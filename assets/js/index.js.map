{"version":3,"file":"index.js","sources":["index.js","webpack/bootstrap 7dc10f272e6c543f0f37","./src/assets/js/index.js","./src/assets/js/demo.js","./src/assets/js/externals.js","./~/hammerjs/hammer.js","(webpack)/buildin/amd-options.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","window","Hammer","toggle","document","querySelector","target","addEventListener","ev","className","indexOf","replace","preventDefault","resetElementStart","el","resetElementEnd","transform","translate","x","startX","y","startY","scale","rotate","requestElementUpdate","updateElementTransform","value","style","webkitTransform","join","ticking","reqAnimationFrame","onPan","deltaX","deltaY","onSwipe","setTimeout","onPinch","onRotate","rotation","onTap","onDoubleTap","onHold","background","prefixed","callback","Math","round","parentNode","offsetWidth","offsetHeight","mc","get","set","on","classList","location","href","_gaq","push","ga","createElement","type","async","src","protocol","s","getElementsByTagName","insertBefore","d","js","fjs","getElementById","__WEBPACK_AMD_DEFINE_RESULT__","undefined","setTimeoutScope","fn","timeout","context","bindFn","each","obj","iterator","i","len","forEach","length","hasOwnProperty","extend","dest","merge","keys","Object","inherit","child","base","properties","childP","baseP","prototype","create","constructor","Inherited","this","_super","apply","arguments","boolOrFn","val","args","TYPE_FUNCTION","ifUndefined","val1","val2","addEventListeners","element","types","handler","splitStr","removeEventListeners","removeEventListener","hasParent","node","parent","inStr","str","find","trim","split","inArray","findByKey","toArray","Array","slice","uniqueArray","key","results","values","property","prefix","prop","camelProp","toUpperCase","VENDOR_PREFIXES","uniqueId","_uniqueId","Input","manager","self","domHandler","options","enable","evEl","evWin","createInputInstance","Type","SUPPORT_POINTER_EVENTS","PointerEventInput","SUPPORT_ONLY_TOUCH","TouchInput","SUPPORT_TOUCH","TouchMouseInput","MouseInput","inputHandler","eventType","input","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","INPUT_START","isFinal","INPUT_END","session","computeInputData","recognize","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","timeStamp","now","deltaTime","angle","getAngle","distance","getDistance","offsetDirection","getDirection","getScale","getRotation","srcEvent","computeIntervalInputData","last","lastInterval","velocity","velocityX","velocityY","direction","COMPUTE_INTERVAL","v","getVelocity","max","clientX","clientY","abs","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","p1","p2","props","PROPS_XY","sqrt","atan2","PI","start","end","PROPS_CLIENT_XY","MOUSE_ELEMENT_EVENTS","MOUSE_WINDOW_EVENTS","allow","pressed","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","store","pointerEvents","TOUCH_EVENTS","targetIds","normalizeTouches","touchInput","targetTouches","changedTouches","changedTargetTouches","identifier","concat","touch","mouse","TouchAction","cleanTouchActions","actions","TOUCH_ACTION_NONE","TOUCH_ACTION_PAN_X","TOUCH_ACTION_PAN_Y","action","test","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_AUTO","Recognizer","defaults","state","STATE_POSSIBLE","simultaneous","requireFail","stateStr","STATE_CANCELLED","STATE_ENDED","STATE_CHANGED","STATE_BEGAN","directionStr","getRecognizerByNameIfManager","otherRecognizer","recognizer","AttrRecognizer","PanRecognizer","pX","pY","PinchRecognizer","PressRecognizer","_timer","_input","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","count","recognizers","easyRecognizers","Manager","handlers","touchAction","toggleCssProps","item","add","recognizeWith","requireFailure","cssProps","name","falseFn","userSelect","onselectstart","userDrag","ondragstart","triggerDomEvent","event","data","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","TYPE_UNDEFINED","Date","MOBILE_REGEX","navigator","userAgent","INPUT_TYPE_TOUCH","INPUT_TYPE_PEN","INPUT_TYPE_MOUSE","INPUT_TYPE_KINECT","INPUT_MOVE","INPUT_CANCEL","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","destroy","elEvents","winEvents","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","mouseout","button","which","relatedTarget","toElement","nodeName","pointerType","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM",2,3,4,5,"MSPointerEvent","removePointer","eventTypeNormalized","toLowerCase","storeIndex","pointerId","splice","TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","touches","inputEvent","inputData","isTouch","isMouse","PREFIXED_TOUCH_ACTION","body","NATIVE_TOUCH_ACTION","TOUCH_ACTION_COMPUTE","compute","update","getTouchAction","preventDefaults","prevented","hasNone","hasPanY","hasPanX","preventSrc","STATE_RECOGNIZED","STATE_FAILED","option","dropRecognizeWith","dropRequireFailure","index","hasRequireFailures","canRecognizeWith","emit","tryEmit","canEmit","inputDataClone","process","reset","attrTest","optionPointers","isRecognized","isValid","threshold","directionTest","hasMoved","inOut","time","validPointers","validMovement","validTime","clearTimeout","taps","interval","posThreshold","validTouchTime","_failTimeout","validInterval","validMultiTap","tapCount","VERSION","domEvents","touchSelect","touchCallout","contentZooming","tapHighlightColor","STOP","FORCED_STOP","stop","force","stopped","curRecognizer","existing","remove","events","off","Tap","Pan","Swipe","Pinch","Rotate","Press","__webpack_amd_options__"],"mappings":"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","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/assets/js/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\twindow.Hammer = __webpack_require__(3);\r\n\t\r\n\tvar toggle = document.querySelector(\".toggle-sidebar\");\r\n\tvar target = document.querySelector(\".sidebar\");\r\n\tif(toggle && target) {\r\n\t    toggle.addEventListener(\"click\", function(ev) {\r\n\t        if(target.className.indexOf('show') === -1) {\r\n\t            target.className += ' show';\r\n\t        } else {\r\n\t            target.className = target.className.replace('show', '');\r\n\t        }\r\n\t        ev.preventDefault();\r\n\t    });\r\n\t}\r\n\t\r\n\t\r\n\tif(document.querySelector(\"#hitarea\")) {\r\n\t    __webpack_require__(1);\r\n\t}\r\n\t\r\n\t__webpack_require__(2);\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * kind of messy code, but good enough for now\r\n\t */\r\n\t// polyfill\r\n\tvar reqAnimationFrame = (function () {\r\n\t    return window[Hammer.prefixed(window, 'requestAnimationFrame')] || function (callback) {\r\n\t        window.setTimeout(callback, 1000 / 60);\r\n\t    };\r\n\t})();\r\n\t\r\n\tvar el = document.querySelector(\"#hitarea\");\r\n\t\r\n\tvar startX = Math.round((el.parentNode.offsetWidth - el.offsetWidth) / 2);\r\n\tvar startY = Math.round((el.parentNode.offsetHeight - el.offsetHeight) / 2);\r\n\t\r\n\tvar ticking = false;\r\n\tvar transform;\r\n\t\r\n\tvar mc = new Hammer(el);\r\n\t\r\n\tmc.get('pinch').set('enable', true);\r\n\tmc.get('rotate').set('enable', true);\r\n\t\r\n\tmc.on(\"pan\", onPan);\r\n\tmc.on(\"swipe\", onSwipe);\r\n\tmc.on(\"rotate\", onRotate);\r\n\tmc.on(\"pinch\", onPinch);\r\n\tmc.on(\"tap\", onTap);\r\n\tmc.on(\"doubletap\", onDoubleTap);\r\n\tmc.on(\"hold\", onHold);\r\n\t\r\n\tmc.on(\"panstart rotatestart pinchstart\", resetElementStart);\r\n\tmc.on(\"panend rotateend pinchend pancancel rotatecancel pinchcancel\", resetElementEnd);\r\n\t\r\n\tfunction resetElementStart() {\r\n\t    el.className = '';\r\n\t}\r\n\t\r\n\tfunction resetElementEnd() {\r\n\t    transform = {\r\n\t        translate: { x: startX, y: startY },\r\n\t        scale: 1,\r\n\t        rotate: 0\r\n\t    };\r\n\t    el.className = 'animate';\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction updateElementTransform() {\r\n\t    var value = [\r\n\t        'translate3d(' + transform.translate.x + 'px, ' + transform.translate.y + 'px, 0)',\r\n\t        'scale(' + transform.scale + ', ' + transform.scale + ')',\r\n\t        'rotate(' + transform.rotate + 'deg)'];\r\n\t    el.style.webkitTransform = el.style.transform = value.join(\" \");\r\n\t    ticking = false;\r\n\t}\r\n\t\r\n\tfunction requestElementUpdate() {\r\n\t    if(!ticking) {\r\n\t        ticking = true;\r\n\t        reqAnimationFrame(updateElementTransform);\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction onPan(ev) {\r\n\t    transform.translate = {\r\n\t        x: startX + ev.deltaX,\r\n\t        y: startY + ev.deltaY\r\n\t    };\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction onSwipe(ev) {\r\n\t    transform.translate = {\r\n\t        x: startX + (ev.deltaX * 1.2),\r\n\t        y: startY + (ev.deltaY * 1.2)\r\n\t    };\r\n\t    transform.scale = 1.2;\r\n\t    requestElementUpdate();\r\n\t\r\n\t    setTimeout(function () {\r\n\t        resetElementEnd();\r\n\t    }, 400);\r\n\t}\r\n\t\r\n\tfunction onPinch(ev) {\r\n\t    transform.scale = ev.scale;\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction onRotate(ev) {\r\n\t    transform.rotate = ev.rotation;\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction onTap(ev) {\r\n\t    transform.scale = .9;\r\n\t    requestElementUpdate();\r\n\t\r\n\t    setTimeout(function () {\r\n\t        transform.scale = 1;\r\n\t        requestElementUpdate();\r\n\t    }, 200);\r\n\t}\r\n\t\r\n\tfunction onDoubleTap(ev) {\r\n\t    transform.rotate = !transform.rotate ? 360 : 0;\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction onHold(ev) {\r\n\t    el.style.background = '#fd0';\r\n\t    setTimeout(function () {\r\n\t        el.style.background = 'white';\r\n\t        requestElementUpdate();\r\n\t    }, 500);\r\n\t}\r\n\t\r\n\tresetElementEnd();\r\n\t\r\n\tdocument.querySelector(\".device-button\").addEventListener(\"click\", function(){\r\n\t    document.querySelector(\".device\").classList.toggle('hammertime');\r\n\t}, false);\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tif(location.href.indexOf(\".github.io\") > -1) {\r\n\t    var _gaq = _gaq || [];\r\n\t    _gaq.push(['_setAccount', 'UA-30289566-1']);\r\n\t    _gaq.push(['_trackPageview']);\r\n\t    (function () {\r\n\t        var ga = document.createElement('script');\r\n\t        ga.type = 'text/javascript';\r\n\t        ga.async = true;\r\n\t        ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';\r\n\t        var s = document.getElementsByTagName('script')[0];\r\n\t        s.parentNode.insertBefore(ga, s);\r\n\t    })();\r\n\t}\r\n\t\r\n\t!function (d, s, id) {\r\n\t    var js, fjs = d.getElementsByTagName(s)[0];\r\n\t    if (!d.getElementById(id)) {\r\n\t        js = d.createElement(s);\r\n\t        js.id = id;\r\n\t        js.src = \"//platform.twitter.com/widgets.js\";\r\n\t        fjs.parentNode.insertBefore(js, fjs);\r\n\t    }\r\n\t}(document, \"script\", \"twitter-wjs\");\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;(function(window, undefined) {\r\n\t  'use strict';\r\n\t\r\n\tvar VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];\r\n\t\r\n\tvar TYPE_FUNCTION = 'function';\r\n\tvar TYPE_UNDEFINED = 'undefined';\r\n\t\r\n\tvar round = Math.round;\r\n\tvar now = Date.now;\r\n\t\r\n\t/**\r\n\t * set a timeout with a given scope\r\n\t * @param {Function} fn\r\n\t * @param {Number} timeout\r\n\t * @param {Object} context\r\n\t * @returns {number}\r\n\t */\r\n\tfunction setTimeoutScope(fn, timeout, context) {\r\n\t    return setTimeout(bindFn(fn, context), timeout);\r\n\t}\r\n\t\r\n\t/**\r\n\t * walk objects and arrays\r\n\t * @param {Object} obj\r\n\t * @param {Function} iterator\r\n\t * @param {Object} context\r\n\t */\r\n\tfunction each(obj, iterator, context) {\r\n\t    var i, len;\r\n\t\r\n\t    if (!obj) {\r\n\t        return;\r\n\t    }\r\n\t\r\n\t    if (obj.forEach) {\r\n\t        obj.forEach(iterator, context);\r\n\t    } else if (obj.length !== undefined) {\r\n\t        for (i = 0, len = obj.length; i < len; i++) {\r\n\t            iterator.call(context, obj[i], i, obj);\r\n\t        }\r\n\t    } else {\r\n\t        for (i in obj) {\r\n\t            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\t/**\r\n\t * extend object.\r\n\t * means that properties in dest will be overwritten by the ones in src.\r\n\t * @param {Object} dest\r\n\t * @param {Object} src\r\n\t * @param {Boolean} [merge]\r\n\t * @returns {Object} dest\r\n\t */\r\n\tfunction extend(dest, src, merge) {\r\n\t    var keys = Object.keys(src);\r\n\t    for (var i = 0, len = keys.length; i < len; i++) {\r\n\t        if (!merge || (merge && dest[keys[i]] === undefined)) {\r\n\t            dest[keys[i]] = src[keys[i]];\r\n\t        }\r\n\t    }\r\n\t    return dest;\r\n\t}\r\n\t\r\n\t/**\r\n\t * merge the values from src in the dest.\r\n\t * means that properties that exist in dest will not be overwritten by src\r\n\t * @param {Object} dest\r\n\t * @param {Object} src\r\n\t * @returns {Object} dest\r\n\t */\r\n\tfunction merge(dest, src) {\r\n\t    return extend(dest, src, true);\r\n\t}\r\n\t\r\n\t/**\r\n\t * simple class inheritance\r\n\t * @param {Function} child\r\n\t * @param {Function} base\r\n\t * @param {Object} [properties]\r\n\t */\r\n\tfunction inherit(child, base, properties) {\r\n\t    var baseP = base.prototype,\r\n\t        childP;\r\n\t\r\n\t    // object create is supported since IE9\r\n\t    if (Object.create) {\r\n\t        childP = child.prototype = Object.create(baseP);\r\n\t        childP.constructor = child;\r\n\t    } else {\r\n\t        extend(child, base);\r\n\t        var Inherited = function() {\r\n\t            this.constructor = child;\r\n\t        };\r\n\t        Inherited.prototype = baseP;\r\n\t        childP = child.prototype = new Inherited();\r\n\t    }\r\n\t\r\n\t    if (properties) {\r\n\t        extend(childP, properties);\r\n\t    }\r\n\t\r\n\t    childP._super = baseP;\r\n\t}\r\n\t\r\n\t/**\r\n\t * simple function bind\r\n\t * @param {Function} fn\r\n\t * @param {Object} context\r\n\t * @returns {Function}\r\n\t */\r\n\tfunction bindFn(fn, context) {\r\n\t    return function() {\r\n\t        return fn.apply(context, arguments);\r\n\t    };\r\n\t}\r\n\t\r\n\t/**\r\n\t * let a boolean value also be a function that must return a boolean\r\n\t * this first item in args will be used as the context\r\n\t * @param {Boolean|Function} val\r\n\t * @param {Array} [args]\r\n\t * @returns {Boolean}\r\n\t */\r\n\tfunction boolOrFn(val, args) {\r\n\t    if (typeof val == TYPE_FUNCTION) {\r\n\t        return val.apply(args ? args[0] || window : window, args);\r\n\t    }\r\n\t    return val;\r\n\t}\r\n\t\r\n\t/**\r\n\t * use the val2 when val1 is undefined\r\n\t * @param {*} val1\r\n\t * @param {*} val2\r\n\t * @returns {*}\r\n\t */\r\n\tfunction ifUndefined(val1, val2) {\r\n\t    return (val1 === undefined) ? val2 : val1;\r\n\t}\r\n\t\r\n\t/**\r\n\t * addEventListener with multiple events at once\r\n\t * @param {HTMLElement} element\r\n\t * @param {String} types\r\n\t * @param {Function} handler\r\n\t */\r\n\tfunction addEventListeners(element, types, handler) {\r\n\t    each(splitStr(types), function(type) {\r\n\t        element.addEventListener(type, handler, false);\r\n\t    });\r\n\t}\r\n\t\r\n\t/**\r\n\t * removeEventListener with multiple events at once\r\n\t * @param {HTMLElement} element\r\n\t * @param {String} types\r\n\t * @param {Function} handler\r\n\t */\r\n\tfunction removeEventListeners(element, types, handler) {\r\n\t    each(splitStr(types), function(type) {\r\n\t        element.removeEventListener(type, handler, false);\r\n\t    });\r\n\t}\r\n\t\r\n\t/**\r\n\t * find if a node is in the given parent\r\n\t * @method hasParent\r\n\t * @param {HTMLElement} node\r\n\t * @param {HTMLElement} parent\r\n\t * @return {Boolean} found\r\n\t */\r\n\tfunction hasParent(node, parent) {\r\n\t    while (node) {\r\n\t        if (node == parent) {\r\n\t            return true;\r\n\t        }\r\n\t        node = node.parentNode;\r\n\t    }\r\n\t    return false;\r\n\t}\r\n\t\r\n\t/**\r\n\t * small indexOf wrapper\r\n\t * @param {String} str\r\n\t * @param {String} find\r\n\t * @returns {Boolean} found\r\n\t */\r\n\tfunction inStr(str, find) {\r\n\t    return str.indexOf(find) > -1;\r\n\t}\r\n\t\r\n\t/**\r\n\t * split string on whitespace\r\n\t * @param {String} str\r\n\t * @returns {Array} words\r\n\t */\r\n\tfunction splitStr(str) {\r\n\t    return str.trim().split(/\\s+/g);\r\n\t}\r\n\t\r\n\t/**\r\n\t * find if a array contains the object using indexOf or a simple polyFill\r\n\t * @param {Array} src\r\n\t * @param {String} find\r\n\t * @param {String} [findByKey]\r\n\t * @return {Boolean|Number} false when not found, or the index\r\n\t */\r\n\tfunction inArray(src, find, findByKey) {\r\n\t    if (src.indexOf && !findByKey) {\r\n\t        return src.indexOf(find);\r\n\t    } else {\r\n\t        for (var i = 0, len = src.length; i < len; i++) {\r\n\t            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\r\n\t                return i;\r\n\t            }\r\n\t        }\r\n\t        return -1;\r\n\t    }\r\n\t}\r\n\t\r\n\t/**\r\n\t * convert array-like objects to real arrays\r\n\t * @param {Object} obj\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction toArray(obj) {\r\n\t    return Array.prototype.slice.call(obj, 0);\r\n\t}\r\n\t\r\n\t/**\r\n\t * unique array with objects based on a key (like 'id') or just by the array's value\r\n\t * @param {Array} src [{id:1},{id:2},{id:1}]\r\n\t * @param {String} [key]\r\n\t * @returns {Array} [{id:1},{id:2}]\r\n\t */\r\n\tfunction uniqueArray(src, key) {\r\n\t    var results = [];\r\n\t    var values = [];\r\n\t    for (var i = 0, len = src.length; i < len; i++) {\r\n\t        var val = key ? src[i][key] : src[i];\r\n\t        if (inArray(values, val) < 0) {\r\n\t            results.push(src[i]);\r\n\t        }\r\n\t        values[i] = val;\r\n\t    }\r\n\t    return results;\r\n\t}\r\n\t\r\n\t/**\r\n\t * get the prefixed property\r\n\t * @param {Object} obj\r\n\t * @param {String} property\r\n\t * @returns {String|Undefined} prefixed\r\n\t */\r\n\tfunction prefixed(obj, property) {\r\n\t    var prefix, prop;\r\n\t    var camelProp = property[0].toUpperCase() + property.slice(1);\r\n\t\r\n\t    for (var i = 0, len = VENDOR_PREFIXES.length; i < len; i++) {\r\n\t        prefix = VENDOR_PREFIXES[i];\r\n\t        prop = (prefix) ? prefix + camelProp : property;\r\n\t\r\n\t        if (prop in obj) {\r\n\t            return prop;\r\n\t        }\r\n\t    }\r\n\t    return undefined;\r\n\t}\r\n\t\r\n\t/**\r\n\t * get a unique id\r\n\t * @returns {number} uniqueId\r\n\t */\r\n\tvar _uniqueId = 1;\r\n\tfunction uniqueId() {\r\n\t    return _uniqueId++;\r\n\t}\r\n\t\r\n\tvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\r\n\t\r\n\tvar SUPPORT_TOUCH = ('ontouchstart' in window);\r\n\tvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\r\n\tvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\r\n\t\r\n\tvar INPUT_TYPE_TOUCH = 'touch';\r\n\tvar INPUT_TYPE_PEN = 'pen';\r\n\tvar INPUT_TYPE_MOUSE = 'mouse';\r\n\tvar INPUT_TYPE_KINECT = 'kinect';\r\n\t\r\n\tvar COMPUTE_INTERVAL = 25;\r\n\t\r\n\tvar INPUT_START = 1;\r\n\tvar INPUT_MOVE = 2;\r\n\tvar INPUT_END = 4;\r\n\tvar INPUT_CANCEL = 8;\r\n\t\r\n\tvar DIRECTION_NONE = 1;\r\n\tvar DIRECTION_LEFT = 2;\r\n\tvar DIRECTION_RIGHT = 4;\r\n\tvar DIRECTION_UP = 8;\r\n\tvar DIRECTION_DOWN = 16;\r\n\t\r\n\tvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\r\n\tvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\r\n\tvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\r\n\t\r\n\tvar PROPS_XY = ['x', 'y'];\r\n\tvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\r\n\t\r\n\t/**\r\n\t * create new input type manager\r\n\t * @param {Manager} manager\r\n\t * @param {Function} callback\r\n\t * @returns {Input}\r\n\t * @constructor\r\n\t */\r\n\tfunction Input(manager, callback) {\r\n\t    var self = this;\r\n\t    this.manager = manager;\r\n\t    this.callback = callback;\r\n\t\r\n\t    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\r\n\t    // so when disabled the input events are completely bypassed.\r\n\t    this.domHandler = function(ev) {\r\n\t        if (boolOrFn(self.manager.options.enable, [self.manager])) {\r\n\t            self.handler(ev);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    this.evEl && addEventListeners(this.manager.element, this.evEl, this.domHandler);\r\n\t    this.evWin && addEventListeners(window, this.evWin, this.domHandler);\r\n\t}\r\n\t\r\n\tInput.prototype = {\r\n\t    /**\r\n\t     * should handle the inputEvent data and trigger the callback\r\n\t     * @virtual\r\n\t     */\r\n\t    handler: function() { },\r\n\t\r\n\t    /**\r\n\t     * unbind the events\r\n\t     */\r\n\t    destroy: function() {\r\n\t        this.elEvents && removeEventListeners(this.manager.element, this.elEvents, this.domHandler);\r\n\t        this.winEvents && removeEventListeners(window, this.winEvents, this.domHandler);\r\n\t    }\r\n\t};\r\n\t\r\n\t/**\r\n\t * create new input type manager\r\n\t * @param {Hammer} manager\r\n\t * @returns {Input}\r\n\t */\r\n\tfunction createInputInstance(manager) {\r\n\t    var Type;\r\n\t    if (SUPPORT_POINTER_EVENTS) {\r\n\t        Type = PointerEventInput;\r\n\t    } else if (SUPPORT_ONLY_TOUCH) {\r\n\t        Type = TouchInput;\r\n\t    } else if (!SUPPORT_TOUCH) {\r\n\t        Type = MouseInput;\r\n\t    } else {\r\n\t        Type = TouchMouseInput;\r\n\t    }\r\n\t    return new (Type)(manager, inputHandler);\r\n\t}\r\n\t\r\n\t/**\r\n\t * handle input events\r\n\t * @param {Manager} manager\r\n\t * @param {String} eventType\r\n\t * @param {Object} input\r\n\t */\r\n\tfunction inputHandler(manager, eventType, input) {\r\n\t    var pointersLen = input.pointers.length;\r\n\t    var changedPointersLen = input.changedPointers.length;\r\n\t    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\r\n\t    var isFinal = (eventType & INPUT_END && (pointersLen - changedPointersLen === 0));\r\n\t\r\n\t    input.isFirst = isFirst;\r\n\t    input.isFinal = isFinal;\r\n\t\r\n\t    if (isFirst) {\r\n\t        manager.session = {};\r\n\t    }\r\n\t    // source event is the normalized value of the domEvents\r\n\t    // like 'touchstart, mouseup, pointerdown'\r\n\t    input.eventType = eventType;\r\n\t\r\n\t    // compute scale, rotation etc\r\n\t    computeInputData(manager, input);\r\n\t\r\n\t    manager.recognize(input);\r\n\t}\r\n\t\r\n\t/**\r\n\t * extend the data with some usable properties like scale, rotate, velocity etc\r\n\t * @param {Object} manager\r\n\t * @param {Object} input\r\n\t */\r\n\tfunction computeInputData(manager, input) {\r\n\t    var session = manager.session;\r\n\t    var pointers = input.pointers;\r\n\t    var pointersLength = pointers.length;\r\n\t\r\n\t    // store the first input to calculate the distance and direction\r\n\t    if (!session.firstInput) {\r\n\t        session.firstInput = simpleCloneInputData(input);\r\n\t    }\r\n\t\r\n\t    // to compute scale and rotation we need to store the multiple touches\r\n\t    if (pointersLength > 1 && !session.firstMultiple) {\r\n\t        session.firstMultiple = simpleCloneInputData(input);\r\n\t    } else if (pointersLength === 1) {\r\n\t        session.firstMultiple = false;\r\n\t    }\r\n\t\r\n\t    var firstInput = session.firstInput;\r\n\t    var firstMultiple = session.firstMultiple;\r\n\t    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\r\n\t    var center = getCenter(pointers);\r\n\t\r\n\t    input.timeStamp = now();\r\n\t    input.deltaTime = input.timeStamp - firstInput.timeStamp;\r\n\t    input.deltaX = center.x - offsetCenter.x;\r\n\t    input.deltaY = center.y - offsetCenter.y;\r\n\t\r\n\t    input.center = center;\r\n\t    input.angle = getAngle(offsetCenter, center);\r\n\t    input.distance = getDistance(offsetCenter, center);\r\n\t    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\r\n\t\r\n\t    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\r\n\t    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\r\n\t\r\n\t    // find the correct target\r\n\t    var target = manager.element;\r\n\t    if (hasParent(input.srcEvent.target, target)) {\r\n\t        target = input.srcEvent.target;\r\n\t    }\r\n\t    input.target = target;\r\n\t\r\n\t    computeIntervalInputData(session, input);\r\n\t}\r\n\t\r\n\t/**\r\n\t * velocity is calculated every x ms\r\n\t * @param {Object} session\r\n\t * @param {Object} input\r\n\t */\r\n\tfunction computeIntervalInputData(session, input) {\r\n\t    var last = session.lastInterval;\r\n\t    if (!last) {\r\n\t        last = session.lastInterval = simpleCloneInputData(input);\r\n\t    }\r\n\t\r\n\t    var deltaTime = input.timeStamp - last.timeStamp,\r\n\t        velocity,\r\n\t        velocityX,\r\n\t        velocityY,\r\n\t        direction;\r\n\t\r\n\t    if (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined) {\r\n\t        var deltaX = last.deltaX - input.deltaX;\r\n\t        var deltaY = last.deltaY - input.deltaY;\r\n\t\r\n\t        var v = getVelocity(deltaTime, deltaX, deltaY);\r\n\t        velocityX = v.x;\r\n\t        velocityY = v.y;\r\n\t        velocity = Math.max(v.x, v.y);\r\n\t        direction = getDirection(deltaX, deltaY);\r\n\t    } else {\r\n\t        // use latest velocity info if it doesn't overtake a minimum period\r\n\t        velocity = last.velocity;\r\n\t        velocityX = last.velocityX;\r\n\t        velocityY = last.velocityY;\r\n\t        direction = last.direction;\r\n\t    }\r\n\t\r\n\t    input.velocity = velocity;\r\n\t    input.velocityX = velocityX;\r\n\t    input.velocityY = velocityY;\r\n\t    input.direction = direction;\r\n\t}\r\n\t\r\n\t/**\r\n\t * create a simple clone from the input used for storage of firstInput and firstMultiple\r\n\t * @param {Object} input\r\n\t * @returns {Object} clonedInputData\r\n\t */\r\n\tfunction simpleCloneInputData(input) {\r\n\t    // make a simple copy of the pointers because we will get a reference if we don't\r\n\t    // we only need clientXY for the calculations\r\n\t    var pointers = [];\r\n\t    for (var i = 0; i < input.pointers.length; i++) {\r\n\t        pointers[i] = {\r\n\t            clientX: round(input.pointers[i].clientX),\r\n\t            clientY: round(input.pointers[i].clientY)\r\n\t        };\r\n\t    }\r\n\t\r\n\t    return {\r\n\t        timeStamp: now(),\r\n\t        pointers: pointers,\r\n\t        center: getCenter(pointers),\r\n\t        deltaX: input.deltaX,\r\n\t        deltaY: input.deltaY\r\n\t    };\r\n\t}\r\n\t\r\n\t/**\r\n\t * get the center of all the pointers\r\n\t * @param {Array} pointers\r\n\t * @return {Object} center contains `x` and `y` properties\r\n\t */\r\n\tfunction getCenter(pointers) {\r\n\t    var pointersLength = pointers.length;\r\n\t\r\n\t    // no need to loop when only one touch\r\n\t    if (pointersLength === 1) {\r\n\t        return {\r\n\t            x: round(pointers[0].clientX),\r\n\t            y: round(pointers[0].clientY)\r\n\t        };\r\n\t    }\r\n\t\r\n\t    var x = 0, y = 0;\r\n\t    for (var i = 0; i < pointersLength; i++) {\r\n\t        x += pointers[i].clientX;\r\n\t        y += pointers[i].clientY;\r\n\t    }\r\n\t\r\n\t    return {\r\n\t        x: round(x / pointersLength),\r\n\t        y: round(y / pointersLength)\r\n\t    };\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the velocity between two points. unit is in px per ms.\r\n\t * @param {Number} deltaTime\r\n\t * @param {Number} x\r\n\t * @param {Number} y\r\n\t * @return {Object} velocity `x` and `y`\r\n\t */\r\n\tfunction getVelocity(deltaTime, x, y) {\r\n\t    return {\r\n\t        x: Math.abs(x / deltaTime) || 0,\r\n\t        y: Math.abs(y / deltaTime) || 0\r\n\t    };\r\n\t}\r\n\t\r\n\t/**\r\n\t * get the direction between two points\r\n\t * @param {Number} x\r\n\t * @param {Number} y\r\n\t * @return {Number} direction\r\n\t */\r\n\tfunction getDirection(x, y) {\r\n\t    if (x === y) {\r\n\t        return DIRECTION_NONE;\r\n\t    }\r\n\t\r\n\t    if (Math.abs(x) >= Math.abs(y)) {\r\n\t        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n\t    }\r\n\t    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the absolute distance between two points\r\n\t * @param {Object} p1 {x, y}\r\n\t * @param {Object} p2 {x, y}\r\n\t * @param {Array} [props] containing x and y keys\r\n\t * @return {Number} distance\r\n\t */\r\n\tfunction getDistance(p1, p2, props) {\r\n\t    if (!props) {\r\n\t        props = PROPS_XY;\r\n\t    }\r\n\t    var x = p2[props[0]] - p1[props[0]],\r\n\t        y = p2[props[1]] - p1[props[1]];\r\n\t\r\n\t    return Math.sqrt((x * x) + (y * y));\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the angle between two coordinates\r\n\t * @param {Object} p1\r\n\t * @param {Object} p2\r\n\t * @param {Array} [props] containing x and y keys\r\n\t * @return {Number} angle\r\n\t */\r\n\tfunction getAngle(p1, p2, props) {\r\n\t    if (!props) {\r\n\t        props = PROPS_XY;\r\n\t    }\r\n\t    var x = p2[props[0]] - p1[props[0]],\r\n\t        y = p2[props[1]] - p1[props[1]];\r\n\t    return Math.atan2(y, x) * 180 / Math.PI;\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the rotation degrees between two pointersets\r\n\t * @param {Array} start array of pointers\r\n\t * @param {Array} end array of pointers\r\n\t * @return {Number} rotation\r\n\t */\r\n\tfunction getRotation(start, end) {\r\n\t    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the scale factor between two pointersets\r\n\t * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\r\n\t * @param {Array} start array of pointers\r\n\t * @param {Array} end array of pointers\r\n\t * @return {Number} scale\r\n\t */\r\n\tfunction getScale(start, end) {\r\n\t    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\r\n\t}\r\n\t\r\n\tvar MOUSE_INPUT_MAP = {\r\n\t    mousedown: INPUT_START,\r\n\t    mousemove: INPUT_MOVE,\r\n\t    mouseup: INPUT_END,\r\n\t    mouseout: INPUT_CANCEL\r\n\t};\r\n\t\r\n\tvar MOUSE_ELEMENT_EVENTS = 'mousedown';\r\n\tvar MOUSE_WINDOW_EVENTS = 'mousemove mouseout mouseup';\r\n\t\r\n\t/**\r\n\t * Mouse events input\r\n\t * @constructor\r\n\t * @extends Input\r\n\t */\r\n\tfunction MouseInput() {\r\n\t    this.evEl = MOUSE_ELEMENT_EVENTS;\r\n\t    this.evWin = MOUSE_WINDOW_EVENTS;\r\n\t\r\n\t    this.allow = true; // used by Input.TouchMouse to disable mouse events\r\n\t    this.pressed = false; // mousedown state\r\n\t\r\n\t    Input.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(MouseInput, Input, {\r\n\t    /**\r\n\t     * handle mouse events\r\n\t     * @param {Object} ev\r\n\t     */\r\n\t    handler: function(ev) {\r\n\t        var eventType = MOUSE_INPUT_MAP[ev.type];\r\n\t\r\n\t        // on start we want to have the left mouse button down\r\n\t        if (eventType & INPUT_START && ev.button === 0) {\r\n\t            this.pressed = true;\r\n\t        }\r\n\t\r\n\t        if (eventType & INPUT_MOVE && ev.which !== 1) {\r\n\t            eventType = INPUT_END;\r\n\t        }\r\n\t\r\n\t        // mouse must be down, and mouse events are allowed (see the TouchMouse input)\r\n\t        if (!this.pressed || !this.allow) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        // out of the window?\r\n\t        var target = ev.relatedTarget || ev.toElement || ev.target;\r\n\t        if (ev.type == 'mouseout' && target.nodeName != 'HTML') {\r\n\t            eventType = INPUT_MOVE;\r\n\t        }\r\n\t\r\n\t        if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n\t            this.pressed = false;\r\n\t        }\r\n\t\r\n\t        this.callback(this.manager, eventType, {\r\n\t            pointers: [ev],\r\n\t            changedPointers: [ev],\r\n\t            pointerType: INPUT_TYPE_MOUSE,\r\n\t            srcEvent: ev\r\n\t        });\r\n\t    },\r\n\t});\r\n\t\r\n\tvar POINTER_INPUT_MAP = {\r\n\t    pointerdown: INPUT_START,\r\n\t    pointermove: INPUT_MOVE,\r\n\t    pointerup: INPUT_END,\r\n\t    pointercancel: INPUT_CANCEL,\r\n\t    pointerout: INPUT_CANCEL\r\n\t};\r\n\t\r\n\t// in IE10 the pointer types is defined as an enum\r\n\tvar IE10_POINTER_TYPE_ENUM = {\r\n\t    2: INPUT_TYPE_TOUCH,\r\n\t    3: INPUT_TYPE_PEN,\r\n\t    4: INPUT_TYPE_MOUSE,\r\n\t    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\r\n\t};\r\n\t\r\n\tvar POINTER_ELEMENT_EVENTS = 'pointerdown pointermove pointerup pointercancel';\r\n\tvar POINTER_WINDOW_EVENTS = 'pointerout';\r\n\t\r\n\t// IE10 has prefixed support, and case-sensitive\r\n\tif (window.MSPointerEvent) {\r\n\t    POINTER_ELEMENT_EVENTS = 'MSPointerDown MSPointerMove MSPointerUp MSPointerCancel';\r\n\t    POINTER_WINDOW_EVENTS = 'MSPointerOut';\r\n\t}\r\n\t\r\n\t/**\r\n\t * Pointer events input\r\n\t * @constructor\r\n\t * @extends Input\r\n\t */\r\n\tfunction PointerEventInput() {\r\n\t    this.evEl = POINTER_ELEMENT_EVENTS;\r\n\t    this.evWin = POINTER_WINDOW_EVENTS;\r\n\t\r\n\t    Input.apply(this, arguments);\r\n\t\r\n\t    this.store = (this.manager.session.pointerEvents = []);\r\n\t}\r\n\t\r\n\tinherit(PointerEventInput, Input, {\r\n\t    /**\r\n\t     * handle mouse events\r\n\t     * @param {Object} ev\r\n\t     */\r\n\t    handler: function(ev) {\r\n\t        var store = this.store;\r\n\t        var removePointer = false;\r\n\t\r\n\t        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\r\n\t        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\r\n\t        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\r\n\t\r\n\t        // out of the window?\r\n\t        var target = ev.relatedTarget || ev.toElement || ev.target;\r\n\t        if (eventTypeNormalized == 'pointerout' && target.nodeName != 'HTML') {\r\n\t            eventType = INPUT_MOVE;\r\n\t        }\r\n\t\r\n\t        // start and mouse must be down\r\n\t        if (eventType & INPUT_START && (ev.button === 0 || pointerType == INPUT_TYPE_TOUCH)) {\r\n\t            store.push(ev);\r\n\t        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n\t            removePointer = true;\r\n\t        }\r\n\t\r\n\t        // get index of the event in the store\r\n\t        // it not found, so the pointer hasn't been down (so it's probably a hover)\r\n\t        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\r\n\t        if (storeIndex < 0) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        // update the event in the store\r\n\t        store[storeIndex] = ev;\r\n\t\r\n\t        this.callback(this.manager, eventType, {\r\n\t            pointers: store,\r\n\t            changedPointers: [ev],\r\n\t            pointerType: pointerType,\r\n\t            srcEvent: ev\r\n\t        });\r\n\t\r\n\t        if (removePointer) {\r\n\t            // remove from the store\r\n\t            store.splice(storeIndex, 1);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\tvar TOUCH_INPUT_MAP = {\r\n\t    touchstart: INPUT_START,\r\n\t    touchmove: INPUT_MOVE,\r\n\t    touchend: INPUT_END,\r\n\t    touchcancel: INPUT_CANCEL\r\n\t};\r\n\t\r\n\tvar TOUCH_EVENTS = 'touchstart touchmove touchend touchcancel';\r\n\t\r\n\t/**\r\n\t * Touch events input\r\n\t * @constructor\r\n\t * @extends Input\r\n\t */\r\n\tfunction TouchInput() {\r\n\t    this.evEl = TOUCH_EVENTS;\r\n\t    this.targetIds = {};\r\n\t\r\n\t    Input.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(TouchInput, Input, {\r\n\t    /**\r\n\t     * handle touch events\r\n\t     * @param {Object} ev\r\n\t     */\r\n\t    handler: function(ev) {\r\n\t        var touches = normalizeTouches(ev, this);\r\n\t        this.callback(this.manager, TOUCH_INPUT_MAP[ev.type], {\r\n\t            pointers: touches[0],\r\n\t            changedPointers: touches[1],\r\n\t            pointerType: INPUT_TYPE_TOUCH,\r\n\t            srcEvent: ev\r\n\t        });\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * make sure all browsers return the same touches\r\n\t * @param {Object} ev\r\n\t * @param {TouchInput} touchInput\r\n\t * @returns {Array} [all, changed]\r\n\t */\r\n\tfunction normalizeTouches(ev, touchInput) {\r\n\t    var i, len;\r\n\t\r\n\t    var targetIds = touchInput.targetIds;\r\n\t    var targetTouches = toArray(ev.targetTouches);\r\n\t    var changedTouches = toArray(ev.changedTouches);\r\n\t    var changedTargetTouches = [];\r\n\t\r\n\t    // collect touches\r\n\t    if (ev.type == 'touchstart') {\r\n\t        for (i = 0, len = targetTouches.length; i < len; i++) {\r\n\t            targetIds[targetTouches[i].identifier] = true;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    // filter changed touches to only contain touches that exist in the collected target ids\r\n\t    for (i = 0, len = changedTouches.length; i < len; i++) {\r\n\t        if (targetIds[changedTouches[i].identifier]) {\r\n\t            changedTargetTouches.push(changedTouches[i]);\r\n\t        }\r\n\t\r\n\t        // cleanup removed touches\r\n\t        if (ev.type == 'touchend'|| ev.type == 'touchcancel') {\r\n\t            delete targetIds[changedTouches[i].identifier];\r\n\t        }\r\n\t    }\r\n\t\r\n\t    return [\r\n\t        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\r\n\t        // also removed the duplicates\r\n\t        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier'),\r\n\t\r\n\t        // only the changed :-)\r\n\t        changedTargetTouches\r\n\t    ];\r\n\t}\r\n\t\r\n\t/**\r\n\t * Combined touch and mouse input\r\n\t *\r\n\t * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\r\n\t * This because touch devices also emit mouse events while doing a touch.\r\n\t *\r\n\t * @constructor\r\n\t * @extends Input\r\n\t */\r\n\tfunction TouchMouseInput() {\r\n\t    Input.apply(this, arguments);\r\n\t\r\n\t    var handler = bindFn(this.handler, this);\r\n\t    this.touch = new TouchInput(this.manager, handler);\r\n\t    this.mouse = new MouseInput(this.manager, handler);\r\n\t}\r\n\t\r\n\tinherit(TouchMouseInput, Input, {\r\n\t    /**\r\n\t     * handle mouse and touch events\r\n\t     * @param {Hammer} manager\r\n\t     * @param {String} inputEvent\r\n\t     * @param {Object} inputData\r\n\t     */\r\n\t    handler: function(manager, inputEvent, inputData) {\r\n\t        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\r\n\t            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\r\n\t\r\n\t        // when we're in a touch event, so  block all upcoming mouse events\r\n\t        // most mobile browser also emit mouseevents, right after touchstart\r\n\t        if (isTouch) {\r\n\t            this.mouse.allow = false;\r\n\t        } else if (isMouse && !this.mouse.allow) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        // reset the allowMouse when we're done\r\n\t        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {\r\n\t            this.mouse.allow = true;\r\n\t        }\r\n\t\r\n\t        this.callback(manager, inputEvent, inputData);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * remove the event listeners\r\n\t     */\r\n\t    destroy: function() {\r\n\t        this.touch.destroy();\r\n\t        this.mouse.destroy();\r\n\t    }\r\n\t});\r\n\t\r\n\tvar PREFIXED_TOUCH_ACTION = prefixed(document.body.style, 'touchAction');\r\n\tvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\r\n\t\r\n\t// magical touchAction value\r\n\tvar TOUCH_ACTION_COMPUTE = 'compute';\r\n\tvar TOUCH_ACTION_AUTO = 'auto';\r\n\tvar TOUCH_ACTION_MANIPULATION = 'manipulation';\r\n\tvar TOUCH_ACTION_NONE = 'none';\r\n\tvar TOUCH_ACTION_PAN_X = 'pan-x';\r\n\tvar TOUCH_ACTION_PAN_Y = 'pan-y';\r\n\t\r\n\t/**\r\n\t * Touch Action\r\n\t * sets the touchAction property or uses the js alternative\r\n\t * @param {Manager} manager\r\n\t * @param {String} value\r\n\t * @constructor\r\n\t */\r\n\tfunction TouchAction(manager, value) {\r\n\t    this.manager = manager;\r\n\t    this.set(value);\r\n\t}\r\n\t\r\n\tTouchAction.prototype = {\r\n\t    /**\r\n\t     * set the touchAction value on the element or enable the polyfill\r\n\t     * @param {String} value\r\n\t     */\r\n\t    set: function(value) {\r\n\t        // find out the touch-action by the event handlers\r\n\t        if (value == TOUCH_ACTION_COMPUTE) {\r\n\t            value = this.compute();\r\n\t        }\r\n\t\r\n\t        if (NATIVE_TOUCH_ACTION) {\r\n\t            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\r\n\t        }\r\n\t        this.actions = value.toLowerCase();\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * just re-set the touchAction value\r\n\t     */\r\n\t    update: function() {\r\n\t        this.set(this.manager.options.touchAction);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * compute the value for the touchAction property based on the recognizer's settings\r\n\t     * @returns {String} value\r\n\t     */\r\n\t    compute: function() {\r\n\t        var value;\r\n\t        var actions = [];\r\n\t\r\n\t        each(this.manager.recognizers, function(recognizer) {\r\n\t            if (boolOrFn(recognizer.options.enable, recognizer)) {\r\n\t                actions = actions.concat(recognizer.getTouchAction());\r\n\t            }\r\n\t        });\r\n\t        value = uniqueArray(actions).join(' ');\r\n\t        return cleanTouchActions(value);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * this method is called on each input cycle and provides the preventing of the browser behavior\r\n\t     * @param {Object} input\r\n\t     */\r\n\t    preventDefaults: function(input) {\r\n\t        // not needed with native support for the touchAction property\r\n\t        if (NATIVE_TOUCH_ACTION) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var srcEvent = input.srcEvent;\r\n\t        var direction = input.offsetDirection;\r\n\t\r\n\t        // if the touch action did prevented once this session\r\n\t        if (this.manager.session.prevented) {\r\n\t            srcEvent.preventDefault();\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var actions = this.actions;\r\n\t        var hasNone = inStr(actions, TOUCH_ACTION_NONE);\r\n\t        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\r\n\t        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\r\n\t\r\n\t        if (hasNone || (hasPanY && hasPanX) ||\r\n\t            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\r\n\t            (hasPanX && direction & DIRECTION_VERTICAL)) {\r\n\t            return this.preventSrc(srcEvent);\r\n\t        }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\r\n\t     * @param {Object} srcEvent\r\n\t     */\r\n\t    preventSrc: function(srcEvent) {\r\n\t        this.manager.session.prevented = true;\r\n\t        srcEvent.preventDefault();\r\n\t    }\r\n\t};\r\n\t\r\n\t/**\r\n\t * when the touchActions are collected they are not a valid value, so we need to clean things up. *\r\n\t * @param {String} actions\r\n\t * @returns {*}\r\n\t */\r\n\tfunction cleanTouchActions(actions) {\r\n\t    // none\r\n\t    if (inStr(actions, TOUCH_ACTION_NONE)) {\r\n\t        return TOUCH_ACTION_NONE;\r\n\t    }\r\n\t    // pan-x and pan-y can be combined\r\n\t    if (inStr(actions, TOUCH_ACTION_PAN_X) || inStr(actions, TOUCH_ACTION_PAN_Y)) {\r\n\t        return actions.replace(/[\\-\\w]+/g, function(action) {\r\n\t            if (/^pan\\-/.test(action)) {\r\n\t                return action;\r\n\t            }\r\n\t            return '';\r\n\t        });\r\n\t    }\r\n\t    // manipulation\r\n\t    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\r\n\t        return TOUCH_ACTION_MANIPULATION;\r\n\t    }\r\n\t\r\n\t    return TOUCH_ACTION_AUTO;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Recognizer flow explained; *\r\n\t * All recognizers have the initial state of POSSIBLE when a input session starts.\r\n\t * The definition of a input session is from the first input until the last input, with all it's movement in it. *\r\n\t * Example session for mouse-input: mousedown -> mousemove -> mouseup\r\n\t *\r\n\t * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\r\n\t * which determines with state it should be.\r\n\t *\r\n\t * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\r\n\t * POSSIBLE to give it another change on the next cycle.\r\n\t *\r\n\t *               Possible\r\n\t *                  |\r\n\t *            +-----+---------------+\r\n\t *            |                     |\r\n\t *      +-----+-----+               |\r\n\t *      |           |               |\r\n\t *   Failed      Cancelled          |\r\n\t *                          +-------+------+\r\n\t *                          |              |\r\n\t *                      Recognized       Began\r\n\t *                                         |\r\n\t *                                      Changed\r\n\t *                                         |\r\n\t *                                  Ended/Recognized\r\n\t */\r\n\tvar STATE_POSSIBLE = 1;\r\n\tvar STATE_BEGAN = 2;\r\n\tvar STATE_CHANGED = 4;\r\n\tvar STATE_ENDED = 8;\r\n\tvar STATE_RECOGNIZED = STATE_ENDED;\r\n\tvar STATE_CANCELLED = 16;\r\n\tvar STATE_FAILED = 32;\r\n\t\r\n\t/**\r\n\t * Recognizer\r\n\t * Every recognizer needs to extend from this class.\r\n\t * @constructor\r\n\t * @param {Object} options\r\n\t */\r\n\tfunction Recognizer(options) {\r\n\t    this.id = uniqueId();\r\n\t\r\n\t    this.manager = null;\r\n\t    this.options = merge(options || {}, this.defaults);\r\n\t\r\n\t    // default is enable true\r\n\t    this.options.enable = ifUndefined(this.options.enable, true);\r\n\t\r\n\t    this.state = STATE_POSSIBLE;\r\n\t\r\n\t    this.simultaneous = {};\r\n\t    this.requireFail = [];\r\n\t}\r\n\t\r\n\tRecognizer.prototype = {\r\n\t    /**\r\n\t     * @virtual\r\n\t     * @type {Object}\r\n\t     */\r\n\t    defaults: {},\r\n\t\r\n\t    /**\r\n\t     * set options\r\n\t     * @param {String} option\r\n\t     * @param {*} val\r\n\t     */\r\n\t    set: function(option, val) {\r\n\t        this.options[option] = val;\r\n\t\r\n\t        // also update the touchAction, in case something changed about the directions/enabled state\r\n\t        this.manager && this.manager.touchAction.update();\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * recognize simultaneous with an other recognizer.\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Recognizer} this\r\n\t     */\r\n\t    recognizeWith: function(otherRecognizer) {\r\n\t        var simultaneous = this.simultaneous;\r\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n\t        if (!simultaneous[otherRecognizer.id]) {\r\n\t            simultaneous[otherRecognizer.id] = otherRecognizer;\r\n\t            otherRecognizer.recognizeWith(this);\r\n\t        }\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Recognizer} this\r\n\t     */\r\n\t    dropRecognizeWith: function(otherRecognizer) {\r\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n\t        delete this.simultaneous[otherRecognizer.id];\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * recognizer can only run when an other is failing\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Recognizer} this\r\n\t     */\r\n\t    requireFailure: function(otherRecognizer) {\r\n\t        var requireFail = this.requireFail;\r\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n\t        if (inArray(requireFail, otherRecognizer) === -1) {\r\n\t            requireFail.push(otherRecognizer);\r\n\t            otherRecognizer.requireFailure(this);\r\n\t        }\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * drop the requireFailure link. it does not remove the link on the other recognizer.\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Recognizer} this\r\n\t     */\r\n\t    dropRequireFailure: function(otherRecognizer) {\r\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n\t        var index = inArray(this.requireFail, otherRecognizer);\r\n\t        if (index > -1) {\r\n\t            this.requireFail.splice(index, 1);\r\n\t        }\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * has require failures boolean\r\n\t     * @returns {boolean}\r\n\t     */\r\n\t    hasRequireFailures: function() {\r\n\t        return this.requireFail.length > 0;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * if the recognizer can recognize simultaneous with an other recognizer\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Boolean}\r\n\t     */\r\n\t    canRecognizeWith: function(otherRecognizer) {\r\n\t        return !!this.simultaneous[otherRecognizer.id];\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * You should use `tryEmit` instead of `emit` directly to check\r\n\t     * that all the needed recognizers has failed before emitting.\r\n\t     * @param {Object} input\r\n\t     */\r\n\t    emit: function(input) {\r\n\t        this.manager.emit(this.options.event, input); // simple 'eventName' events\r\n\t        this.manager.emit(this.options.event + stateStr(this.state), input); // like 'panmove' and 'panstart'\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Check that all the require failure recognizers has failed,\r\n\t     * if true, it emits a gesture event,\r\n\t     * otherwise, setup the state to FAILED.\r\n\t     * @param {Object} input\r\n\t     */\r\n\t    tryEmit: function(input) {\r\n\t        if (this.canEmit()) {\r\n\t            return this.emit(input);\r\n\t        }\r\n\t        // it's failing anyway\r\n\t        this.state = STATE_FAILED;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * can we emit?\r\n\t     * @returns {boolean}\r\n\t     */\r\n\t    canEmit: function() {\r\n\t        for (var i = 0; i < this.requireFail.length; i++) {\r\n\t            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\r\n\t                return false;\r\n\t            }\r\n\t        }\r\n\t        return true;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * update the recognizer\r\n\t     * @param {Object} inputData\r\n\t     */\r\n\t    recognize: function(inputData) {\r\n\t        // make a new copy of the inputData\r\n\t        // so we can change the inputData without messing up the other recognizers\r\n\t        var inputDataClone = extend({}, inputData);\r\n\t\r\n\t        // is is enabled and allow recognizing?\r\n\t        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\r\n\t            this.reset();\r\n\t            this.state = STATE_FAILED;\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        // reset when we've reached the end\r\n\t        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\r\n\t            this.state = STATE_POSSIBLE;\r\n\t        }\r\n\t\r\n\t        this.state = this.process(inputDataClone);\r\n\t\r\n\t        // the recognizer has recognized a gesture\r\n\t        // so trigger an event\r\n\t        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\r\n\t            this.tryEmit(inputDataClone);\r\n\t        }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * return the state of the recognizer\r\n\t     * the actual recognizing happens in this method\r\n\t     * @virtual\r\n\t     * @param {Object} inputData\r\n\t     * @returns {Const} STATE\r\n\t     */\r\n\t    process: function(inputData) { }, // jshint ignore:line\r\n\t\r\n\t    /**\r\n\t     * return the preferred touch-action\r\n\t     * @virtual\r\n\t     * @returns {Array}\r\n\t     */\r\n\t    getTouchAction: function() { },\r\n\t\r\n\t    /**\r\n\t     * called when the gesture isn't allowed to recognize\r\n\t     * like when another is being recognized or it is disabled\r\n\t     * @virtual\r\n\t     */\r\n\t    reset: function() { }\r\n\t};\r\n\t\r\n\t/**\r\n\t * get a usable string, used as event postfix\r\n\t * @param {Const} state\r\n\t * @returns {String} state\r\n\t */\r\n\tfunction stateStr(state) {\r\n\t    if (state & STATE_CANCELLED) {\r\n\t        return 'cancel';\r\n\t    } else if (state & STATE_ENDED) {\r\n\t        return 'end';\r\n\t    } else if (state & STATE_CHANGED) {\r\n\t        return 'move';\r\n\t    } else if (state & STATE_BEGAN) {\r\n\t        return 'start';\r\n\t    }\r\n\t    return '';\r\n\t}\r\n\t\r\n\t/**\r\n\t * direction cons to string\r\n\t * @param {Const} direction\r\n\t * @returns {String}\r\n\t */\r\n\tfunction directionStr(direction) {\r\n\t    if (direction == DIRECTION_DOWN) {\r\n\t        return 'down';\r\n\t    } else if (direction == DIRECTION_UP) {\r\n\t        return 'up';\r\n\t    } else if (direction == DIRECTION_LEFT) {\r\n\t        return 'left';\r\n\t    } else if (direction == DIRECTION_RIGHT) {\r\n\t        return 'right';\r\n\t    }\r\n\t    return '';\r\n\t}\r\n\t\r\n\t/**\r\n\t * get a recognizer by name if it is bound to a manager\r\n\t * @param {Recognizer|String} otherRecognizer\r\n\t * @param {Recognizer} recognizer\r\n\t * @returns {Recognizer}\r\n\t */\r\n\tfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\r\n\t    var manager = recognizer.manager;\r\n\t    if (manager) {\r\n\t        return manager.get(otherRecognizer);\r\n\t    }\r\n\t    return otherRecognizer;\r\n\t}\r\n\t\r\n\t/**\r\n\t * This recognizer is just used as a base for the simple attribute recognizers.\r\n\t * @constructor\r\n\t * @extends Recognizer\r\n\t */\r\n\tfunction AttrRecognizer() {\r\n\t    Recognizer.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(AttrRecognizer, Recognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof AttrRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        /**\r\n\t         * @type {Number}\r\n\t         * @default 1\r\n\t         */\r\n\t        pointers: 1\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Used to check if it the recognizer receives valid input, like input.distance > 10.\r\n\t     * @memberof AttrRecognizer\r\n\t     * @param {Object} input\r\n\t     * @returns {Boolean} recognized\r\n\t     */\r\n\t    attrTest: function(input) {\r\n\t        var optionPointers = this.options.pointers;\r\n\t        return optionPointers === 0 || input.pointers.length === optionPointers;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Process the input and return the state for the recognizer\r\n\t     * @memberof AttrRecognizer\r\n\t     * @param {Object} input\r\n\t     * @returns {*} State\r\n\t     */\r\n\t    process: function(input) {\r\n\t        var state = this.state;\r\n\t        var eventType = input.eventType;\r\n\t\r\n\t        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\r\n\t        var isValid = this.attrTest(input);\r\n\t\r\n\t        // on cancel input and we've recognized before, return STATE_CANCELLED\r\n\t        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\r\n\t            return state | STATE_CANCELLED;\r\n\t        } else if (isRecognized || isValid) {\r\n\t            if (eventType & INPUT_END) {\r\n\t                return state | STATE_ENDED;\r\n\t            } else if (!(state & STATE_BEGAN)) {\r\n\t                return STATE_BEGAN;\r\n\t            }\r\n\t            return state | STATE_CHANGED;\r\n\t        }\r\n\t        return STATE_FAILED;\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Pan\r\n\t * Recognized when the pointer is down and moved in the allowed direction.\r\n\t * @constructor\r\n\t * @extends AttrRecognizer\r\n\t */\r\n\tfunction PanRecognizer() {\r\n\t    AttrRecognizer.apply(this, arguments);\r\n\t\r\n\t    this.pX = null;\r\n\t    this.pY = null;\r\n\t}\r\n\t\r\n\tinherit(PanRecognizer, AttrRecognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof PanRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        event: 'pan',\r\n\t        threshold: 10,\r\n\t        pointers: 1,\r\n\t        direction: DIRECTION_ALL\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        var direction = this.options.direction;\r\n\t\r\n\t        if (direction === DIRECTION_ALL) {\r\n\t            return [TOUCH_ACTION_NONE];\r\n\t        }\r\n\t\r\n\t        var actions = [];\r\n\t        if (direction & DIRECTION_HORIZONTAL) {\r\n\t            actions.push(TOUCH_ACTION_PAN_Y);\r\n\t        }\r\n\t        if (direction & DIRECTION_VERTICAL) {\r\n\t            actions.push(TOUCH_ACTION_PAN_X);\r\n\t        }\r\n\t        return actions;\r\n\t    },\r\n\t\r\n\t    directionTest: function(input) {\r\n\t        var options = this.options;\r\n\t        var hasMoved = true;\r\n\t        var distance = input.distance;\r\n\t        var direction = input.direction;\r\n\t        var x = input.deltaX;\r\n\t        var y = input.deltaY;\r\n\t\r\n\t        // lock to axis?\r\n\t        if (!(direction & options.direction)) {\r\n\t            if (options.direction & DIRECTION_HORIZONTAL) {\r\n\t                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n\t                hasMoved = x != this.pX;\r\n\t                distance = Math.abs(input.deltaX);\r\n\t            } else {\r\n\t                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\r\n\t                hasMoved = y != this.pY;\r\n\t                distance = Math.abs(input.deltaY);\r\n\t            }\r\n\t        }\r\n\t        input.direction = direction;\r\n\t        return hasMoved && distance > options.threshold && direction & options.direction;\r\n\t    },\r\n\t\r\n\t    attrTest: function(input) {\r\n\t        return AttrRecognizer.prototype.attrTest.call(this, input) &&\r\n\t            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\r\n\t    },\r\n\t\r\n\t    emit: function(input) {\r\n\t        this.pX = input.deltaX;\r\n\t        this.pY = input.deltaY;\r\n\t\r\n\t        this._super.emit.call(this, input);\r\n\t\r\n\t        var direction = directionStr(input.direction);\r\n\t        if (direction) {\r\n\t            this.manager.emit(this.options.event + direction, input);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Pinch\r\n\t * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\r\n\t * @constructor\r\n\t * @extends AttrRecognizer\r\n\t */\r\n\tfunction PinchRecognizer() {\r\n\t    AttrRecognizer.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(PinchRecognizer, AttrRecognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof PinchRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        event: 'pinch',\r\n\t        threshold: 0,\r\n\t        pointers: 2\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return [TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y];\r\n\t    },\r\n\t\r\n\t    attrTest: function(input) {\r\n\t        return this._super.attrTest.call(this, input) &&\r\n\t            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\r\n\t    },\r\n\t\r\n\t    emit: function(input) {\r\n\t        this._super.emit.call(this, input);\r\n\t        if (input.scale !== 1) {\r\n\t            var inOut = input.scale < 1 ? 'in' : 'out';\r\n\t            this.manager.emit(this.options.event + inOut, input);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Press\r\n\t * Recognized when the pointer is down for x ms without any movement.\r\n\t * @constructor\r\n\t * @extends Recognizer\r\n\t */\r\n\tfunction PressRecognizer() {\r\n\t    Recognizer.apply(this, arguments);\r\n\t\r\n\t    this._timer = null;\r\n\t    this._input = null;\r\n\t}\r\n\t\r\n\tinherit(PressRecognizer, Recognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof PressRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        event: 'press',\r\n\t        pointers: 1,\r\n\t        time: 500, // minimal time of the pointer to be pressed\r\n\t        threshold: 5 // a minimal movement is ok, but keep it low\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return [TOUCH_ACTION_AUTO];\r\n\t    },\r\n\t\r\n\t    process: function(input) {\r\n\t        var options = this.options;\r\n\t\r\n\t        var validPointers = input.pointers.length === options.pointers;\r\n\t        var validMovement = input.distance < options.threshold;\r\n\t        var validTime = input.deltaTime > options.time;\r\n\t\r\n\t        this._input = input;\r\n\t\r\n\t        // we only allow little movement\r\n\t        // and we've reached an end event, so a tap is possible\r\n\t        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\r\n\t            this.reset();\r\n\t        } else if (input.eventType & INPUT_START) {\r\n\t            this.reset();\r\n\t            this._timer = setTimeoutScope(function() {\r\n\t                this.state = STATE_RECOGNIZED;\r\n\t                this.tryEmit();\r\n\t            }, options.time, this);\r\n\t        }\r\n\t        return STATE_FAILED;\r\n\t    },\r\n\t\r\n\t    reset: function() {\r\n\t        clearTimeout(this._timer);\r\n\t    },\r\n\t\r\n\t    emit: function() {\r\n\t        if (this.state === STATE_RECOGNIZED) {\r\n\t            this._input.timeStamp = now();\r\n\t            this.manager.emit(this.options.event, this._input);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Rotate\r\n\t * Recognized when two or more pointer are moving in a circular motion.\r\n\t * @constructor\r\n\t * @extends AttrRecognizer\r\n\t */\r\n\tfunction RotateRecognizer() {\r\n\t    AttrRecognizer.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(RotateRecognizer, AttrRecognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof RotateRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        event: 'rotate',\r\n\t        threshold: 0,\r\n\t        pointers: 2\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return [TOUCH_ACTION_NONE];\r\n\t    },\r\n\t\r\n\t    attrTest: function(input) {\r\n\t        return this._super.attrTest.call(this, input) &&\r\n\t            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Swipe\r\n\t * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\r\n\t * @constructor\r\n\t * @extends AttrRecognizer\r\n\t */\r\n\tfunction SwipeRecognizer() {\r\n\t    AttrRecognizer.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(SwipeRecognizer, AttrRecognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof SwipeRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        event: 'swipe',\r\n\t        threshold: 10,\r\n\t        velocity: 0.65,\r\n\t        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\r\n\t        pointers: 1\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return PanRecognizer.prototype.getTouchAction.call(this);\r\n\t    },\r\n\t\r\n\t    attrTest: function(input) {\r\n\t        var direction = this.options.direction;\r\n\t        var velocity;\r\n\t\r\n\t        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\r\n\t            velocity = input.velocity;\r\n\t        } else if (direction & DIRECTION_HORIZONTAL) {\r\n\t            velocity = input.velocityX;\r\n\t        } else if (direction & DIRECTION_VERTICAL) {\r\n\t            velocity = input.velocityY;\r\n\t        }\r\n\t\r\n\t        return this._super.attrTest.call(this, input) &&\r\n\t            direction & input.direction &&\r\n\t            velocity > this.options.velocity && input.eventType & INPUT_END;\r\n\t    },\r\n\t\r\n\t    emit: function(input) {\r\n\t        this.manager.emit(this.options.event, input);\r\n\t\r\n\t        var direction = directionStr(input.direction);\r\n\t        if (direction) {\r\n\t            this.manager.emit(this.options.event + direction, input);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\r\n\t * between the given interval and position. The delay option can be used to recognize multi-taps without firing\r\n\t * a single tap.\r\n\t *\r\n\t * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\r\n\t * multi-taps being recognized.\r\n\t * @constructor\r\n\t * @extends Recognizer\r\n\t */\r\n\tfunction TapRecognizer() {\r\n\t    Recognizer.apply(this, arguments);\r\n\t\r\n\t    // previous time and center,\r\n\t    // used for tap counting\r\n\t    this.pTime = false;\r\n\t    this.pCenter = false;\r\n\t\r\n\t    this._timer = null;\r\n\t    this._input = null;\r\n\t    this.count = 0;\r\n\t}\r\n\t\r\n\tinherit(TapRecognizer, Recognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof PinchRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        event: 'tap',\r\n\t        pointers: 1,\r\n\t        taps: 1,\r\n\t        interval: 300, // max time between the multi-tap taps\r\n\t        time: 250, // max time of the pointer to be down (like finger on the screen)\r\n\t        threshold: 2, // a minimal movement is ok, but keep it low\r\n\t        posThreshold: 10 // a multi-tap can be a bit off the initial position\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return [TOUCH_ACTION_MANIPULATION];\r\n\t    },\r\n\t\r\n\t    process: function(input) {\r\n\t        var options = this.options;\r\n\t\r\n\t        var validPointers = input.pointers.length === options.pointers;\r\n\t        var validMovement = input.distance < options.threshold;\r\n\t        var validTouchTime = input.deltaTime < options.time;\r\n\t\r\n\t        this.reset();\r\n\t\r\n\t        if ((input.eventType & INPUT_START) && (this.count === 0)) {\r\n\t            return this._failTimeout();\r\n\t        }\r\n\t\r\n\t        // we only allow little movement\r\n\t        // and we've reached an end event, so a tap is possible\r\n\t        if (validMovement && validTouchTime && validPointers) {\r\n\t            if (input.eventType != INPUT_END) {\r\n\t                return this._failTimeout();\r\n\t            }\r\n\t\r\n\t            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\r\n\t            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\r\n\t\r\n\t            this.pTime = input.timeStamp;\r\n\t            this.pCenter = input.center;\r\n\t\r\n\t            if (!validMultiTap || !validInterval) {\r\n\t                this.count = 1;\r\n\t            } else {\r\n\t                this.count += 1;\r\n\t            }\r\n\t\r\n\t            this._input = input;\r\n\t\r\n\t            // if tap count matches we have recognized it,\r\n\t            // else it has began recognizing...\r\n\t            var tapCount = this.count % options.taps;\r\n\t            if (tapCount === 0) {\r\n\t                // no failing requirements, immediately trigger the tap event\r\n\t                // or wait as long as the multitap interval to trigger\r\n\t                if (!this.hasRequireFailures()) {\r\n\t                    return STATE_RECOGNIZED;\r\n\t                } else {\r\n\t                    this._timer = setTimeoutScope(function() {\r\n\t                        this.state = STATE_RECOGNIZED;\r\n\t                        this.tryEmit();\r\n\t                    }, options.interval, this);\r\n\t                    return STATE_BEGAN;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        return STATE_FAILED;\r\n\t    },\r\n\t\r\n\t    _failTimeout: function() {\r\n\t        this._timer = setTimeoutScope(function() {\r\n\t            this.state = STATE_FAILED;\r\n\t        }, this.options.interval, this);\r\n\t        return STATE_FAILED;\r\n\t    },\r\n\t\r\n\t    reset: function() {\r\n\t        clearTimeout(this._timer);\r\n\t    },\r\n\t\r\n\t    emit: function() {\r\n\t        if (this.state == STATE_RECOGNIZED ) {\r\n\t            this._input.tapCount = this.count;\r\n\t            this.manager.emit(this.options.event, this._input);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Simple way to create an manager with a default set of recognizers.\r\n\t * @param {HTMLElement} element\r\n\t * @param {Object} [options]\r\n\t * @constructor\r\n\t */\r\n\tfunction Hammer(element, options) {\r\n\t    options = options || {};\r\n\t    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.easyRecognizers);\r\n\t    return new Manager(element, options);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @const {string}\r\n\t */\r\n\tHammer.VERSION = '2.0.0-dev';\r\n\t\r\n\t/**\r\n\t * default settings\r\n\t * @namespace\r\n\t */\r\n\tHammer.defaults = {\r\n\t    /**\r\n\t     * set if DOM events are being triggered.\r\n\t     * But this is slower and unused by simple implementations, so disabled by default.\r\n\t     * @type {Boolean}\r\n\t     * @default false\r\n\t     */\r\n\t    domEvents: false,\r\n\t\r\n\t    /**\r\n\t     * The value for the touchAction property/fallback.\r\n\t     * When set to `compute` it will magically set the correct value based on the added recognizers.\r\n\t     * @type {String}\r\n\t     * @default compute\r\n\t     */\r\n\t    touchAction: TOUCH_ACTION_COMPUTE,\r\n\t\r\n\t    /**\r\n\t     * @type {Boolean}\r\n\t     * @default true\r\n\t     */\r\n\t    enable: true,\r\n\t\r\n\t    /**\r\n\t     * Default recognizer setup when calling `Hammer()`\r\n\t     * When creating a new Manager these will be skipped.\r\n\t     * @type {Array}\r\n\t     */\r\n\t    easyRecognizers: [\r\n\t        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\r\n\t        [RotateRecognizer, { enable: false }],\r\n\t        [PinchRecognizer, { enable: false }, ['rotate']],\r\n\t        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],\r\n\t        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\r\n\t        [TapRecognizer],\r\n\t        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\r\n\t        [PressRecognizer]\r\n\t    ],\r\n\t\r\n\t    /**\r\n\t     * Some CSS properties can be used to improve the working of Hammer.\r\n\t     * Add them to this method and they will be set when creating a new Manager.\r\n\t     * @namespace\r\n\t     */\r\n\t    cssProps: {\r\n\t        /**\r\n\t         * Disables text selection to improve the dragging gesture. When the value is `none` it also sets\r\n\t         * `onselectstart=false` for IE9 on the element. Mainly for desktop browsers.\r\n\t         * @type {String}\r\n\t         * @default 'none'\r\n\t         */\r\n\t        userSelect: 'none',\r\n\t\r\n\t        /**\r\n\t         * Disable the Windows Phone grippers when pressing an element.\r\n\t         * @type {String}\r\n\t         * @default 'none'\r\n\t         */\r\n\t        touchSelect: 'none',\r\n\t\r\n\t        /**\r\n\t         * Disables the default callout shown when you touch and hold a touch target.\r\n\t         * On iOS, when you touch and hold a touch target such as a link, Safari displays\r\n\t         * a callout containing information about the link. This property allows you to disable that callout.\r\n\t         * @type {String}\r\n\t         * @default 'none'\r\n\t         */\r\n\t        touchCallout: 'none',\r\n\t\r\n\t        /**\r\n\t         * Specifies whether zooming is enabled. Used by IE10>\r\n\t         * @type {String}\r\n\t         * @default 'none'\r\n\t         */\r\n\t        contentZooming: 'none',\r\n\t\r\n\t        /**\r\n\t         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\r\n\t         * @type {String}\r\n\t         * @default 'none'\r\n\t         */\r\n\t        userDrag: 'none',\r\n\t\r\n\t        /**\r\n\t         * Overrides the highlight color shown when the user taps a link or a JavaScript\r\n\t         * clickable element in iOS. This property obeys the alpha value, if specified.\r\n\t         * @type {String}\r\n\t         * @default 'rgba(0,0,0,0)'\r\n\t         */\r\n\t        tapHighlightColor: 'rgba(0,0,0,0)'\r\n\t    }\r\n\t};\r\n\t\r\n\tvar STOP = 1;\r\n\tvar FORCED_STOP = 2;\r\n\t\r\n\t/**\r\n\t * Manager\r\n\t * @param {HTMLElement} element\r\n\t * @param {Object} [options]\r\n\t * @constructor\r\n\t */\r\n\tfunction Manager(element, options) {\r\n\t    options = options || {};\r\n\t\r\n\t    this.options = merge(options, Hammer.defaults);\r\n\t\r\n\t    this.handlers = {};\r\n\t    this.session = {};\r\n\t    this.recognizers = [];\r\n\t\r\n\t    this.element = element;\r\n\t    this.input = createInputInstance(this);\r\n\t    this.touchAction = new TouchAction(this, this.options.touchAction);\r\n\t\r\n\t    toggleCssProps(this, true);\r\n\t\r\n\t    each(options.recognizers, function(item) {\r\n\t        var recognizer = this.add(new (item[0])(item[1]));\r\n\t        item[2] && each(item[2], recognizer.recognizeWith, recognizer);\r\n\t        item[3] && each(item[3], recognizer.requireFailure, recognizer);\r\n\t    }, this);\r\n\t}\r\n\t\r\n\tManager.prototype = {\r\n\t    /**\r\n\t     * set options\r\n\t     * @param {String} option\r\n\t     * @param {*} val\r\n\t     */\r\n\t    set: function(option, val) {\r\n\t        this.options[option] = val;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * stop recognizing for this session.\r\n\t     * This session will be discarded, when a new [input]start event is fired.\r\n\t     * When forced, the recognizer cycle is stopped immediately.\r\n\t     * @param {Boolean} [force]\r\n\t     */\r\n\t    stop: function(force) {\r\n\t        this.session.stopped = force ? FORCED_STOP : STOP;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * run the recognizers!\r\n\t     * called by the inputHandler function on every movement of the pointers (touches)\r\n\t     * it walks through all the recognizers and tries to detect the gesture that is being made\r\n\t     * @param {Object} inputData\r\n\t     */\r\n\t    recognize: function(inputData) {\r\n\t        if (this.session.stopped) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        // run the touch-action polyfill\r\n\t        this.touchAction.preventDefaults(inputData);\r\n\t\r\n\t        var recognizer;\r\n\t        var session = this.session;\r\n\t\r\n\t        // this holds the recognizer that is being recognized.\r\n\t        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\r\n\t        // if no recognizer is detecting a thing, it is set to `null`\r\n\t        var curRecognizer = session.curRecognizer;\r\n\t\r\n\t        // reset when the last recognizer is recognized\r\n\t        // or when we're in a new session\r\n\t        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\r\n\t            curRecognizer = session.curRecognizer = null;\r\n\t        }\r\n\t\r\n\t        for (var i = 0, len = this.recognizers.length; i < len; i++) {\r\n\t            recognizer = this.recognizers[i];\r\n\t\r\n\t            // find out if we are allowed try to recognize the input for this one.\r\n\t            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\r\n\t            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\r\n\t            //      that is being recognized.\r\n\t            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\r\n\t            //      this can be setup with the `recognizeWith()` method on the recognizer.\r\n\t            if (this.session.stopped !== FORCED_STOP && ( // 1\r\n\t                    !curRecognizer || recognizer == curRecognizer || // 2\r\n\t                    recognizer.canRecognizeWith(curRecognizer))) { // 3\r\n\t                recognizer.recognize(inputData);\r\n\t            } else {\r\n\t                recognizer.reset();\r\n\t            }\r\n\t\r\n\t            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\r\n\t            // current active recognizer. but only if we don't already have an active recognizer\r\n\t            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\r\n\t                curRecognizer = session.curRecognizer = recognizer;\r\n\t            }\r\n\t        }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * get a recognizer by its event name.\r\n\t     * @param {Recognizer|String} recognizer\r\n\t     * @returns {Recognizer|Null}\r\n\t     */\r\n\t    get: function(recognizer) {\r\n\t        if (recognizer instanceof Recognizer) {\r\n\t            return recognizer;\r\n\t        }\r\n\t\r\n\t        var recognizers = this.recognizers;\r\n\t        for (var i = 0; i < recognizers.length; i++) {\r\n\t            if (recognizers[i].options.event == recognizer) {\r\n\t                return recognizers[i];\r\n\t            }\r\n\t        }\r\n\t        return null;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * add a recognizer to the manager\r\n\t     * existing recognizers with the same event name will be removed\r\n\t     * @param {Recognizer} recognizer\r\n\t     * @returns {Recognizer}\r\n\t     */\r\n\t    add: function(recognizer) {\r\n\t        // remove existing\r\n\t        var existing = this.get(recognizer.options.event);\r\n\t        if (existing) {\r\n\t            this.remove(existing);\r\n\t        }\r\n\t\r\n\t        this.recognizers.push(recognizer);\r\n\t        recognizer.manager = this;\r\n\t\r\n\t        this.touchAction.update();\r\n\t        return recognizer;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * remove a recognizer by name or instance\r\n\t     * @param {Recognizer|String} recognizer\r\n\t     */\r\n\t    remove: function(recognizer) {\r\n\t        var recognizers = this.recognizers;\r\n\t        recognizer = this.get(recognizer);\r\n\t        recognizers.splice(inArray(recognizers, recognizer), 1);\r\n\t\r\n\t        this.touchAction.update();\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * bind event\r\n\t     * @param {String} events\r\n\t     * @param {Function} handler\r\n\t     * @returns {EventEmitter} this\r\n\t     */\r\n\t    on: function(events, handler) {\r\n\t        var handlers = this.handlers;\r\n\t        each(splitStr(events), function(event) {\r\n\t            handlers[event] = handlers[event] || [];\r\n\t            handlers[event].push(handler);\r\n\t        });\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * unbind event, leave emit blank to remove all handlers\r\n\t     * @param {String} events\r\n\t     * @param {Function} [handler]\r\n\t     * @returns {EventEmitter} this\r\n\t     */\r\n\t    off: function(events, handler) {\r\n\t        var handlers = this.handlers;\r\n\t        each(splitStr(events), function(event) {\r\n\t            if (!handler) {\r\n\t                delete handlers[event];\r\n\t            } else {\r\n\t                handlers[event].splice(inArray(handlers[event], handler), 1);\r\n\t            }\r\n\t        });\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * emit event to the listeners\r\n\t     * @param {String} event\r\n\t     * @param {Object} data\r\n\t     */\r\n\t    emit: function(event, data) {\r\n\t        // we also want to trigger dom events\r\n\t        if (this.options.domEvents) {\r\n\t            triggerDomEvent(event, data);\r\n\t        }\r\n\t\r\n\t        // no handlers, so skip it all\r\n\t        var handlers = this.handlers[event];\r\n\t        if (!handlers || !handlers.length) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        data.type = event;\r\n\t        data.preventDefault = function() {\r\n\t            data.srcEvent.preventDefault();\r\n\t        };\r\n\t\r\n\t        for (var i = 0, len = handlers.length; i < len; i++) {\r\n\t            handlers[i](data);\r\n\t        }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * destroy the manager and unbinds all events\r\n\t     * it doesn't unbind dom events, that is the user own responsibility\r\n\t     */\r\n\t    destroy: function() {\r\n\t        this.element && toggleCssProps(this, false);\r\n\t\r\n\t        this.handlers = {};\r\n\t        this.session = {};\r\n\t        this.input.destroy();\r\n\t        this.element = null;\r\n\t    }\r\n\t};\r\n\t\r\n\t/**\r\n\t * add/remove the css properties as defined in manager.options.cssProps\r\n\t * @param {Manager} manager\r\n\t * @param {Boolean} add\r\n\t */\r\n\tfunction toggleCssProps(manager, add) {\r\n\t    var element = manager.element;\r\n\t    var cssProps = manager.options.cssProps;\r\n\t\r\n\t    each(cssProps, function(value, name) {\r\n\t        element.style[prefixed(element.style, name)] = add ? value : '';\r\n\t    });\r\n\t\r\n\t    var falseFn = add && function() { return false; };\r\n\t    if (cssProps.userSelect == 'none') { element.onselectstart = falseFn; }\r\n\t    if (cssProps.userDrag == 'none') { element.ondragstart = falseFn; }\r\n\t}\r\n\t\r\n\t/**\r\n\t * trigger dom event\r\n\t * @param {String} event\r\n\t * @param {Object} data\r\n\t */\r\n\tfunction triggerDomEvent(event, data) {\r\n\t    var gestureEvent = document.createEvent('Event');\r\n\t    gestureEvent.initEvent(event, true, true);\r\n\t    gestureEvent.gesture = data;\r\n\t    data.target.dispatchEvent(gestureEvent);\r\n\t}\r\n\t\r\n\textend(Hammer, {\r\n\t    INPUT_START: INPUT_START,\r\n\t    INPUT_MOVE: INPUT_MOVE,\r\n\t    INPUT_END: INPUT_END,\r\n\t    INPUT_CANCEL: INPUT_CANCEL,\r\n\t\r\n\t    STATE_POSSIBLE: STATE_POSSIBLE,\r\n\t    STATE_BEGAN: STATE_BEGAN,\r\n\t    STATE_CHANGED: STATE_CHANGED,\r\n\t    STATE_ENDED: STATE_ENDED,\r\n\t    STATE_RECOGNIZED: STATE_RECOGNIZED,\r\n\t    STATE_CANCELLED: STATE_CANCELLED,\r\n\t    STATE_FAILED: STATE_FAILED,\r\n\t\r\n\t    DIRECTION_NONE: DIRECTION_NONE,\r\n\t    DIRECTION_LEFT: DIRECTION_LEFT,\r\n\t    DIRECTION_RIGHT: DIRECTION_RIGHT,\r\n\t    DIRECTION_UP: DIRECTION_UP,\r\n\t    DIRECTION_DOWN: DIRECTION_DOWN,\r\n\t    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\r\n\t    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\r\n\t    DIRECTION_ALL: DIRECTION_ALL,\r\n\t\r\n\t    Manager: Manager,\r\n\t    Input: Input,\r\n\t    TouchAction: TouchAction,\r\n\t\r\n\t    Recognizer: Recognizer,\r\n\t    AttrRecognizer: AttrRecognizer,\r\n\t    Tap: TapRecognizer,\r\n\t    Pan: PanRecognizer,\r\n\t    Swipe: SwipeRecognizer,\r\n\t    Pinch: PinchRecognizer,\r\n\t    Rotate: RotateRecognizer,\r\n\t    Press: PressRecognizer,\r\n\t\r\n\t    on: addEventListeners,\r\n\t    off: removeEventListeners,\r\n\t    each: each,\r\n\t    merge: merge,\r\n\t    extend: extend,\r\n\t    inherit: inherit,\r\n\t    bindFn: bindFn,\r\n\t    prefixed: prefixed\r\n\t});\r\n\t\r\n\tif (\"function\" == TYPE_FUNCTION && __webpack_require__(4)) {\r\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\r\n\t        return Hammer;\r\n\t    }.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t} else if (typeof module != TYPE_UNDEFINED && module.exports) {\r\n\t    module.exports = Hammer;\r\n\t} else {\r\n\t    window.Hammer = Hammer;\r\n\t}\r\n\t\r\n\t})(window);\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ }\n/******/ ])"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/assets/js/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);","window.Hammer = require('../../../node_modules/hammerjs/hammer.js');\r\n\r\nvar toggle = document.querySelector(\".toggle-sidebar\");\r\nvar target = document.querySelector(\".sidebar\");\r\nif(toggle && target) {\r\n    toggle.addEventListener(\"click\", function(ev) {\r\n        if(target.className.indexOf('show') === -1) {\r\n            target.className += ' show';\r\n        } else {\r\n            target.className = target.className.replace('show', '');\r\n        }\r\n        ev.preventDefault();\r\n    });\r\n}\r\n\r\n\r\nif(document.querySelector(\"#hitarea\")) {\r\n    require('./demo.js');\r\n}\r\n\r\nrequire('./externals.js');\r\n","/**\r\n * kind of messy code, but good enough for now\r\n */\r\n// polyfill\r\nvar reqAnimationFrame = (function () {\r\n    return window[Hammer.prefixed(window, 'requestAnimationFrame')] || function (callback) {\r\n        window.setTimeout(callback, 1000 / 60);\r\n    };\r\n})();\r\n\r\nvar el = document.querySelector(\"#hitarea\");\r\n\r\nvar startX = Math.round((el.parentNode.offsetWidth - el.offsetWidth) / 2);\r\nvar startY = Math.round((el.parentNode.offsetHeight - el.offsetHeight) / 2);\r\n\r\nvar ticking = false;\r\nvar transform;\r\n\r\nvar mc = new Hammer(el);\r\n\r\nmc.get('pinch').set('enable', true);\r\nmc.get('rotate').set('enable', true);\r\n\r\nmc.on(\"pan\", onPan);\r\nmc.on(\"swipe\", onSwipe);\r\nmc.on(\"rotate\", onRotate);\r\nmc.on(\"pinch\", onPinch);\r\nmc.on(\"tap\", onTap);\r\nmc.on(\"doubletap\", onDoubleTap);\r\nmc.on(\"hold\", onHold);\r\n\r\nmc.on(\"panstart rotatestart pinchstart\", resetElementStart);\r\nmc.on(\"panend rotateend pinchend pancancel rotatecancel pinchcancel\", resetElementEnd);\r\n\r\nfunction resetElementStart() {\r\n    el.className = '';\r\n}\r\n\r\nfunction resetElementEnd() {\r\n    transform = {\r\n        translate: { x: startX, y: startY },\r\n        scale: 1,\r\n        rotate: 0\r\n    };\r\n    el.className = 'animate';\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction updateElementTransform() {\r\n    var value = [\r\n        'translate3d(' + transform.translate.x + 'px, ' + transform.translate.y + 'px, 0)',\r\n        'scale(' + transform.scale + ', ' + transform.scale + ')',\r\n        'rotate(' + transform.rotate + 'deg)'];\r\n    el.style.webkitTransform = el.style.transform = value.join(\" \");\r\n    ticking = false;\r\n}\r\n\r\nfunction requestElementUpdate() {\r\n    if(!ticking) {\r\n        ticking = true;\r\n        reqAnimationFrame(updateElementTransform);\r\n    }\r\n}\r\n\r\nfunction onPan(ev) {\r\n    transform.translate = {\r\n        x: startX + ev.deltaX,\r\n        y: startY + ev.deltaY\r\n    };\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction onSwipe(ev) {\r\n    transform.translate = {\r\n        x: startX + (ev.deltaX * 1.2),\r\n        y: startY + (ev.deltaY * 1.2)\r\n    };\r\n    transform.scale = 1.2;\r\n    requestElementUpdate();\r\n\r\n    setTimeout(function () {\r\n        resetElementEnd();\r\n    }, 400);\r\n}\r\n\r\nfunction onPinch(ev) {\r\n    transform.scale = ev.scale;\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction onRotate(ev) {\r\n    transform.rotate = ev.rotation;\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction onTap(ev) {\r\n    transform.scale = .9;\r\n    requestElementUpdate();\r\n\r\n    setTimeout(function () {\r\n        transform.scale = 1;\r\n        requestElementUpdate();\r\n    }, 200);\r\n}\r\n\r\nfunction onDoubleTap(ev) {\r\n    transform.rotate = !transform.rotate ? 360 : 0;\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction onHold(ev) {\r\n    el.style.background = '#fd0';\r\n    setTimeout(function () {\r\n        el.style.background = 'white';\r\n        requestElementUpdate();\r\n    }, 500);\r\n}\r\n\r\nresetElementEnd();\r\n\r\ndocument.querySelector(\".device-button\").addEventListener(\"click\", function(){\r\n    document.querySelector(\".device\").classList.toggle('hammertime');\r\n}, false);\r\n","if(location.href.indexOf(\".github.io\") > -1) {\r\n    var _gaq = _gaq || [];\r\n    _gaq.push(['_setAccount', 'UA-30289566-1']);\r\n    _gaq.push(['_trackPageview']);\r\n    (function () {\r\n        var ga = document.createElement('script');\r\n        ga.type = 'text/javascript';\r\n        ga.async = true;\r\n        ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';\r\n        var s = document.getElementsByTagName('script')[0];\r\n        s.parentNode.insertBefore(ga, s);\r\n    })();\r\n}\r\n\r\n!function (d, s, id) {\r\n    var js, fjs = d.getElementsByTagName(s)[0];\r\n    if (!d.getElementById(id)) {\r\n        js = d.createElement(s);\r\n        js.id = id;\r\n        js.src = \"//platform.twitter.com/widgets.js\";\r\n        fjs.parentNode.insertBefore(js, fjs);\r\n    }\r\n}(document, \"script\", \"twitter-wjs\");\r\n","(function(window, undefined) {\r\n  'use strict';\r\n\r\nvar VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];\r\n\r\nvar TYPE_FUNCTION = 'function';\r\nvar TYPE_UNDEFINED = 'undefined';\r\n\r\nvar round = Math.round;\r\nvar now = Date.now;\r\n\r\n/**\r\n * set a timeout with a given scope\r\n * @param {Function} fn\r\n * @param {Number} timeout\r\n * @param {Object} context\r\n * @returns {number}\r\n */\r\nfunction setTimeoutScope(fn, timeout, context) {\r\n    return setTimeout(bindFn(fn, context), timeout);\r\n}\r\n\r\n/**\r\n * walk objects and arrays\r\n * @param {Object} obj\r\n * @param {Function} iterator\r\n * @param {Object} context\r\n */\r\nfunction each(obj, iterator, context) {\r\n    var i, len;\r\n\r\n    if (!obj) {\r\n        return;\r\n    }\r\n\r\n    if (obj.forEach) {\r\n        obj.forEach(iterator, context);\r\n    } else if (obj.length !== undefined) {\r\n        for (i = 0, len = obj.length; i < len; i++) {\r\n            iterator.call(context, obj[i], i, obj);\r\n        }\r\n    } else {\r\n        for (i in obj) {\r\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * extend object.\r\n * means that properties in dest will be overwritten by the ones in src.\r\n * @param {Object} dest\r\n * @param {Object} src\r\n * @param {Boolean} [merge]\r\n * @returns {Object} dest\r\n */\r\nfunction extend(dest, src, merge) {\r\n    var keys = Object.keys(src);\r\n    for (var i = 0, len = keys.length; i < len; i++) {\r\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\r\n            dest[keys[i]] = src[keys[i]];\r\n        }\r\n    }\r\n    return dest;\r\n}\r\n\r\n/**\r\n * merge the values from src in the dest.\r\n * means that properties that exist in dest will not be overwritten by src\r\n * @param {Object} dest\r\n * @param {Object} src\r\n * @returns {Object} dest\r\n */\r\nfunction merge(dest, src) {\r\n    return extend(dest, src, true);\r\n}\r\n\r\n/**\r\n * simple class inheritance\r\n * @param {Function} child\r\n * @param {Function} base\r\n * @param {Object} [properties]\r\n */\r\nfunction inherit(child, base, properties) {\r\n    var baseP = base.prototype,\r\n        childP;\r\n\r\n    // object create is supported since IE9\r\n    if (Object.create) {\r\n        childP = child.prototype = Object.create(baseP);\r\n        childP.constructor = child;\r\n    } else {\r\n        extend(child, base);\r\n        var Inherited = function() {\r\n            this.constructor = child;\r\n        };\r\n        Inherited.prototype = baseP;\r\n        childP = child.prototype = new Inherited();\r\n    }\r\n\r\n    if (properties) {\r\n        extend(childP, properties);\r\n    }\r\n\r\n    childP._super = baseP;\r\n}\r\n\r\n/**\r\n * simple function bind\r\n * @param {Function} fn\r\n * @param {Object} context\r\n * @returns {Function}\r\n */\r\nfunction bindFn(fn, context) {\r\n    return function() {\r\n        return fn.apply(context, arguments);\r\n    };\r\n}\r\n\r\n/**\r\n * let a boolean value also be a function that must return a boolean\r\n * this first item in args will be used as the context\r\n * @param {Boolean|Function} val\r\n * @param {Array} [args]\r\n * @returns {Boolean}\r\n */\r\nfunction boolOrFn(val, args) {\r\n    if (typeof val == TYPE_FUNCTION) {\r\n        return val.apply(args ? args[0] || window : window, args);\r\n    }\r\n    return val;\r\n}\r\n\r\n/**\r\n * use the val2 when val1 is undefined\r\n * @param {*} val1\r\n * @param {*} val2\r\n * @returns {*}\r\n */\r\nfunction ifUndefined(val1, val2) {\r\n    return (val1 === undefined) ? val2 : val1;\r\n}\r\n\r\n/**\r\n * addEventListener with multiple events at once\r\n * @param {HTMLElement} element\r\n * @param {String} types\r\n * @param {Function} handler\r\n */\r\nfunction addEventListeners(element, types, handler) {\r\n    each(splitStr(types), function(type) {\r\n        element.addEventListener(type, handler, false);\r\n    });\r\n}\r\n\r\n/**\r\n * removeEventListener with multiple events at once\r\n * @param {HTMLElement} element\r\n * @param {String} types\r\n * @param {Function} handler\r\n */\r\nfunction removeEventListeners(element, types, handler) {\r\n    each(splitStr(types), function(type) {\r\n        element.removeEventListener(type, handler, false);\r\n    });\r\n}\r\n\r\n/**\r\n * find if a node is in the given parent\r\n * @method hasParent\r\n * @param {HTMLElement} node\r\n * @param {HTMLElement} parent\r\n * @return {Boolean} found\r\n */\r\nfunction hasParent(node, parent) {\r\n    while (node) {\r\n        if (node == parent) {\r\n            return true;\r\n        }\r\n        node = node.parentNode;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * small indexOf wrapper\r\n * @param {String} str\r\n * @param {String} find\r\n * @returns {Boolean} found\r\n */\r\nfunction inStr(str, find) {\r\n    return str.indexOf(find) > -1;\r\n}\r\n\r\n/**\r\n * split string on whitespace\r\n * @param {String} str\r\n * @returns {Array} words\r\n */\r\nfunction splitStr(str) {\r\n    return str.trim().split(/\\s+/g);\r\n}\r\n\r\n/**\r\n * find if a array contains the object using indexOf or a simple polyFill\r\n * @param {Array} src\r\n * @param {String} find\r\n * @param {String} [findByKey]\r\n * @return {Boolean|Number} false when not found, or the index\r\n */\r\nfunction inArray(src, find, findByKey) {\r\n    if (src.indexOf && !findByKey) {\r\n        return src.indexOf(find);\r\n    } else {\r\n        for (var i = 0, len = src.length; i < len; i++) {\r\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n\r\n/**\r\n * convert array-like objects to real arrays\r\n * @param {Object} obj\r\n * @returns {Array}\r\n */\r\nfunction toArray(obj) {\r\n    return Array.prototype.slice.call(obj, 0);\r\n}\r\n\r\n/**\r\n * unique array with objects based on a key (like 'id') or just by the array's value\r\n * @param {Array} src [{id:1},{id:2},{id:1}]\r\n * @param {String} [key]\r\n * @returns {Array} [{id:1},{id:2}]\r\n */\r\nfunction uniqueArray(src, key) {\r\n    var results = [];\r\n    var values = [];\r\n    for (var i = 0, len = src.length; i < len; i++) {\r\n        var val = key ? src[i][key] : src[i];\r\n        if (inArray(values, val) < 0) {\r\n            results.push(src[i]);\r\n        }\r\n        values[i] = val;\r\n    }\r\n    return results;\r\n}\r\n\r\n/**\r\n * get the prefixed property\r\n * @param {Object} obj\r\n * @param {String} property\r\n * @returns {String|Undefined} prefixed\r\n */\r\nfunction prefixed(obj, property) {\r\n    var prefix, prop;\r\n    var camelProp = property[0].toUpperCase() + property.slice(1);\r\n\r\n    for (var i = 0, len = VENDOR_PREFIXES.length; i < len; i++) {\r\n        prefix = VENDOR_PREFIXES[i];\r\n        prop = (prefix) ? prefix + camelProp : property;\r\n\r\n        if (prop in obj) {\r\n            return prop;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * get a unique id\r\n * @returns {number} uniqueId\r\n */\r\nvar _uniqueId = 1;\r\nfunction uniqueId() {\r\n    return _uniqueId++;\r\n}\r\n\r\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\r\n\r\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\r\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\r\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\r\n\r\nvar INPUT_TYPE_TOUCH = 'touch';\r\nvar INPUT_TYPE_PEN = 'pen';\r\nvar INPUT_TYPE_MOUSE = 'mouse';\r\nvar INPUT_TYPE_KINECT = 'kinect';\r\n\r\nvar COMPUTE_INTERVAL = 25;\r\n\r\nvar INPUT_START = 1;\r\nvar INPUT_MOVE = 2;\r\nvar INPUT_END = 4;\r\nvar INPUT_CANCEL = 8;\r\n\r\nvar DIRECTION_NONE = 1;\r\nvar DIRECTION_LEFT = 2;\r\nvar DIRECTION_RIGHT = 4;\r\nvar DIRECTION_UP = 8;\r\nvar DIRECTION_DOWN = 16;\r\n\r\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\r\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\r\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\r\n\r\nvar PROPS_XY = ['x', 'y'];\r\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\r\n\r\n/**\r\n * create new input type manager\r\n * @param {Manager} manager\r\n * @param {Function} callback\r\n * @returns {Input}\r\n * @constructor\r\n */\r\nfunction Input(manager, callback) {\r\n    var self = this;\r\n    this.manager = manager;\r\n    this.callback = callback;\r\n\r\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\r\n    // so when disabled the input events are completely bypassed.\r\n    this.domHandler = function(ev) {\r\n        if (boolOrFn(self.manager.options.enable, [self.manager])) {\r\n            self.handler(ev);\r\n        }\r\n    };\r\n\r\n    this.evEl && addEventListeners(this.manager.element, this.evEl, this.domHandler);\r\n    this.evWin && addEventListeners(window, this.evWin, this.domHandler);\r\n}\r\n\r\nInput.prototype = {\r\n    /**\r\n     * should handle the inputEvent data and trigger the callback\r\n     * @virtual\r\n     */\r\n    handler: function() { },\r\n\r\n    /**\r\n     * unbind the events\r\n     */\r\n    destroy: function() {\r\n        this.elEvents && removeEventListeners(this.manager.element, this.elEvents, this.domHandler);\r\n        this.winEvents && removeEventListeners(window, this.winEvents, this.domHandler);\r\n    }\r\n};\r\n\r\n/**\r\n * create new input type manager\r\n * @param {Hammer} manager\r\n * @returns {Input}\r\n */\r\nfunction createInputInstance(manager) {\r\n    var Type;\r\n    if (SUPPORT_POINTER_EVENTS) {\r\n        Type = PointerEventInput;\r\n    } else if (SUPPORT_ONLY_TOUCH) {\r\n        Type = TouchInput;\r\n    } else if (!SUPPORT_TOUCH) {\r\n        Type = MouseInput;\r\n    } else {\r\n        Type = TouchMouseInput;\r\n    }\r\n    return new (Type)(manager, inputHandler);\r\n}\r\n\r\n/**\r\n * handle input events\r\n * @param {Manager} manager\r\n * @param {String} eventType\r\n * @param {Object} input\r\n */\r\nfunction inputHandler(manager, eventType, input) {\r\n    var pointersLen = input.pointers.length;\r\n    var changedPointersLen = input.changedPointers.length;\r\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\r\n    var isFinal = (eventType & INPUT_END && (pointersLen - changedPointersLen === 0));\r\n\r\n    input.isFirst = isFirst;\r\n    input.isFinal = isFinal;\r\n\r\n    if (isFirst) {\r\n        manager.session = {};\r\n    }\r\n    // source event is the normalized value of the domEvents\r\n    // like 'touchstart, mouseup, pointerdown'\r\n    input.eventType = eventType;\r\n\r\n    // compute scale, rotation etc\r\n    computeInputData(manager, input);\r\n\r\n    manager.recognize(input);\r\n}\r\n\r\n/**\r\n * extend the data with some usable properties like scale, rotate, velocity etc\r\n * @param {Object} manager\r\n * @param {Object} input\r\n */\r\nfunction computeInputData(manager, input) {\r\n    var session = manager.session;\r\n    var pointers = input.pointers;\r\n    var pointersLength = pointers.length;\r\n\r\n    // store the first input to calculate the distance and direction\r\n    if (!session.firstInput) {\r\n        session.firstInput = simpleCloneInputData(input);\r\n    }\r\n\r\n    // to compute scale and rotation we need to store the multiple touches\r\n    if (pointersLength > 1 && !session.firstMultiple) {\r\n        session.firstMultiple = simpleCloneInputData(input);\r\n    } else if (pointersLength === 1) {\r\n        session.firstMultiple = false;\r\n    }\r\n\r\n    var firstInput = session.firstInput;\r\n    var firstMultiple = session.firstMultiple;\r\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\r\n    var center = getCenter(pointers);\r\n\r\n    input.timeStamp = now();\r\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\r\n    input.deltaX = center.x - offsetCenter.x;\r\n    input.deltaY = center.y - offsetCenter.y;\r\n\r\n    input.center = center;\r\n    input.angle = getAngle(offsetCenter, center);\r\n    input.distance = getDistance(offsetCenter, center);\r\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\r\n\r\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\r\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\r\n\r\n    // find the correct target\r\n    var target = manager.element;\r\n    if (hasParent(input.srcEvent.target, target)) {\r\n        target = input.srcEvent.target;\r\n    }\r\n    input.target = target;\r\n\r\n    computeIntervalInputData(session, input);\r\n}\r\n\r\n/**\r\n * velocity is calculated every x ms\r\n * @param {Object} session\r\n * @param {Object} input\r\n */\r\nfunction computeIntervalInputData(session, input) {\r\n    var last = session.lastInterval;\r\n    if (!last) {\r\n        last = session.lastInterval = simpleCloneInputData(input);\r\n    }\r\n\r\n    var deltaTime = input.timeStamp - last.timeStamp,\r\n        velocity,\r\n        velocityX,\r\n        velocityY,\r\n        direction;\r\n\r\n    if (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined) {\r\n        var deltaX = last.deltaX - input.deltaX;\r\n        var deltaY = last.deltaY - input.deltaY;\r\n\r\n        var v = getVelocity(deltaTime, deltaX, deltaY);\r\n        velocityX = v.x;\r\n        velocityY = v.y;\r\n        velocity = Math.max(v.x, v.y);\r\n        direction = getDirection(deltaX, deltaY);\r\n    } else {\r\n        // use latest velocity info if it doesn't overtake a minimum period\r\n        velocity = last.velocity;\r\n        velocityX = last.velocityX;\r\n        velocityY = last.velocityY;\r\n        direction = last.direction;\r\n    }\r\n\r\n    input.velocity = velocity;\r\n    input.velocityX = velocityX;\r\n    input.velocityY = velocityY;\r\n    input.direction = direction;\r\n}\r\n\r\n/**\r\n * create a simple clone from the input used for storage of firstInput and firstMultiple\r\n * @param {Object} input\r\n * @returns {Object} clonedInputData\r\n */\r\nfunction simpleCloneInputData(input) {\r\n    // make a simple copy of the pointers because we will get a reference if we don't\r\n    // we only need clientXY for the calculations\r\n    var pointers = [];\r\n    for (var i = 0; i < input.pointers.length; i++) {\r\n        pointers[i] = {\r\n            clientX: round(input.pointers[i].clientX),\r\n            clientY: round(input.pointers[i].clientY)\r\n        };\r\n    }\r\n\r\n    return {\r\n        timeStamp: now(),\r\n        pointers: pointers,\r\n        center: getCenter(pointers),\r\n        deltaX: input.deltaX,\r\n        deltaY: input.deltaY\r\n    };\r\n}\r\n\r\n/**\r\n * get the center of all the pointers\r\n * @param {Array} pointers\r\n * @return {Object} center contains `x` and `y` properties\r\n */\r\nfunction getCenter(pointers) {\r\n    var pointersLength = pointers.length;\r\n\r\n    // no need to loop when only one touch\r\n    if (pointersLength === 1) {\r\n        return {\r\n            x: round(pointers[0].clientX),\r\n            y: round(pointers[0].clientY)\r\n        };\r\n    }\r\n\r\n    var x = 0, y = 0;\r\n    for (var i = 0; i < pointersLength; i++) {\r\n        x += pointers[i].clientX;\r\n        y += pointers[i].clientY;\r\n    }\r\n\r\n    return {\r\n        x: round(x / pointersLength),\r\n        y: round(y / pointersLength)\r\n    };\r\n}\r\n\r\n/**\r\n * calculate the velocity between two points. unit is in px per ms.\r\n * @param {Number} deltaTime\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Object} velocity `x` and `y`\r\n */\r\nfunction getVelocity(deltaTime, x, y) {\r\n    return {\r\n        x: Math.abs(x / deltaTime) || 0,\r\n        y: Math.abs(y / deltaTime) || 0\r\n    };\r\n}\r\n\r\n/**\r\n * get the direction between two points\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Number} direction\r\n */\r\nfunction getDirection(x, y) {\r\n    if (x === y) {\r\n        return DIRECTION_NONE;\r\n    }\r\n\r\n    if (Math.abs(x) >= Math.abs(y)) {\r\n        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n    }\r\n    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\r\n}\r\n\r\n/**\r\n * calculate the absolute distance between two points\r\n * @param {Object} p1 {x, y}\r\n * @param {Object} p2 {x, y}\r\n * @param {Array} [props] containing x and y keys\r\n * @return {Number} distance\r\n */\r\nfunction getDistance(p1, p2, props) {\r\n    if (!props) {\r\n        props = PROPS_XY;\r\n    }\r\n    var x = p2[props[0]] - p1[props[0]],\r\n        y = p2[props[1]] - p1[props[1]];\r\n\r\n    return Math.sqrt((x * x) + (y * y));\r\n}\r\n\r\n/**\r\n * calculate the angle between two coordinates\r\n * @param {Object} p1\r\n * @param {Object} p2\r\n * @param {Array} [props] containing x and y keys\r\n * @return {Number} angle\r\n */\r\nfunction getAngle(p1, p2, props) {\r\n    if (!props) {\r\n        props = PROPS_XY;\r\n    }\r\n    var x = p2[props[0]] - p1[props[0]],\r\n        y = p2[props[1]] - p1[props[1]];\r\n    return Math.atan2(y, x) * 180 / Math.PI;\r\n}\r\n\r\n/**\r\n * calculate the rotation degrees between two pointersets\r\n * @param {Array} start array of pointers\r\n * @param {Array} end array of pointers\r\n * @return {Number} rotation\r\n */\r\nfunction getRotation(start, end) {\r\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);\r\n}\r\n\r\n/**\r\n * calculate the scale factor between two pointersets\r\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\r\n * @param {Array} start array of pointers\r\n * @param {Array} end array of pointers\r\n * @return {Number} scale\r\n */\r\nfunction getScale(start, end) {\r\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\r\n}\r\n\r\nvar MOUSE_INPUT_MAP = {\r\n    mousedown: INPUT_START,\r\n    mousemove: INPUT_MOVE,\r\n    mouseup: INPUT_END,\r\n    mouseout: INPUT_CANCEL\r\n};\r\n\r\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\r\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseout mouseup';\r\n\r\n/**\r\n * Mouse events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction MouseInput() {\r\n    this.evEl = MOUSE_ELEMENT_EVENTS;\r\n    this.evWin = MOUSE_WINDOW_EVENTS;\r\n\r\n    this.allow = true; // used by Input.TouchMouse to disable mouse events\r\n    this.pressed = false; // mousedown state\r\n\r\n    Input.apply(this, arguments);\r\n}\r\n\r\ninherit(MouseInput, Input, {\r\n    /**\r\n     * handle mouse events\r\n     * @param {Object} ev\r\n     */\r\n    handler: function(ev) {\r\n        var eventType = MOUSE_INPUT_MAP[ev.type];\r\n\r\n        // on start we want to have the left mouse button down\r\n        if (eventType & INPUT_START && ev.button === 0) {\r\n            this.pressed = true;\r\n        }\r\n\r\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\r\n            eventType = INPUT_END;\r\n        }\r\n\r\n        // mouse must be down, and mouse events are allowed (see the TouchMouse input)\r\n        if (!this.pressed || !this.allow) {\r\n            return;\r\n        }\r\n\r\n        // out of the window?\r\n        var target = ev.relatedTarget || ev.toElement || ev.target;\r\n        if (ev.type == 'mouseout' && target.nodeName != 'HTML') {\r\n            eventType = INPUT_MOVE;\r\n        }\r\n\r\n        if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n            this.pressed = false;\r\n        }\r\n\r\n        this.callback(this.manager, eventType, {\r\n            pointers: [ev],\r\n            changedPointers: [ev],\r\n            pointerType: INPUT_TYPE_MOUSE,\r\n            srcEvent: ev\r\n        });\r\n    },\r\n});\r\n\r\nvar POINTER_INPUT_MAP = {\r\n    pointerdown: INPUT_START,\r\n    pointermove: INPUT_MOVE,\r\n    pointerup: INPUT_END,\r\n    pointercancel: INPUT_CANCEL,\r\n    pointerout: INPUT_CANCEL\r\n};\r\n\r\n// in IE10 the pointer types is defined as an enum\r\nvar IE10_POINTER_TYPE_ENUM = {\r\n    2: INPUT_TYPE_TOUCH,\r\n    3: INPUT_TYPE_PEN,\r\n    4: INPUT_TYPE_MOUSE,\r\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\r\n};\r\n\r\nvar POINTER_ELEMENT_EVENTS = 'pointerdown pointermove pointerup pointercancel';\r\nvar POINTER_WINDOW_EVENTS = 'pointerout';\r\n\r\n// IE10 has prefixed support, and case-sensitive\r\nif (window.MSPointerEvent) {\r\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown MSPointerMove MSPointerUp MSPointerCancel';\r\n    POINTER_WINDOW_EVENTS = 'MSPointerOut';\r\n}\r\n\r\n/**\r\n * Pointer events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction PointerEventInput() {\r\n    this.evEl = POINTER_ELEMENT_EVENTS;\r\n    this.evWin = POINTER_WINDOW_EVENTS;\r\n\r\n    Input.apply(this, arguments);\r\n\r\n    this.store = (this.manager.session.pointerEvents = []);\r\n}\r\n\r\ninherit(PointerEventInput, Input, {\r\n    /**\r\n     * handle mouse events\r\n     * @param {Object} ev\r\n     */\r\n    handler: function(ev) {\r\n        var store = this.store;\r\n        var removePointer = false;\r\n\r\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\r\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\r\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\r\n\r\n        // out of the window?\r\n        var target = ev.relatedTarget || ev.toElement || ev.target;\r\n        if (eventTypeNormalized == 'pointerout' && target.nodeName != 'HTML') {\r\n            eventType = INPUT_MOVE;\r\n        }\r\n\r\n        // start and mouse must be down\r\n        if (eventType & INPUT_START && (ev.button === 0 || pointerType == INPUT_TYPE_TOUCH)) {\r\n            store.push(ev);\r\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n            removePointer = true;\r\n        }\r\n\r\n        // get index of the event in the store\r\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\r\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\r\n        if (storeIndex < 0) {\r\n            return;\r\n        }\r\n\r\n        // update the event in the store\r\n        store[storeIndex] = ev;\r\n\r\n        this.callback(this.manager, eventType, {\r\n            pointers: store,\r\n            changedPointers: [ev],\r\n            pointerType: pointerType,\r\n            srcEvent: ev\r\n        });\r\n\r\n        if (removePointer) {\r\n            // remove from the store\r\n            store.splice(storeIndex, 1);\r\n        }\r\n    }\r\n});\r\n\r\nvar TOUCH_INPUT_MAP = {\r\n    touchstart: INPUT_START,\r\n    touchmove: INPUT_MOVE,\r\n    touchend: INPUT_END,\r\n    touchcancel: INPUT_CANCEL\r\n};\r\n\r\nvar TOUCH_EVENTS = 'touchstart touchmove touchend touchcancel';\r\n\r\n/**\r\n * Touch events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction TouchInput() {\r\n    this.evEl = TOUCH_EVENTS;\r\n    this.targetIds = {};\r\n\r\n    Input.apply(this, arguments);\r\n}\r\n\r\ninherit(TouchInput, Input, {\r\n    /**\r\n     * handle touch events\r\n     * @param {Object} ev\r\n     */\r\n    handler: function(ev) {\r\n        var touches = normalizeTouches(ev, this);\r\n        this.callback(this.manager, TOUCH_INPUT_MAP[ev.type], {\r\n            pointers: touches[0],\r\n            changedPointers: touches[1],\r\n            pointerType: INPUT_TYPE_TOUCH,\r\n            srcEvent: ev\r\n        });\r\n    }\r\n});\r\n\r\n/**\r\n * make sure all browsers return the same touches\r\n * @param {Object} ev\r\n * @param {TouchInput} touchInput\r\n * @returns {Array} [all, changed]\r\n */\r\nfunction normalizeTouches(ev, touchInput) {\r\n    var i, len;\r\n\r\n    var targetIds = touchInput.targetIds;\r\n    var targetTouches = toArray(ev.targetTouches);\r\n    var changedTouches = toArray(ev.changedTouches);\r\n    var changedTargetTouches = [];\r\n\r\n    // collect touches\r\n    if (ev.type == 'touchstart') {\r\n        for (i = 0, len = targetTouches.length; i < len; i++) {\r\n            targetIds[targetTouches[i].identifier] = true;\r\n        }\r\n    }\r\n\r\n    // filter changed touches to only contain touches that exist in the collected target ids\r\n    for (i = 0, len = changedTouches.length; i < len; i++) {\r\n        if (targetIds[changedTouches[i].identifier]) {\r\n            changedTargetTouches.push(changedTouches[i]);\r\n        }\r\n\r\n        // cleanup removed touches\r\n        if (ev.type == 'touchend'|| ev.type == 'touchcancel') {\r\n            delete targetIds[changedTouches[i].identifier];\r\n        }\r\n    }\r\n\r\n    return [\r\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\r\n        // also removed the duplicates\r\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier'),\r\n\r\n        // only the changed :-)\r\n        changedTargetTouches\r\n    ];\r\n}\r\n\r\n/**\r\n * Combined touch and mouse input\r\n *\r\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\r\n * This because touch devices also emit mouse events while doing a touch.\r\n *\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction TouchMouseInput() {\r\n    Input.apply(this, arguments);\r\n\r\n    var handler = bindFn(this.handler, this);\r\n    this.touch = new TouchInput(this.manager, handler);\r\n    this.mouse = new MouseInput(this.manager, handler);\r\n}\r\n\r\ninherit(TouchMouseInput, Input, {\r\n    /**\r\n     * handle mouse and touch events\r\n     * @param {Hammer} manager\r\n     * @param {String} inputEvent\r\n     * @param {Object} inputData\r\n     */\r\n    handler: function(manager, inputEvent, inputData) {\r\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\r\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\r\n\r\n        // when we're in a touch event, so  block all upcoming mouse events\r\n        // most mobile browser also emit mouseevents, right after touchstart\r\n        if (isTouch) {\r\n            this.mouse.allow = false;\r\n        } else if (isMouse && !this.mouse.allow) {\r\n            return;\r\n        }\r\n\r\n        // reset the allowMouse when we're done\r\n        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {\r\n            this.mouse.allow = true;\r\n        }\r\n\r\n        this.callback(manager, inputEvent, inputData);\r\n    },\r\n\r\n    /**\r\n     * remove the event listeners\r\n     */\r\n    destroy: function() {\r\n        this.touch.destroy();\r\n        this.mouse.destroy();\r\n    }\r\n});\r\n\r\nvar PREFIXED_TOUCH_ACTION = prefixed(document.body.style, 'touchAction');\r\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\r\n\r\n// magical touchAction value\r\nvar TOUCH_ACTION_COMPUTE = 'compute';\r\nvar TOUCH_ACTION_AUTO = 'auto';\r\nvar TOUCH_ACTION_MANIPULATION = 'manipulation';\r\nvar TOUCH_ACTION_NONE = 'none';\r\nvar TOUCH_ACTION_PAN_X = 'pan-x';\r\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\r\n\r\n/**\r\n * Touch Action\r\n * sets the touchAction property or uses the js alternative\r\n * @param {Manager} manager\r\n * @param {String} value\r\n * @constructor\r\n */\r\nfunction TouchAction(manager, value) {\r\n    this.manager = manager;\r\n    this.set(value);\r\n}\r\n\r\nTouchAction.prototype = {\r\n    /**\r\n     * set the touchAction value on the element or enable the polyfill\r\n     * @param {String} value\r\n     */\r\n    set: function(value) {\r\n        // find out the touch-action by the event handlers\r\n        if (value == TOUCH_ACTION_COMPUTE) {\r\n            value = this.compute();\r\n        }\r\n\r\n        if (NATIVE_TOUCH_ACTION) {\r\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\r\n        }\r\n        this.actions = value.toLowerCase();\r\n    },\r\n\r\n    /**\r\n     * just re-set the touchAction value\r\n     */\r\n    update: function() {\r\n        this.set(this.manager.options.touchAction);\r\n    },\r\n\r\n    /**\r\n     * compute the value for the touchAction property based on the recognizer's settings\r\n     * @returns {String} value\r\n     */\r\n    compute: function() {\r\n        var value;\r\n        var actions = [];\r\n\r\n        each(this.manager.recognizers, function(recognizer) {\r\n            if (boolOrFn(recognizer.options.enable, recognizer)) {\r\n                actions = actions.concat(recognizer.getTouchAction());\r\n            }\r\n        });\r\n        value = uniqueArray(actions).join(' ');\r\n        return cleanTouchActions(value);\r\n    },\r\n\r\n    /**\r\n     * this method is called on each input cycle and provides the preventing of the browser behavior\r\n     * @param {Object} input\r\n     */\r\n    preventDefaults: function(input) {\r\n        // not needed with native support for the touchAction property\r\n        if (NATIVE_TOUCH_ACTION) {\r\n            return;\r\n        }\r\n\r\n        var srcEvent = input.srcEvent;\r\n        var direction = input.offsetDirection;\r\n\r\n        // if the touch action did prevented once this session\r\n        if (this.manager.session.prevented) {\r\n            srcEvent.preventDefault();\r\n            return;\r\n        }\r\n\r\n        var actions = this.actions;\r\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE);\r\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\r\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\r\n\r\n        if (hasNone || (hasPanY && hasPanX) ||\r\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\r\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\r\n            return this.preventSrc(srcEvent);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\r\n     * @param {Object} srcEvent\r\n     */\r\n    preventSrc: function(srcEvent) {\r\n        this.manager.session.prevented = true;\r\n        srcEvent.preventDefault();\r\n    }\r\n};\r\n\r\n/**\r\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\r\n * @param {String} actions\r\n * @returns {*}\r\n */\r\nfunction cleanTouchActions(actions) {\r\n    // none\r\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\r\n        return TOUCH_ACTION_NONE;\r\n    }\r\n    // pan-x and pan-y can be combined\r\n    if (inStr(actions, TOUCH_ACTION_PAN_X) || inStr(actions, TOUCH_ACTION_PAN_Y)) {\r\n        return actions.replace(/[\\-\\w]+/g, function(action) {\r\n            if (/^pan\\-/.test(action)) {\r\n                return action;\r\n            }\r\n            return '';\r\n        });\r\n    }\r\n    // manipulation\r\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\r\n        return TOUCH_ACTION_MANIPULATION;\r\n    }\r\n\r\n    return TOUCH_ACTION_AUTO;\r\n}\r\n\r\n/**\r\n * Recognizer flow explained; *\r\n * All recognizers have the initial state of POSSIBLE when a input session starts.\r\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\r\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\r\n *\r\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\r\n * which determines with state it should be.\r\n *\r\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\r\n * POSSIBLE to give it another change on the next cycle.\r\n *\r\n *               Possible\r\n *                  |\r\n *            +-----+---------------+\r\n *            |                     |\r\n *      +-----+-----+               |\r\n *      |           |               |\r\n *   Failed      Cancelled          |\r\n *                          +-------+------+\r\n *                          |              |\r\n *                      Recognized       Began\r\n *                                         |\r\n *                                      Changed\r\n *                                         |\r\n *                                  Ended/Recognized\r\n */\r\nvar STATE_POSSIBLE = 1;\r\nvar STATE_BEGAN = 2;\r\nvar STATE_CHANGED = 4;\r\nvar STATE_ENDED = 8;\r\nvar STATE_RECOGNIZED = STATE_ENDED;\r\nvar STATE_CANCELLED = 16;\r\nvar STATE_FAILED = 32;\r\n\r\n/**\r\n * Recognizer\r\n * Every recognizer needs to extend from this class.\r\n * @constructor\r\n * @param {Object} options\r\n */\r\nfunction Recognizer(options) {\r\n    this.id = uniqueId();\r\n\r\n    this.manager = null;\r\n    this.options = merge(options || {}, this.defaults);\r\n\r\n    // default is enable true\r\n    this.options.enable = ifUndefined(this.options.enable, true);\r\n\r\n    this.state = STATE_POSSIBLE;\r\n\r\n    this.simultaneous = {};\r\n    this.requireFail = [];\r\n}\r\n\r\nRecognizer.prototype = {\r\n    /**\r\n     * @virtual\r\n     * @type {Object}\r\n     */\r\n    defaults: {},\r\n\r\n    /**\r\n     * set options\r\n     * @param {String} option\r\n     * @param {*} val\r\n     */\r\n    set: function(option, val) {\r\n        this.options[option] = val;\r\n\r\n        // also update the touchAction, in case something changed about the directions/enabled state\r\n        this.manager && this.manager.touchAction.update();\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * recognize simultaneous with an other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    recognizeWith: function(otherRecognizer) {\r\n        var simultaneous = this.simultaneous;\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        if (!simultaneous[otherRecognizer.id]) {\r\n            simultaneous[otherRecognizer.id] = otherRecognizer;\r\n            otherRecognizer.recognizeWith(this);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    dropRecognizeWith: function(otherRecognizer) {\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        delete this.simultaneous[otherRecognizer.id];\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * recognizer can only run when an other is failing\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    requireFailure: function(otherRecognizer) {\r\n        var requireFail = this.requireFail;\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        if (inArray(requireFail, otherRecognizer) === -1) {\r\n            requireFail.push(otherRecognizer);\r\n            otherRecognizer.requireFailure(this);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    dropRequireFailure: function(otherRecognizer) {\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        var index = inArray(this.requireFail, otherRecognizer);\r\n        if (index > -1) {\r\n            this.requireFail.splice(index, 1);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * has require failures boolean\r\n     * @returns {boolean}\r\n     */\r\n    hasRequireFailures: function() {\r\n        return this.requireFail.length > 0;\r\n    },\r\n\r\n    /**\r\n     * if the recognizer can recognize simultaneous with an other recognizer\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Boolean}\r\n     */\r\n    canRecognizeWith: function(otherRecognizer) {\r\n        return !!this.simultaneous[otherRecognizer.id];\r\n    },\r\n\r\n    /**\r\n     * You should use `tryEmit` instead of `emit` directly to check\r\n     * that all the needed recognizers has failed before emitting.\r\n     * @param {Object} input\r\n     */\r\n    emit: function(input) {\r\n        this.manager.emit(this.options.event, input); // simple 'eventName' events\r\n        this.manager.emit(this.options.event + stateStr(this.state), input); // like 'panmove' and 'panstart'\r\n    },\r\n\r\n    /**\r\n     * Check that all the require failure recognizers has failed,\r\n     * if true, it emits a gesture event,\r\n     * otherwise, setup the state to FAILED.\r\n     * @param {Object} input\r\n     */\r\n    tryEmit: function(input) {\r\n        if (this.canEmit()) {\r\n            return this.emit(input);\r\n        }\r\n        // it's failing anyway\r\n        this.state = STATE_FAILED;\r\n    },\r\n\r\n    /**\r\n     * can we emit?\r\n     * @returns {boolean}\r\n     */\r\n    canEmit: function() {\r\n        for (var i = 0; i < this.requireFail.length; i++) {\r\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * update the recognizer\r\n     * @param {Object} inputData\r\n     */\r\n    recognize: function(inputData) {\r\n        // make a new copy of the inputData\r\n        // so we can change the inputData without messing up the other recognizers\r\n        var inputDataClone = extend({}, inputData);\r\n\r\n        // is is enabled and allow recognizing?\r\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\r\n            this.reset();\r\n            this.state = STATE_FAILED;\r\n            return;\r\n        }\r\n\r\n        // reset when we've reached the end\r\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\r\n            this.state = STATE_POSSIBLE;\r\n        }\r\n\r\n        this.state = this.process(inputDataClone);\r\n\r\n        // the recognizer has recognized a gesture\r\n        // so trigger an event\r\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\r\n            this.tryEmit(inputDataClone);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * return the state of the recognizer\r\n     * the actual recognizing happens in this method\r\n     * @virtual\r\n     * @param {Object} inputData\r\n     * @returns {Const} STATE\r\n     */\r\n    process: function(inputData) { }, // jshint ignore:line\r\n\r\n    /**\r\n     * return the preferred touch-action\r\n     * @virtual\r\n     * @returns {Array}\r\n     */\r\n    getTouchAction: function() { },\r\n\r\n    /**\r\n     * called when the gesture isn't allowed to recognize\r\n     * like when another is being recognized or it is disabled\r\n     * @virtual\r\n     */\r\n    reset: function() { }\r\n};\r\n\r\n/**\r\n * get a usable string, used as event postfix\r\n * @param {Const} state\r\n * @returns {String} state\r\n */\r\nfunction stateStr(state) {\r\n    if (state & STATE_CANCELLED) {\r\n        return 'cancel';\r\n    } else if (state & STATE_ENDED) {\r\n        return 'end';\r\n    } else if (state & STATE_CHANGED) {\r\n        return 'move';\r\n    } else if (state & STATE_BEGAN) {\r\n        return 'start';\r\n    }\r\n    return '';\r\n}\r\n\r\n/**\r\n * direction cons to string\r\n * @param {Const} direction\r\n * @returns {String}\r\n */\r\nfunction directionStr(direction) {\r\n    if (direction == DIRECTION_DOWN) {\r\n        return 'down';\r\n    } else if (direction == DIRECTION_UP) {\r\n        return 'up';\r\n    } else if (direction == DIRECTION_LEFT) {\r\n        return 'left';\r\n    } else if (direction == DIRECTION_RIGHT) {\r\n        return 'right';\r\n    }\r\n    return '';\r\n}\r\n\r\n/**\r\n * get a recognizer by name if it is bound to a manager\r\n * @param {Recognizer|String} otherRecognizer\r\n * @param {Recognizer} recognizer\r\n * @returns {Recognizer}\r\n */\r\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\r\n    var manager = recognizer.manager;\r\n    if (manager) {\r\n        return manager.get(otherRecognizer);\r\n    }\r\n    return otherRecognizer;\r\n}\r\n\r\n/**\r\n * This recognizer is just used as a base for the simple attribute recognizers.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nfunction AttrRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(AttrRecognizer, Recognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof AttrRecognizer\r\n     */\r\n    defaults: {\r\n        /**\r\n         * @type {Number}\r\n         * @default 1\r\n         */\r\n        pointers: 1\r\n    },\r\n\r\n    /**\r\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\r\n     * @memberof AttrRecognizer\r\n     * @param {Object} input\r\n     * @returns {Boolean} recognized\r\n     */\r\n    attrTest: function(input) {\r\n        var optionPointers = this.options.pointers;\r\n        return optionPointers === 0 || input.pointers.length === optionPointers;\r\n    },\r\n\r\n    /**\r\n     * Process the input and return the state for the recognizer\r\n     * @memberof AttrRecognizer\r\n     * @param {Object} input\r\n     * @returns {*} State\r\n     */\r\n    process: function(input) {\r\n        var state = this.state;\r\n        var eventType = input.eventType;\r\n\r\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\r\n        var isValid = this.attrTest(input);\r\n\r\n        // on cancel input and we've recognized before, return STATE_CANCELLED\r\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\r\n            return state | STATE_CANCELLED;\r\n        } else if (isRecognized || isValid) {\r\n            if (eventType & INPUT_END) {\r\n                return state | STATE_ENDED;\r\n            } else if (!(state & STATE_BEGAN)) {\r\n                return STATE_BEGAN;\r\n            }\r\n            return state | STATE_CHANGED;\r\n        }\r\n        return STATE_FAILED;\r\n    }\r\n});\r\n\r\n/**\r\n * Pan\r\n * Recognized when the pointer is down and moved in the allowed direction.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction PanRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n\r\n    this.pX = null;\r\n    this.pY = null;\r\n}\r\n\r\ninherit(PanRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PanRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'pan',\r\n        threshold: 10,\r\n        pointers: 1,\r\n        direction: DIRECTION_ALL\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        var direction = this.options.direction;\r\n\r\n        if (direction === DIRECTION_ALL) {\r\n            return [TOUCH_ACTION_NONE];\r\n        }\r\n\r\n        var actions = [];\r\n        if (direction & DIRECTION_HORIZONTAL) {\r\n            actions.push(TOUCH_ACTION_PAN_Y);\r\n        }\r\n        if (direction & DIRECTION_VERTICAL) {\r\n            actions.push(TOUCH_ACTION_PAN_X);\r\n        }\r\n        return actions;\r\n    },\r\n\r\n    directionTest: function(input) {\r\n        var options = this.options;\r\n        var hasMoved = true;\r\n        var distance = input.distance;\r\n        var direction = input.direction;\r\n        var x = input.deltaX;\r\n        var y = input.deltaY;\r\n\r\n        // lock to axis?\r\n        if (!(direction & options.direction)) {\r\n            if (options.direction & DIRECTION_HORIZONTAL) {\r\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n                hasMoved = x != this.pX;\r\n                distance = Math.abs(input.deltaX);\r\n            } else {\r\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\r\n                hasMoved = y != this.pY;\r\n                distance = Math.abs(input.deltaY);\r\n            }\r\n        }\r\n        input.direction = direction;\r\n        return hasMoved && distance > options.threshold && direction & options.direction;\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\r\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\r\n    },\r\n\r\n    emit: function(input) {\r\n        this.pX = input.deltaX;\r\n        this.pY = input.deltaY;\r\n\r\n        this._super.emit.call(this, input);\r\n\r\n        var direction = directionStr(input.direction);\r\n        if (direction) {\r\n            this.manager.emit(this.options.event + direction, input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Pinch\r\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction PinchRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(PinchRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PinchRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'pinch',\r\n        threshold: 0,\r\n        pointers: 2\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y];\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return this._super.attrTest.call(this, input) &&\r\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\r\n    },\r\n\r\n    emit: function(input) {\r\n        this._super.emit.call(this, input);\r\n        if (input.scale !== 1) {\r\n            var inOut = input.scale < 1 ? 'in' : 'out';\r\n            this.manager.emit(this.options.event + inOut, input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Press\r\n * Recognized when the pointer is down for x ms without any movement.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nfunction PressRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n\r\n    this._timer = null;\r\n    this._input = null;\r\n}\r\n\r\ninherit(PressRecognizer, Recognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PressRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'press',\r\n        pointers: 1,\r\n        time: 500, // minimal time of the pointer to be pressed\r\n        threshold: 5 // a minimal movement is ok, but keep it low\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_AUTO];\r\n    },\r\n\r\n    process: function(input) {\r\n        var options = this.options;\r\n\r\n        var validPointers = input.pointers.length === options.pointers;\r\n        var validMovement = input.distance < options.threshold;\r\n        var validTime = input.deltaTime > options.time;\r\n\r\n        this._input = input;\r\n\r\n        // we only allow little movement\r\n        // and we've reached an end event, so a tap is possible\r\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\r\n            this.reset();\r\n        } else if (input.eventType & INPUT_START) {\r\n            this.reset();\r\n            this._timer = setTimeoutScope(function() {\r\n                this.state = STATE_RECOGNIZED;\r\n                this.tryEmit();\r\n            }, options.time, this);\r\n        }\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    reset: function() {\r\n        clearTimeout(this._timer);\r\n    },\r\n\r\n    emit: function() {\r\n        if (this.state === STATE_RECOGNIZED) {\r\n            this._input.timeStamp = now();\r\n            this.manager.emit(this.options.event, this._input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Rotate\r\n * Recognized when two or more pointer are moving in a circular motion.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction RotateRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(RotateRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof RotateRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'rotate',\r\n        threshold: 0,\r\n        pointers: 2\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_NONE];\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return this._super.attrTest.call(this, input) &&\r\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\r\n    }\r\n});\r\n\r\n/**\r\n * Swipe\r\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction SwipeRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(SwipeRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof SwipeRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'swipe',\r\n        threshold: 10,\r\n        velocity: 0.65,\r\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\r\n        pointers: 1\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return PanRecognizer.prototype.getTouchAction.call(this);\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        var direction = this.options.direction;\r\n        var velocity;\r\n\r\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\r\n            velocity = input.velocity;\r\n        } else if (direction & DIRECTION_HORIZONTAL) {\r\n            velocity = input.velocityX;\r\n        } else if (direction & DIRECTION_VERTICAL) {\r\n            velocity = input.velocityY;\r\n        }\r\n\r\n        return this._super.attrTest.call(this, input) &&\r\n            direction & input.direction &&\r\n            velocity > this.options.velocity && input.eventType & INPUT_END;\r\n    },\r\n\r\n    emit: function(input) {\r\n        this.manager.emit(this.options.event, input);\r\n\r\n        var direction = directionStr(input.direction);\r\n        if (direction) {\r\n            this.manager.emit(this.options.event + direction, input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\r\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\r\n * a single tap.\r\n *\r\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\r\n * multi-taps being recognized.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nfunction TapRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n\r\n    // previous time and center,\r\n    // used for tap counting\r\n    this.pTime = false;\r\n    this.pCenter = false;\r\n\r\n    this._timer = null;\r\n    this._input = null;\r\n    this.count = 0;\r\n}\r\n\r\ninherit(TapRecognizer, Recognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PinchRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'tap',\r\n        pointers: 1,\r\n        taps: 1,\r\n        interval: 300, // max time between the multi-tap taps\r\n        time: 250, // max time of the pointer to be down (like finger on the screen)\r\n        threshold: 2, // a minimal movement is ok, but keep it low\r\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_MANIPULATION];\r\n    },\r\n\r\n    process: function(input) {\r\n        var options = this.options;\r\n\r\n        var validPointers = input.pointers.length === options.pointers;\r\n        var validMovement = input.distance < options.threshold;\r\n        var validTouchTime = input.deltaTime < options.time;\r\n\r\n        this.reset();\r\n\r\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\r\n            return this._failTimeout();\r\n        }\r\n\r\n        // we only allow little movement\r\n        // and we've reached an end event, so a tap is possible\r\n        if (validMovement && validTouchTime && validPointers) {\r\n            if (input.eventType != INPUT_END) {\r\n                return this._failTimeout();\r\n            }\r\n\r\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\r\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\r\n\r\n            this.pTime = input.timeStamp;\r\n            this.pCenter = input.center;\r\n\r\n            if (!validMultiTap || !validInterval) {\r\n                this.count = 1;\r\n            } else {\r\n                this.count += 1;\r\n            }\r\n\r\n            this._input = input;\r\n\r\n            // if tap count matches we have recognized it,\r\n            // else it has began recognizing...\r\n            var tapCount = this.count % options.taps;\r\n            if (tapCount === 0) {\r\n                // no failing requirements, immediately trigger the tap event\r\n                // or wait as long as the multitap interval to trigger\r\n                if (!this.hasRequireFailures()) {\r\n                    return STATE_RECOGNIZED;\r\n                } else {\r\n                    this._timer = setTimeoutScope(function() {\r\n                        this.state = STATE_RECOGNIZED;\r\n                        this.tryEmit();\r\n                    }, options.interval, this);\r\n                    return STATE_BEGAN;\r\n                }\r\n            }\r\n        }\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    _failTimeout: function() {\r\n        this._timer = setTimeoutScope(function() {\r\n            this.state = STATE_FAILED;\r\n        }, this.options.interval, this);\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    reset: function() {\r\n        clearTimeout(this._timer);\r\n    },\r\n\r\n    emit: function() {\r\n        if (this.state == STATE_RECOGNIZED ) {\r\n            this._input.tapCount = this.count;\r\n            this.manager.emit(this.options.event, this._input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Simple way to create an manager with a default set of recognizers.\r\n * @param {HTMLElement} element\r\n * @param {Object} [options]\r\n * @constructor\r\n */\r\nfunction Hammer(element, options) {\r\n    options = options || {};\r\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.easyRecognizers);\r\n    return new Manager(element, options);\r\n}\r\n\r\n/**\r\n * @const {string}\r\n */\r\nHammer.VERSION = '2.0.0-dev';\r\n\r\n/**\r\n * default settings\r\n * @namespace\r\n */\r\nHammer.defaults = {\r\n    /**\r\n     * set if DOM events are being triggered.\r\n     * But this is slower and unused by simple implementations, so disabled by default.\r\n     * @type {Boolean}\r\n     * @default false\r\n     */\r\n    domEvents: false,\r\n\r\n    /**\r\n     * The value for the touchAction property/fallback.\r\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\r\n     * @type {String}\r\n     * @default compute\r\n     */\r\n    touchAction: TOUCH_ACTION_COMPUTE,\r\n\r\n    /**\r\n     * @type {Boolean}\r\n     * @default true\r\n     */\r\n    enable: true,\r\n\r\n    /**\r\n     * Default recognizer setup when calling `Hammer()`\r\n     * When creating a new Manager these will be skipped.\r\n     * @type {Array}\r\n     */\r\n    easyRecognizers: [\r\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\r\n        [RotateRecognizer, { enable: false }],\r\n        [PinchRecognizer, { enable: false }, ['rotate']],\r\n        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],\r\n        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\r\n        [TapRecognizer],\r\n        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\r\n        [PressRecognizer]\r\n    ],\r\n\r\n    /**\r\n     * Some CSS properties can be used to improve the working of Hammer.\r\n     * Add them to this method and they will be set when creating a new Manager.\r\n     * @namespace\r\n     */\r\n    cssProps: {\r\n        /**\r\n         * Disables text selection to improve the dragging gesture. When the value is `none` it also sets\r\n         * `onselectstart=false` for IE9 on the element. Mainly for desktop browsers.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        userSelect: 'none',\r\n\r\n        /**\r\n         * Disable the Windows Phone grippers when pressing an element.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        touchSelect: 'none',\r\n\r\n        /**\r\n         * Disables the default callout shown when you touch and hold a touch target.\r\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\r\n         * a callout containing information about the link. This property allows you to disable that callout.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        touchCallout: 'none',\r\n\r\n        /**\r\n         * Specifies whether zooming is enabled. Used by IE10>\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        contentZooming: 'none',\r\n\r\n        /**\r\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        userDrag: 'none',\r\n\r\n        /**\r\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\r\n         * clickable element in iOS. This property obeys the alpha value, if specified.\r\n         * @type {String}\r\n         * @default 'rgba(0,0,0,0)'\r\n         */\r\n        tapHighlightColor: 'rgba(0,0,0,0)'\r\n    }\r\n};\r\n\r\nvar STOP = 1;\r\nvar FORCED_STOP = 2;\r\n\r\n/**\r\n * Manager\r\n * @param {HTMLElement} element\r\n * @param {Object} [options]\r\n * @constructor\r\n */\r\nfunction Manager(element, options) {\r\n    options = options || {};\r\n\r\n    this.options = merge(options, Hammer.defaults);\r\n\r\n    this.handlers = {};\r\n    this.session = {};\r\n    this.recognizers = [];\r\n\r\n    this.element = element;\r\n    this.input = createInputInstance(this);\r\n    this.touchAction = new TouchAction(this, this.options.touchAction);\r\n\r\n    toggleCssProps(this, true);\r\n\r\n    each(options.recognizers, function(item) {\r\n        var recognizer = this.add(new (item[0])(item[1]));\r\n        item[2] && each(item[2], recognizer.recognizeWith, recognizer);\r\n        item[3] && each(item[3], recognizer.requireFailure, recognizer);\r\n    }, this);\r\n}\r\n\r\nManager.prototype = {\r\n    /**\r\n     * set options\r\n     * @param {String} option\r\n     * @param {*} val\r\n     */\r\n    set: function(option, val) {\r\n        this.options[option] = val;\r\n    },\r\n\r\n    /**\r\n     * stop recognizing for this session.\r\n     * This session will be discarded, when a new [input]start event is fired.\r\n     * When forced, the recognizer cycle is stopped immediately.\r\n     * @param {Boolean} [force]\r\n     */\r\n    stop: function(force) {\r\n        this.session.stopped = force ? FORCED_STOP : STOP;\r\n    },\r\n\r\n    /**\r\n     * run the recognizers!\r\n     * called by the inputHandler function on every movement of the pointers (touches)\r\n     * it walks through all the recognizers and tries to detect the gesture that is being made\r\n     * @param {Object} inputData\r\n     */\r\n    recognize: function(inputData) {\r\n        if (this.session.stopped) {\r\n            return;\r\n        }\r\n\r\n        // run the touch-action polyfill\r\n        this.touchAction.preventDefaults(inputData);\r\n\r\n        var recognizer;\r\n        var session = this.session;\r\n\r\n        // this holds the recognizer that is being recognized.\r\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\r\n        // if no recognizer is detecting a thing, it is set to `null`\r\n        var curRecognizer = session.curRecognizer;\r\n\r\n        // reset when the last recognizer is recognized\r\n        // or when we're in a new session\r\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\r\n            curRecognizer = session.curRecognizer = null;\r\n        }\r\n\r\n        for (var i = 0, len = this.recognizers.length; i < len; i++) {\r\n            recognizer = this.recognizers[i];\r\n\r\n            // find out if we are allowed try to recognize the input for this one.\r\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\r\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\r\n            //      that is being recognized.\r\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\r\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\r\n            if (this.session.stopped !== FORCED_STOP && ( // 1\r\n                    !curRecognizer || recognizer == curRecognizer || // 2\r\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\r\n                recognizer.recognize(inputData);\r\n            } else {\r\n                recognizer.reset();\r\n            }\r\n\r\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\r\n            // current active recognizer. but only if we don't already have an active recognizer\r\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\r\n                curRecognizer = session.curRecognizer = recognizer;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * get a recognizer by its event name.\r\n     * @param {Recognizer|String} recognizer\r\n     * @returns {Recognizer|Null}\r\n     */\r\n    get: function(recognizer) {\r\n        if (recognizer instanceof Recognizer) {\r\n            return recognizer;\r\n        }\r\n\r\n        var recognizers = this.recognizers;\r\n        for (var i = 0; i < recognizers.length; i++) {\r\n            if (recognizers[i].options.event == recognizer) {\r\n                return recognizers[i];\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * add a recognizer to the manager\r\n     * existing recognizers with the same event name will be removed\r\n     * @param {Recognizer} recognizer\r\n     * @returns {Recognizer}\r\n     */\r\n    add: function(recognizer) {\r\n        // remove existing\r\n        var existing = this.get(recognizer.options.event);\r\n        if (existing) {\r\n            this.remove(existing);\r\n        }\r\n\r\n        this.recognizers.push(recognizer);\r\n        recognizer.manager = this;\r\n\r\n        this.touchAction.update();\r\n        return recognizer;\r\n    },\r\n\r\n    /**\r\n     * remove a recognizer by name or instance\r\n     * @param {Recognizer|String} recognizer\r\n     */\r\n    remove: function(recognizer) {\r\n        var recognizers = this.recognizers;\r\n        recognizer = this.get(recognizer);\r\n        recognizers.splice(inArray(recognizers, recognizer), 1);\r\n\r\n        this.touchAction.update();\r\n    },\r\n\r\n    /**\r\n     * bind event\r\n     * @param {String} events\r\n     * @param {Function} handler\r\n     * @returns {EventEmitter} this\r\n     */\r\n    on: function(events, handler) {\r\n        var handlers = this.handlers;\r\n        each(splitStr(events), function(event) {\r\n            handlers[event] = handlers[event] || [];\r\n            handlers[event].push(handler);\r\n        });\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * unbind event, leave emit blank to remove all handlers\r\n     * @param {String} events\r\n     * @param {Function} [handler]\r\n     * @returns {EventEmitter} this\r\n     */\r\n    off: function(events, handler) {\r\n        var handlers = this.handlers;\r\n        each(splitStr(events), function(event) {\r\n            if (!handler) {\r\n                delete handlers[event];\r\n            } else {\r\n                handlers[event].splice(inArray(handlers[event], handler), 1);\r\n            }\r\n        });\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * emit event to the listeners\r\n     * @param {String} event\r\n     * @param {Object} data\r\n     */\r\n    emit: function(event, data) {\r\n        // we also want to trigger dom events\r\n        if (this.options.domEvents) {\r\n            triggerDomEvent(event, data);\r\n        }\r\n\r\n        // no handlers, so skip it all\r\n        var handlers = this.handlers[event];\r\n        if (!handlers || !handlers.length) {\r\n            return;\r\n        }\r\n\r\n        data.type = event;\r\n        data.preventDefault = function() {\r\n            data.srcEvent.preventDefault();\r\n        };\r\n\r\n        for (var i = 0, len = handlers.length; i < len; i++) {\r\n            handlers[i](data);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * destroy the manager and unbinds all events\r\n     * it doesn't unbind dom events, that is the user own responsibility\r\n     */\r\n    destroy: function() {\r\n        this.element && toggleCssProps(this, false);\r\n\r\n        this.handlers = {};\r\n        this.session = {};\r\n        this.input.destroy();\r\n        this.element = null;\r\n    }\r\n};\r\n\r\n/**\r\n * add/remove the css properties as defined in manager.options.cssProps\r\n * @param {Manager} manager\r\n * @param {Boolean} add\r\n */\r\nfunction toggleCssProps(manager, add) {\r\n    var element = manager.element;\r\n    var cssProps = manager.options.cssProps;\r\n\r\n    each(cssProps, function(value, name) {\r\n        element.style[prefixed(element.style, name)] = add ? value : '';\r\n    });\r\n\r\n    var falseFn = add && function() { return false; };\r\n    if (cssProps.userSelect == 'none') { element.onselectstart = falseFn; }\r\n    if (cssProps.userDrag == 'none') { element.ondragstart = falseFn; }\r\n}\r\n\r\n/**\r\n * trigger dom event\r\n * @param {String} event\r\n * @param {Object} data\r\n */\r\nfunction triggerDomEvent(event, data) {\r\n    var gestureEvent = document.createEvent('Event');\r\n    gestureEvent.initEvent(event, true, true);\r\n    gestureEvent.gesture = data;\r\n    data.target.dispatchEvent(gestureEvent);\r\n}\r\n\r\nextend(Hammer, {\r\n    INPUT_START: INPUT_START,\r\n    INPUT_MOVE: INPUT_MOVE,\r\n    INPUT_END: INPUT_END,\r\n    INPUT_CANCEL: INPUT_CANCEL,\r\n\r\n    STATE_POSSIBLE: STATE_POSSIBLE,\r\n    STATE_BEGAN: STATE_BEGAN,\r\n    STATE_CHANGED: STATE_CHANGED,\r\n    STATE_ENDED: STATE_ENDED,\r\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\r\n    STATE_CANCELLED: STATE_CANCELLED,\r\n    STATE_FAILED: STATE_FAILED,\r\n\r\n    DIRECTION_NONE: DIRECTION_NONE,\r\n    DIRECTION_LEFT: DIRECTION_LEFT,\r\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\r\n    DIRECTION_UP: DIRECTION_UP,\r\n    DIRECTION_DOWN: DIRECTION_DOWN,\r\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\r\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\r\n    DIRECTION_ALL: DIRECTION_ALL,\r\n\r\n    Manager: Manager,\r\n    Input: Input,\r\n    TouchAction: TouchAction,\r\n\r\n    Recognizer: Recognizer,\r\n    AttrRecognizer: AttrRecognizer,\r\n    Tap: TapRecognizer,\r\n    Pan: PanRecognizer,\r\n    Swipe: SwipeRecognizer,\r\n    Pinch: PinchRecognizer,\r\n    Rotate: RotateRecognizer,\r\n    Press: PressRecognizer,\r\n\r\n    on: addEventListeners,\r\n    off: removeEventListeners,\r\n    each: each,\r\n    merge: merge,\r\n    extend: extend,\r\n    inherit: inherit,\r\n    bindFn: bindFn,\r\n    prefixed: prefixed\r\n});\r\n\r\nif (typeof define == TYPE_FUNCTION && define.amd) {\r\n    define(function() {\r\n        return Hammer;\r\n    });\r\n} else if (typeof module != TYPE_UNDEFINED && module.exports) {\r\n    module.exports = Hammer;\r\n} else {\r\n    window.Hammer = Hammer;\r\n}\r\n\r\n})(window);","module.exports = __webpack_amd_options__;\r\n"],"sourceRoot":"webpack-module://"}