{"version":3,"file":"index.js","sources":["index.js","webpack/bootstrap ee8368834bd9f2a90e81","./src/assets/js/index.js","./src/assets/js/trackers.js","./src/assets/js/demo.js","./~/hammerjs/hammer.js","(webpack)/buildin/amd-options.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","d","s","js","fjs","getElementsByTagName","getElementById","createElement","src","parentNode","insertBefore","document","location","href","indexOf","_gaq","push","ga","type","async","protocol","resetElementStart","el","className","resetElementEnd","transform","translate","x","startX","y","startY","scale","rotate","requestElementUpdate","updateElementTransform","value","style","webkitTransform","join","ticking","reqAnimationFrame","onPan","ev","deltaX","deltaY","onSwipe","setTimeout","onPinch","onRotate","rotation","onTap","onDoubleTap","onHold","background","Hammer","window","prefixed","callback","querySelector","Math","round","offsetWidth","offsetHeight","mc","get","set","on","addEventListener","classList","toggle","__WEBPACK_AMD_DEFINE_RESULT__","undefined","each","obj","iterator","context","i","len","forEach","length","hasOwnProperty","extend","dest","merge","keys","Object","inherit","child","base","properties","childP","baseP","prototype","create","constructor","Inherited","this","_super","bindFn","fn","apply","arguments","boolOrFn","val","args","TYPE_FUNCTION","ifUndefined","val1","val2","addEventListeners","element","types","handler","splitStr","removeEventListeners","removeEventListener","hasParent","node","parent","inStr","str","find","trim","split","inArray","findByKey","toArray","Array","slice","uniqueArray","key","results","values","property","prefix","prop","camelProp","toUpperCase","VENDOR_PREFIXES","uniqueId","_uniqueId","Input","manager","self","domHandler","options","enable","evEl","evWin","createInputInstance","Type","SUPPORT_POINTER_EVENTS","PointerEventInput","SUPPORT_ONLY_TOUCH","TouchInput","SUPPORT_TOUCH","TouchMouseInput","MouseInput","inputHandler","eventType","input","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","INPUT_START","isFinal","INPUT_END","session","computeInputData","recognize","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","timeStamp","Date","now","deltaTime","angle","getAngle","distance","getDistance","offsetDirection","getDirection","getScale","getRotation","target","srcEvent","computeIntervalInputData","last","lastInterval","velocity","velocityX","velocityY","direction","COMPUTE_INTERVAL","v","getVelocity","max","clientX","clientY","abs","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","p1","p2","props","PROPS_XY","sqrt","atan2","PI","start","end","PROPS_CLIENT_XY","MOUSE_ELEMENT_EVENTS","MOUSE_WINDOW_EVENTS","allow","pressed","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","store","pointerEvents","TOUCH_EVENTS","targetIds","normalizeTouches","touchInput","targetTouches","changedTouches","changedTargetTouches","identifier","concat","touch","mouse","TouchAction","cleanTouchActions","actions","TOUCH_ACTION_NONE","TOUCH_ACTION_PAN_X","TOUCH_ACTION_PAN_Y","replace","action","test","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_AUTO","Recognizer","defaults","state","STATE_POSSIBLE","simultaneous","requireFail","stateStr","STATE_CANCELLED","STATE_ENDED","STATE_CHANGED","STATE_BEGAN","directionStr","getRecognizerByNameIfManager","otherRecognizer","recognizer","AttrRecognizer","PanRecognizer","pX","pY","PinchRecognizer","PressRecognizer","_timer","_input","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","count","recognizers","easyRecognizers","Manager","handlers","touchAction","toggleCssProps","item","add","recognizeWith","requireFailure","cssProps","name","falseFn","userSelect","onselectstart","userDrag","ondragstart","triggerDomEvent","event","data","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","TYPE_UNDEFINED","MOBILE_REGEX","navigator","userAgent","INPUT_TYPE_TOUCH","INPUT_TYPE_PEN","INPUT_TYPE_MOUSE","INPUT_TYPE_KINECT","INPUT_MOVE","INPUT_CANCEL","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","destroy","elEvents","winEvents","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","mouseout","button","which","relatedTarget","toElement","nodeName","pointerType","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM",2,3,4,5,"MSPointerEvent","removePointer","eventTypeNormalized","toLowerCase","storeIndex","pointerId","splice","TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","touches","inputEvent","inputData","isTouch","isMouse","PREFIXED_TOUCH_ACTION","body","NATIVE_TOUCH_ACTION","TOUCH_ACTION_COMPUTE","compute","update","getTouchAction","preventDefaults","prevented","preventDefault","hasNone","hasPanY","hasPanX","preventSrc","STATE_RECOGNIZED","STATE_FAILED","option","dropRecognizeWith","dropRequireFailure","index","hasRequireFailures","canRecognizeWith","emit","tryEmit","canEmit","inputDataClone","process","reset","attrTest","optionPointers","isRecognized","isValid","threshold","directionTest","hasMoved","inOut","time","validPointers","validMovement","validTime","clearTimeout","taps","delay","interval","posThreshold","validTouchTime","_setupBeganState","validInterval","validMultiTap","tapCount","VERSION","domEvents","touchSelect","touchCallout","contentZooming","tapHighlightColor","STOP","FORCED_STOP","stop","force","stopped","curRecognizer","existing","remove","events","off","Tap","Pan","Swipe","Pinch","Rotate","Press","__webpack_amd_options__"],"mappings":"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","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/assets/js/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\r\n\t__webpack_require__(2);\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t!function (d, s, id) {\r\n\t    var js, fjs = d.getElementsByTagName(s)[0];\r\n\t    if (!d.getElementById(id)) {\r\n\t        js = d.createElement(s);\r\n\t        js.id = id;\r\n\t        js.src = \"//platform.twitter.com/widgets.js\";\r\n\t        fjs.parentNode.insertBefore(js, fjs);\r\n\t    }\r\n\t}(document, \"script\", \"twitter-wjs\");\r\n\t\r\n\tif(location.href.indexOf(\"eightmedia.github.io\") > -1) {\r\n\t    var _gaq = _gaq || [];\r\n\t    _gaq.push(['_setAccount', 'UA-30289566-1']);\r\n\t    _gaq.push(['_trackPageview']);\r\n\t    (function () {\r\n\t        var ga = document.createElement('script');\r\n\t        ga.type = 'text/javascript';\r\n\t        ga.async = true;\r\n\t        ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';\r\n\t        var s = document.getElementsByTagName('script')[0];\r\n\t        s.parentNode.insertBefore(ga, s);\r\n\t    })();\r\n\t}\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Hammer = __webpack_require__(3);\r\n\t\r\n\t// polyfill\r\n\tvar reqAnimationFrame = (function () {\r\n\t    return window[Hammer.prefixed(window, 'requestAnimationFrame')] || function (callback) {\r\n\t        window.setTimeout(callback, 1000 / 60);\r\n\t    };\r\n\t})();\r\n\t\r\n\tvar el = document.querySelector(\"#hitarea\");\r\n\t\r\n\tvar startX = Math.round((el.parentNode.offsetWidth - el.offsetWidth) / 2);\r\n\tvar startY = Math.round((el.parentNode.offsetHeight - el.offsetHeight) / 2);\r\n\t\r\n\tvar ticking = false;\r\n\tvar transform;\r\n\t\r\n\tvar mc = new Hammer(el);\r\n\t\r\n\tmc.get('pinch').set('enable', true);\r\n\tmc.get('rotate').set('enable', true);\r\n\t\r\n\tmc.on(\"pan\", onPan);\r\n\tmc.on(\"swipe\", onSwipe);\r\n\tmc.on(\"rotate\", onRotate);\r\n\tmc.on(\"pinch\", onPinch);\r\n\tmc.on(\"tap\", onTap);\r\n\tmc.on(\"doubletap\", onDoubleTap);\r\n\tmc.on(\"hold\", onHold);\r\n\t\r\n\tmc.on(\"panstart rotatestart pinchstart\", resetElementStart);\r\n\tmc.on(\"panend rotateend pinchend pancancel rotatecancel pinchcancel\", resetElementEnd);\r\n\t\r\n\tfunction resetElementStart() {\r\n\t    el.className = '';\r\n\t}\r\n\t\r\n\tfunction resetElementEnd() {\r\n\t    transform = {\r\n\t        translate: { x: startX, y: startY },\r\n\t        scale: 1,\r\n\t        rotate: 0\r\n\t    };\r\n\t    el.className = 'animate';\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction updateElementTransform() {\r\n\t    var value = [\r\n\t        'translate3d(' + transform.translate.x + 'px, ' + transform.translate.y + 'px, 0)',\r\n\t        'scale(' + transform.scale + ', ' + transform.scale + ')',\r\n\t        'rotate(' + transform.rotate + 'deg)'];\r\n\t    el.style.webkitTransform = el.style.transform = value.join(\" \");\r\n\t    ticking = false;\r\n\t}\r\n\t\r\n\tfunction requestElementUpdate() {\r\n\t    if(!ticking) {\r\n\t        ticking = true;\r\n\t        reqAnimationFrame(updateElementTransform);\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction onPan(ev) {\r\n\t    transform.translate = {\r\n\t        x: startX + ev.deltaX,\r\n\t        y: startY + ev.deltaY\r\n\t    };\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction onSwipe(ev) {\r\n\t    transform.translate = {\r\n\t        x: startX + (ev.deltaX * 1.2),\r\n\t        y: startY + (ev.deltaY * 1.2)\r\n\t    };\r\n\t    transform.scale = 1.2;\r\n\t    requestElementUpdate();\r\n\t\r\n\t    setTimeout(function () {\r\n\t        resetElementEnd();\r\n\t    }, 400);\r\n\t}\r\n\t\r\n\tfunction onPinch(ev) {\r\n\t    transform.scale = ev.scale;\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction onRotate(ev) {\r\n\t    transform.rotate = ev.rotation;\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction onTap(ev) {\r\n\t    transform.scale = .9;\r\n\t    requestElementUpdate();\r\n\t\r\n\t    setTimeout(function () {\r\n\t        transform.scale = 1;\r\n\t        requestElementUpdate();\r\n\t    }, 200);\r\n\t}\r\n\t\r\n\tfunction onDoubleTap(ev) {\r\n\t    transform.rotate = !transform.rotate ? 360 : 0;\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction onHold(ev) {\r\n\t    el.style.background = '#fd0';\r\n\t    setTimeout(function () {\r\n\t        el.style.background = 'white';\r\n\t        requestElementUpdate();\r\n\t    }, 500);\r\n\t}\r\n\t\r\n\tresetElementEnd();\r\n\t\r\n\tdocument.querySelector(\".device-button\").addEventListener(\"click\", function(){\r\n\t    document.querySelector(\".device\").classList.toggle('hammertime');\r\n\t}, false);\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;(function(window, undefined) {\r\n\t  'use strict';\r\n\t\r\n\tvar VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];\r\n\t\r\n\tvar TYPE_FUNCTION = 'function';\r\n\tvar TYPE_UNDEFINED = 'undefined';\r\n\t\r\n\t/**\r\n\t * walk objects and arrays\r\n\t * @param {Object} obj\r\n\t * @param {Function} iterator\r\n\t * @param {Object} context\r\n\t */\r\n\tfunction each(obj, iterator, context) {\r\n\t    var i, len;\r\n\t\r\n\t    if (!obj) {\r\n\t        return;\r\n\t    }\r\n\t\r\n\t    if (obj.forEach) {\r\n\t        obj.forEach(iterator, context);\r\n\t    } else if (obj.length !== undefined) {\r\n\t        for (i = 0, len = obj.length; i < len; i++) {\r\n\t            iterator.call(context, obj[i], i, obj);\r\n\t        }\r\n\t    } else {\r\n\t        for (i in obj) {\r\n\t            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\t/**\r\n\t * extend object.\r\n\t * means that properties in dest will be overwritten by the ones in src.\r\n\t * @param {Object} dest\r\n\t * @param {Object} src\r\n\t * @param {Boolean} [merge]\r\n\t * @returns {Object} dest\r\n\t */\r\n\tfunction extend(dest, src, merge) {\r\n\t    var keys = Object.keys(src);\r\n\t    for (var i = 0, len = keys.length; i < len; i++) {\r\n\t        if (!merge || (merge && dest[keys[i]] === undefined)) {\r\n\t            dest[keys[i]] = src[keys[i]];\r\n\t        }\r\n\t    }\r\n\t    return dest;\r\n\t}\r\n\t\r\n\t/**\r\n\t * merge the values from src in the dest.\r\n\t * means that properties that exist in dest will not be overwritten by src\r\n\t * @param {Object} dest\r\n\t * @param {Object} src\r\n\t * @returns {Object} dest\r\n\t */\r\n\tfunction merge(dest, src) {\r\n\t    return extend(dest, src, true);\r\n\t}\r\n\t\r\n\t/**\r\n\t * simple class inheritance\r\n\t * @param {Function} child\r\n\t * @param {Function} base\r\n\t * @param {Object} [properties]\r\n\t */\r\n\tfunction inherit(child, base, properties) {\r\n\t    var baseP = base.prototype,\r\n\t        childP;\r\n\t\r\n\t    // object create is supported since IE9\r\n\t    if (Object.create) {\r\n\t        childP = child.prototype = Object.create(baseP);\r\n\t        childP.constructor = child;\r\n\t    } else {\r\n\t        extend(child, base);\r\n\t        var Inherited = function() {\r\n\t            this.constructor = child;\r\n\t        };\r\n\t        Inherited.prototype = baseP;\r\n\t        childP = child.prototype = new Inherited();\r\n\t    }\r\n\t\r\n\t    if (properties) {\r\n\t        extend(childP, properties);\r\n\t    }\r\n\t\r\n\t    childP._super = baseP;\r\n\t}\r\n\t\r\n\t/**\r\n\t * simple function bind\r\n\t * @param {Function} fn\r\n\t * @param {Object} context\r\n\t * @returns {Function}\r\n\t */\r\n\tfunction bindFn(fn, context) {\r\n\t    return function() {\r\n\t        return fn.apply(context, arguments);\r\n\t    };\r\n\t}\r\n\t\r\n\t/**\r\n\t * let a boolean value also be a function that must return a boolean\r\n\t * this first item in args will be used as the context\r\n\t * @param {Boolean|Function} val\r\n\t * @param {Array} [args]\r\n\t * @returns {Boolean}\r\n\t */\r\n\tfunction boolOrFn(val, args) {\r\n\t    if (typeof val == TYPE_FUNCTION) {\r\n\t        return val.apply(args ? args[0] || window : window, args);\r\n\t    }\r\n\t    return val;\r\n\t}\r\n\t\r\n\t/**\r\n\t * use the val2 when val1 is undefined\r\n\t * @param {*} val1\r\n\t * @param {*} val2\r\n\t * @returns {*}\r\n\t */\r\n\tfunction ifUndefined(val1, val2) {\r\n\t    return (val1 === undefined) ? val2 : val1;\r\n\t}\r\n\t\r\n\t/**\r\n\t * addEventListener with multiple events at once\r\n\t * @param {HTMLElement} element\r\n\t * @param {String} types\r\n\t * @param {Function} handler\r\n\t */\r\n\tfunction addEventListeners(element, types, handler) {\r\n\t    each(splitStr(types), function(type) {\r\n\t        element.addEventListener(type, handler, false);\r\n\t    });\r\n\t}\r\n\t\r\n\t/**\r\n\t * removeEventListener with multiple events at once\r\n\t * @param {HTMLElement} element\r\n\t * @param {String} types\r\n\t * @param {Function} handler\r\n\t */\r\n\tfunction removeEventListeners(element, types, handler) {\r\n\t    each(splitStr(types), function(type) {\r\n\t        element.removeEventListener(type, handler, false);\r\n\t    });\r\n\t}\r\n\t\r\n\t/**\r\n\t * find if a node is in the given parent\r\n\t * @method hasParent\r\n\t * @param {HTMLElement} node\r\n\t * @param {HTMLElement} parent\r\n\t * @return {Boolean} found\r\n\t */\r\n\tfunction hasParent(node, parent) {\r\n\t    while (node) {\r\n\t        if (node == parent) {\r\n\t            return true;\r\n\t        }\r\n\t        node = node.parentNode;\r\n\t    }\r\n\t    return false;\r\n\t}\r\n\t\r\n\t/**\r\n\t * store Math.round in a var, for better minimisation\r\n\t */\r\n\tvar round = Math.round;\r\n\t\r\n\t/**\r\n\t * small indexOf wrapper\r\n\t * @param {String} str\r\n\t * @param {String} find\r\n\t * @returns {Boolean} found\r\n\t */\r\n\tfunction inStr(str, find) {\r\n\t    return str.indexOf(find) > -1;\r\n\t}\r\n\t\r\n\t/**\r\n\t * split string on whitespace\r\n\t * @param {String} str\r\n\t * @returns {Array} words\r\n\t */\r\n\tfunction splitStr(str) {\r\n\t    return str.trim().split(/\\s+/g);\r\n\t}\r\n\t\r\n\t/**\r\n\t * find if a array contains the object using indexOf or a simple polyFill\r\n\t * @param {Array} src\r\n\t * @param {String} find\r\n\t * @param {String} [findByKey]\r\n\t * @return {Boolean|Number} false when not found, or the index\r\n\t */\r\n\tfunction inArray(src, find, findByKey) {\r\n\t    if (src.indexOf && !findByKey) {\r\n\t        return src.indexOf(find);\r\n\t    } else {\r\n\t        for (var i = 0, len = src.length; i < len; i++) {\r\n\t            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\r\n\t                return i;\r\n\t            }\r\n\t        }\r\n\t        return -1;\r\n\t    }\r\n\t}\r\n\t\r\n\t/**\r\n\t * convert array-like objects to real arrays\r\n\t * @param {Object} obj\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction toArray(obj) {\r\n\t    return Array.prototype.slice.call(obj, 0);\r\n\t}\r\n\t\r\n\t/**\r\n\t * unique array with objects based on a key (like 'id') or just by the array's value\r\n\t * @param {Array} src [{id:1},{id:2},{id:1}]\r\n\t * @param {String} [key]\r\n\t * @returns {Array} [{id:1},{id:2}]\r\n\t */\r\n\tfunction uniqueArray(src, key) {\r\n\t    var results = [];\r\n\t    var values = [];\r\n\t    for (var i = 0, len = src.length; i < len; i++) {\r\n\t        var val = key ? src[i][key] : src[i];\r\n\t        if (inArray(values, val) < 0) {\r\n\t            results.push(src[i]);\r\n\t        }\r\n\t        values[i] = val;\r\n\t    }\r\n\t    return results;\r\n\t}\r\n\t\r\n\t/**\r\n\t * get the prefixed property\r\n\t * @param {Object} obj\r\n\t * @param {String} property\r\n\t * @returns {String|Undefined} prefixed\r\n\t */\r\n\tfunction prefixed(obj, property) {\r\n\t    var prefix, prop;\r\n\t    var camelProp = property[0].toUpperCase() + property.slice(1);\r\n\t\r\n\t    for (var i = 0, len = VENDOR_PREFIXES.length; i < len; i++) {\r\n\t        prefix = VENDOR_PREFIXES[i];\r\n\t        prop = (prefix) ? prefix + camelProp : property;\r\n\t\r\n\t        if (prop in obj) {\r\n\t            return prop;\r\n\t        }\r\n\t    }\r\n\t    return undefined;\r\n\t}\r\n\t\r\n\t/**\r\n\t * get a unique id\r\n\t * @returns {number} uniqueId\r\n\t */\r\n\tvar _uniqueId = 1;\r\n\tfunction uniqueId() {\r\n\t    return _uniqueId++;\r\n\t}\r\n\t\r\n\tvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\r\n\t\r\n\tvar SUPPORT_TOUCH = ('ontouchstart' in window);\r\n\tvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\r\n\tvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\r\n\t\r\n\tvar INPUT_TYPE_TOUCH = 'touch';\r\n\tvar INPUT_TYPE_PEN = 'pen';\r\n\tvar INPUT_TYPE_MOUSE = 'mouse';\r\n\tvar INPUT_TYPE_KINECT = 'kinect';\r\n\t\r\n\tvar COMPUTE_INTERVAL = 25;\r\n\t\r\n\tvar INPUT_START = 1;\r\n\tvar INPUT_MOVE = 2;\r\n\tvar INPUT_END = 4;\r\n\tvar INPUT_CANCEL = 8;\r\n\t\r\n\tvar DIRECTION_NONE = 1;\r\n\tvar DIRECTION_LEFT = 2;\r\n\tvar DIRECTION_RIGHT = 4;\r\n\tvar DIRECTION_UP = 8;\r\n\tvar DIRECTION_DOWN = 16;\r\n\t\r\n\tvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\r\n\tvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\r\n\tvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\r\n\t\r\n\tvar PROPS_XY = ['x', 'y'];\r\n\tvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\r\n\t\r\n\t/**\r\n\t * create new input type manager\r\n\t * @param {Manager} manager\r\n\t * @param {Function} callback\r\n\t * @returns {Input}\r\n\t * @constructor\r\n\t */\r\n\tfunction Input(manager, callback) {\r\n\t    var self = this;\r\n\t    this.manager = manager;\r\n\t    this.callback = callback;\r\n\t\r\n\t    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\r\n\t    // so when disabled the input events are completely bypassed.\r\n\t    this.domHandler = function(ev) {\r\n\t        if (boolOrFn(self.manager.options.enable, [self.manager])) {\r\n\t            self.handler(ev);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    this.evEl && addEventListeners(this.manager.element, this.evEl, this.domHandler);\r\n\t    this.evWin && addEventListeners(window, this.evWin, this.domHandler);\r\n\t}\r\n\t\r\n\tInput.prototype = {\r\n\t    /**\r\n\t     * should handle the inputEvent data and trigger the callback\r\n\t     * @virtual\r\n\t     */\r\n\t    handler: function() { },\r\n\t\r\n\t    /**\r\n\t     * unbind the events\r\n\t     */\r\n\t    destroy: function() {\r\n\t        this.elEvents && removeEventListeners(this.manager.element, this.elEvents, this.domHandler);\r\n\t        this.winEvents && removeEventListeners(window, this.winEvents, this.domHandler);\r\n\t    }\r\n\t};\r\n\t\r\n\t/**\r\n\t * create new input type manager\r\n\t * @param {Hammer} manager\r\n\t * @returns {Input}\r\n\t */\r\n\tfunction createInputInstance(manager) {\r\n\t    var Type;\r\n\t    if (SUPPORT_POINTER_EVENTS) {\r\n\t        Type = PointerEventInput;\r\n\t    } else if (SUPPORT_ONLY_TOUCH) {\r\n\t        Type = TouchInput;\r\n\t    } else if (!SUPPORT_TOUCH) {\r\n\t        Type = MouseInput;\r\n\t    } else {\r\n\t        Type = TouchMouseInput;\r\n\t    }\r\n\t    return new (Type)(manager, inputHandler);\r\n\t}\r\n\t\r\n\t/**\r\n\t * handle input events\r\n\t * @param {Manager} manager\r\n\t * @param {String} eventType\r\n\t * @param {Object} input\r\n\t */\r\n\tfunction inputHandler(manager, eventType, input) {\r\n\t    var pointersLen = input.pointers.length;\r\n\t    var changedPointersLen = input.changedPointers.length;\r\n\t    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\r\n\t    var isFinal = (eventType & INPUT_END && (pointersLen - changedPointersLen === 0));\r\n\t\r\n\t    input.isFirst = isFirst;\r\n\t    input.isFinal = isFinal;\r\n\t\r\n\t    if (isFirst) {\r\n\t        manager.session = {};\r\n\t    }\r\n\t    // source event is the normalized value of the domEvents\r\n\t    // like 'touchstart, mouseup, pointerdown'\r\n\t    input.eventType = eventType;\r\n\t\r\n\t    // compute scale, rotation etc\r\n\t    computeInputData(manager, input);\r\n\t\r\n\t    manager.recognize(input);\r\n\t}\r\n\t\r\n\t/**\r\n\t * extend the data with some usable properties like scale, rotate, velocity etc\r\n\t * @param {Object} manager\r\n\t * @param {Object} input\r\n\t */\r\n\tfunction computeInputData(manager, input) {\r\n\t    var session = manager.session;\r\n\t    var pointers = input.pointers;\r\n\t    var pointersLength = pointers.length;\r\n\t\r\n\t    // store the first input to calculate the distance and direction\r\n\t    if (!session.firstInput) {\r\n\t        session.firstInput = simpleCloneInputData(input);\r\n\t    }\r\n\t\r\n\t    // to compute scale and rotation we need to store the multiple touches\r\n\t    if (pointersLength > 1 && !session.firstMultiple) {\r\n\t        session.firstMultiple = simpleCloneInputData(input);\r\n\t    } else if (pointersLength === 1) {\r\n\t        session.firstMultiple = false;\r\n\t    }\r\n\t\r\n\t    var firstInput = session.firstInput;\r\n\t    var firstMultiple = session.firstMultiple;\r\n\t    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\r\n\t    var center = getCenter(pointers);\r\n\t\r\n\t    input.timeStamp = Date.now();\r\n\t    input.deltaTime = input.timeStamp - firstInput.timeStamp;\r\n\t    input.deltaX = center.x - offsetCenter.x;\r\n\t    input.deltaY = center.y - offsetCenter.y;\r\n\t\r\n\t    input.center = center;\r\n\t    input.angle = getAngle(offsetCenter, center);\r\n\t    input.distance = getDistance(offsetCenter, center);\r\n\t    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\r\n\t\r\n\t    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\r\n\t    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\r\n\t\r\n\t    // find the correct target\r\n\t    var target = manager.element;\r\n\t    if (hasParent(input.srcEvent.target, target)) {\r\n\t        target = input.srcEvent.target;\r\n\t    }\r\n\t    input.target = target;\r\n\t\r\n\t    computeIntervalInputData(session, input);\r\n\t}\r\n\t\r\n\t/**\r\n\t * velocity is calculated every x ms\r\n\t * @param {Object} session\r\n\t * @param {Object} input\r\n\t */\r\n\tfunction computeIntervalInputData(session, input) {\r\n\t    var last = session.lastInterval;\r\n\t    if (!last) {\r\n\t        last = session.lastInterval = simpleCloneInputData(input);\r\n\t    }\r\n\t\r\n\t    var deltaTime = input.timeStamp - last.timeStamp,\r\n\t        velocity,\r\n\t        velocityX,\r\n\t        velocityY,\r\n\t        direction;\r\n\t\r\n\t    if (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined) {\r\n\t        var deltaX = last.deltaX - input.deltaX;\r\n\t        var deltaY = last.deltaY - input.deltaY;\r\n\t\r\n\t        var v = getVelocity(deltaTime, deltaX, deltaY);\r\n\t        velocityX = v.x;\r\n\t        velocityY = v.y;\r\n\t        velocity = Math.max(v.x, v.y);\r\n\t        direction = getDirection(deltaX, deltaY);\r\n\t    } else {\r\n\t        // use latest velocity info if it doesn't overtake a minimum period\r\n\t        velocity = last.velocity;\r\n\t        velocityX = last.velocityX;\r\n\t        velocityY = last.velocityY;\r\n\t        direction = last.direction;\r\n\t    }\r\n\t\r\n\t    input.velocity = velocity;\r\n\t    input.velocityX = velocityX;\r\n\t    input.velocityY = velocityY;\r\n\t    input.direction = direction;\r\n\t}\r\n\t\r\n\t/**\r\n\t * create a simple clone from the input used for storage of firstInput and firstMultiple\r\n\t * @param {Object} input\r\n\t * @returns {Object} clonedInputData\r\n\t */\r\n\tfunction simpleCloneInputData(input) {\r\n\t    // make a simple copy of the pointers because we will get a reference if we don't\r\n\t    // we only need clientXY for the calculations\r\n\t    var pointers = [];\r\n\t    for (var i = 0; i < input.pointers.length; i++) {\r\n\t        pointers[i] = {\r\n\t            clientX: round(input.pointers[i].clientX),\r\n\t            clientY: round(input.pointers[i].clientY)\r\n\t        };\r\n\t    }\r\n\t\r\n\t    return {\r\n\t        timeStamp: Date.now(),\r\n\t        pointers: pointers,\r\n\t        center: getCenter(pointers),\r\n\t        deltaX: input.deltaX,\r\n\t        deltaY: input.deltaY\r\n\t    };\r\n\t}\r\n\t\r\n\t/**\r\n\t * get the center of all the pointers\r\n\t * @param {Array} pointers\r\n\t * @return {Object} center contains `x` and `y` properties\r\n\t */\r\n\tfunction getCenter(pointers) {\r\n\t    var pointersLength = pointers.length;\r\n\t\r\n\t    // no need to loop when only one touch\r\n\t    if (pointersLength === 1) {\r\n\t        return {\r\n\t            x: round(pointers[0].clientX),\r\n\t            y: round(pointers[0].clientY)\r\n\t        };\r\n\t    }\r\n\t\r\n\t    var x = 0, y = 0;\r\n\t    for (var i = 0; i < pointersLength; i++) {\r\n\t        x += pointers[i].clientX;\r\n\t        y += pointers[i].clientY;\r\n\t    }\r\n\t\r\n\t    return {\r\n\t        x: round(x / pointersLength),\r\n\t        y: round(y / pointersLength)\r\n\t    };\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the velocity between two points. unit is in px per ms.\r\n\t * @param {Number} deltaTime\r\n\t * @param {Number} x\r\n\t * @param {Number} y\r\n\t * @return {Object} velocity `x` and `y`\r\n\t */\r\n\tfunction getVelocity(deltaTime, x, y) {\r\n\t    return {\r\n\t        x: Math.abs(x / deltaTime) || 0,\r\n\t        y: Math.abs(y / deltaTime) || 0\r\n\t    };\r\n\t}\r\n\t\r\n\t/**\r\n\t * get the direction between two points\r\n\t * @param {Number} x\r\n\t * @param {Number} y\r\n\t * @return {Number} direction\r\n\t */\r\n\tfunction getDirection(x, y) {\r\n\t    if (x === y) {\r\n\t        return DIRECTION_NONE;\r\n\t    }\r\n\t\r\n\t    if (Math.abs(x) >= Math.abs(y)) {\r\n\t        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n\t    }\r\n\t    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the absolute distance between two points\r\n\t * @param {Object} p1 {x, y}\r\n\t * @param {Object} p2 {x, y}\r\n\t * @param {Array} [props] containing x and y keys\r\n\t * @return {Number} distance\r\n\t */\r\n\tfunction getDistance(p1, p2, props) {\r\n\t    if (!props) {\r\n\t        props = PROPS_XY;\r\n\t    }\r\n\t    var x = p2[props[0]] - p1[props[0]],\r\n\t        y = p2[props[1]] - p1[props[1]];\r\n\t\r\n\t    return Math.sqrt((x * x) + (y * y));\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the angle between two coordinates\r\n\t * @param {Object} p1\r\n\t * @param {Object} p2\r\n\t * @param {Array} [props] containing x and y keys\r\n\t * @return {Number} angle\r\n\t */\r\n\tfunction getAngle(p1, p2, props) {\r\n\t    if (!props) {\r\n\t        props = PROPS_XY;\r\n\t    }\r\n\t    var x = p2[props[0]] - p1[props[0]],\r\n\t        y = p2[props[1]] - p1[props[1]];\r\n\t    return Math.atan2(y, x) * 180 / Math.PI;\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the rotation degrees between two pointersets\r\n\t * @param {Array} start array of pointers\r\n\t * @param {Array} end array of pointers\r\n\t * @return {Number} rotation\r\n\t */\r\n\tfunction getRotation(start, end) {\r\n\t    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the scale factor between two pointersets\r\n\t * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\r\n\t * @param {Array} start array of pointers\r\n\t * @param {Array} end array of pointers\r\n\t * @return {Number} scale\r\n\t */\r\n\tfunction getScale(start, end) {\r\n\t    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\r\n\t}\r\n\t\r\n\tvar MOUSE_INPUT_MAP = {\r\n\t    mousedown: INPUT_START,\r\n\t    mousemove: INPUT_MOVE,\r\n\t    mouseup: INPUT_END,\r\n\t    mouseout: INPUT_CANCEL\r\n\t};\r\n\t\r\n\tvar MOUSE_ELEMENT_EVENTS = 'mousedown';\r\n\tvar MOUSE_WINDOW_EVENTS = 'mousemove mouseout mouseup';\r\n\t\r\n\t/**\r\n\t * Mouse events input\r\n\t * @constructor\r\n\t * @extends Input\r\n\t */\r\n\tfunction MouseInput() {\r\n\t    this.evEl = MOUSE_ELEMENT_EVENTS;\r\n\t    this.evWin = MOUSE_WINDOW_EVENTS;\r\n\t\r\n\t    this.allow = true; // used by Input.TouchMouse to disable mouse events\r\n\t    this.pressed = false; // mousedown state\r\n\t\r\n\t    Input.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(MouseInput, Input, {\r\n\t    /**\r\n\t     * handle mouse events\r\n\t     * @param {Object} ev\r\n\t     */\r\n\t    handler: function(ev) {\r\n\t        var eventType = MOUSE_INPUT_MAP[ev.type];\r\n\t\r\n\t        // on start we want to have the left mouse button down\r\n\t        if (eventType & INPUT_START && ev.button === 0) {\r\n\t            this.pressed = true;\r\n\t        }\r\n\t\r\n\t        if (eventType & INPUT_MOVE && ev.which !== 1) {\r\n\t            eventType = INPUT_END;\r\n\t        }\r\n\t\r\n\t        // mouse must be down, and mouse events are allowed (see the TouchMouse input)\r\n\t        if (!this.pressed || !this.allow) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        // out of the window?\r\n\t        var target = ev.relatedTarget || ev.toElement || ev.target;\r\n\t        if (ev.type == 'mouseout' && target.nodeName != 'HTML') {\r\n\t            eventType = INPUT_MOVE;\r\n\t        }\r\n\t\r\n\t        if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n\t            this.pressed = false;\r\n\t        }\r\n\t\r\n\t        this.callback(this.manager, eventType, {\r\n\t            pointers: [ev],\r\n\t            changedPointers: [ev],\r\n\t            pointerType: INPUT_TYPE_MOUSE,\r\n\t            srcEvent: ev\r\n\t        });\r\n\t    },\r\n\t});\r\n\t\r\n\tvar POINTER_INPUT_MAP = {\r\n\t    pointerdown: INPUT_START,\r\n\t    pointermove: INPUT_MOVE,\r\n\t    pointerup: INPUT_END,\r\n\t    pointercancel: INPUT_CANCEL,\r\n\t    pointerout: INPUT_CANCEL\r\n\t};\r\n\t\r\n\t// in IE10 the pointer types is defined as an enum\r\n\tvar IE10_POINTER_TYPE_ENUM = {\r\n\t    2: INPUT_TYPE_TOUCH,\r\n\t    3: INPUT_TYPE_PEN,\r\n\t    4: INPUT_TYPE_MOUSE,\r\n\t    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\r\n\t};\r\n\t\r\n\tvar POINTER_ELEMENT_EVENTS = 'pointerdown pointermove pointerup pointercancel';\r\n\tvar POINTER_WINDOW_EVENTS = 'pointerout';\r\n\t\r\n\t// IE10 has prefixed support, and case-sensitive\r\n\tif (window.MSPointerEvent) {\r\n\t    POINTER_ELEMENT_EVENTS = 'MSPointerDown MSPointerMove MSPointerUp MSPointerCancel';\r\n\t    POINTER_WINDOW_EVENTS = 'MSPointerOut';\r\n\t}\r\n\t\r\n\t/**\r\n\t * Pointer events input\r\n\t * @constructor\r\n\t * @extends Input\r\n\t */\r\n\tfunction PointerEventInput() {\r\n\t    this.evEl = POINTER_ELEMENT_EVENTS;\r\n\t    this.evWin = POINTER_WINDOW_EVENTS;\r\n\t\r\n\t    Input.apply(this, arguments);\r\n\t\r\n\t    this.store = (this.manager.session.pointerEvents = []);\r\n\t}\r\n\t\r\n\tinherit(PointerEventInput, Input, {\r\n\t    /**\r\n\t     * handle mouse events\r\n\t     * @param {Object} ev\r\n\t     */\r\n\t    handler: function(ev) {\r\n\t        var store = this.store;\r\n\t        var removePointer = false;\r\n\t\r\n\t        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\r\n\t        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\r\n\t        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\r\n\t\r\n\t        // out of the window?\r\n\t        var target = ev.relatedTarget || ev.toElement || ev.target;\r\n\t        if (eventTypeNormalized == 'pointerout' && target.nodeName != 'HTML') {\r\n\t            eventType = INPUT_MOVE;\r\n\t        }\r\n\t\r\n\t        // start and mouse must be down\r\n\t        if (eventType & INPUT_START && (ev.button === 0 || pointerType == INPUT_TYPE_TOUCH)) {\r\n\t            store.push(ev);\r\n\t        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n\t            removePointer = true;\r\n\t        }\r\n\t\r\n\t        // get index of the event in the store\r\n\t        // it not found, so the pointer hasn't been down (so it's probably a hover)\r\n\t        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\r\n\t        if (storeIndex < 0) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        // update the event in the store\r\n\t        store[storeIndex] = ev;\r\n\t\r\n\t        this.callback(this.manager, eventType, {\r\n\t            pointers: store,\r\n\t            changedPointers: [ev],\r\n\t            pointerType: pointerType,\r\n\t            srcEvent: ev\r\n\t        });\r\n\t\r\n\t        if (removePointer) {\r\n\t            // remove from the store\r\n\t            store.splice(storeIndex, 1);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\tvar TOUCH_INPUT_MAP = {\r\n\t    touchstart: INPUT_START,\r\n\t    touchmove: INPUT_MOVE,\r\n\t    touchend: INPUT_END,\r\n\t    touchcancel: INPUT_CANCEL\r\n\t};\r\n\t\r\n\tvar TOUCH_EVENTS = 'touchstart touchmove touchend touchcancel';\r\n\t\r\n\t/**\r\n\t * Touch events input\r\n\t * @constructor\r\n\t * @extends Input\r\n\t */\r\n\tfunction TouchInput() {\r\n\t    this.evEl = TOUCH_EVENTS;\r\n\t    this.targetIds = {};\r\n\t\r\n\t    Input.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(TouchInput, Input, {\r\n\t    /**\r\n\t     * handle touch events\r\n\t     * @param {Object} ev\r\n\t     */\r\n\t    handler: function(ev) {\r\n\t        var touches = normalizeTouches(ev, this);\r\n\t        this.callback(this.manager, TOUCH_INPUT_MAP[ev.type], {\r\n\t            pointers: touches[0],\r\n\t            changedPointers: touches[1],\r\n\t            pointerType: INPUT_TYPE_TOUCH,\r\n\t            srcEvent: ev\r\n\t        });\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * make sure all browsers return the same touches\r\n\t * @param {Object} ev\r\n\t * @param {TouchInput} touchInput\r\n\t * @returns {Array} [all, changed]\r\n\t */\r\n\tfunction normalizeTouches(ev, touchInput) {\r\n\t    var i, len;\r\n\t\r\n\t    var targetIds = touchInput.targetIds;\r\n\t    var targetTouches = toArray(ev.targetTouches);\r\n\t    var changedTouches = toArray(ev.changedTouches);\r\n\t    var changedTargetTouches = [];\r\n\t\r\n\t    // collect touches\r\n\t    if (ev.type == 'touchstart') {\r\n\t        for (i = 0, len = targetTouches.length; i < len; i++) {\r\n\t            targetIds[targetTouches[i].identifier] = true;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    // filter changed touches to only contain touches that exist in the collected target ids\r\n\t    for (i = 0, len = changedTouches.length; i < len; i++) {\r\n\t        if (targetIds[changedTouches[i].identifier]) {\r\n\t            changedTargetTouches.push(changedTouches[i]);\r\n\t        }\r\n\t\r\n\t        // cleanup removed touches\r\n\t        if (ev.type == 'touchend'|| ev.type == 'touchcancel') {\r\n\t            delete targetIds[changedTouches[i].identifier];\r\n\t        }\r\n\t    }\r\n\t\r\n\t    return [\r\n\t        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\r\n\t        // also removed the duplicates\r\n\t        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier'),\r\n\t\r\n\t        // only the changed :-)\r\n\t        changedTargetTouches\r\n\t    ];\r\n\t}\r\n\t\r\n\t/**\r\n\t * Combined touch and mouse input\r\n\t *\r\n\t * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\r\n\t * This because touch devices also emit mouse events while doing a touch.\r\n\t *\r\n\t * @constructor\r\n\t * @extends Input\r\n\t */\r\n\tfunction TouchMouseInput() {\r\n\t    Input.apply(this, arguments);\r\n\t\r\n\t    var handler = bindFn(this.handler, this);\r\n\t    this.touch = new TouchInput(this.manager, handler);\r\n\t    this.mouse = new MouseInput(this.manager, handler);\r\n\t}\r\n\t\r\n\tinherit(TouchMouseInput, Input, {\r\n\t    /**\r\n\t     * handle mouse and touch events\r\n\t     * @param {Hammer} manager\r\n\t     * @param {String} inputEvent\r\n\t     * @param {Object} inputData\r\n\t     */\r\n\t    handler: function(manager, inputEvent, inputData) {\r\n\t        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\r\n\t            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\r\n\t\r\n\t        // when we're in a touch event, so  block all upcoming mouse events\r\n\t        // most mobile browser also emit mouseevents, right after touchstart\r\n\t        if (isTouch) {\r\n\t            this.mouse.allow = false;\r\n\t        } else if (isMouse && !this.mouse.allow) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        // reset the allowMouse when we're done\r\n\t        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {\r\n\t            this.mouse.allow = true;\r\n\t        }\r\n\t\r\n\t        this.callback(manager, inputEvent, inputData);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * remove the event listeners\r\n\t     */\r\n\t    destroy: function() {\r\n\t        this.touch.destroy();\r\n\t        this.mouse.destroy();\r\n\t    }\r\n\t});\r\n\t\r\n\tvar PREFIXED_TOUCH_ACTION = prefixed(document.body.style, 'touchAction');\r\n\tvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\r\n\t\r\n\t// magical touchAction value\r\n\tvar TOUCH_ACTION_COMPUTE = 'compute';\r\n\tvar TOUCH_ACTION_AUTO = 'auto';\r\n\tvar TOUCH_ACTION_MANIPULATION = 'manipulation';\r\n\tvar TOUCH_ACTION_NONE = 'none';\r\n\tvar TOUCH_ACTION_PAN_X = 'pan-x';\r\n\tvar TOUCH_ACTION_PAN_Y = 'pan-y';\r\n\t\r\n\t/**\r\n\t * Touch Action\r\n\t * sets the touchAction property or uses the js alternative\r\n\t * @param {Manager} manager\r\n\t * @param {String} value\r\n\t * @constructor\r\n\t */\r\n\tfunction TouchAction(manager, value) {\r\n\t    this.manager = manager;\r\n\t    this.set(value);\r\n\t}\r\n\t\r\n\tTouchAction.prototype = {\r\n\t    /**\r\n\t     * set the touchAction value on the element or enable the polyfill\r\n\t     * @param {String} value\r\n\t     */\r\n\t    set: function(value) {\r\n\t        // find out the touch-action by the event handlers\r\n\t        if (value == TOUCH_ACTION_COMPUTE) {\r\n\t            value = this.compute();\r\n\t        }\r\n\t\r\n\t        if (NATIVE_TOUCH_ACTION) {\r\n\t            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\r\n\t        }\r\n\t        this.actions = value.toLowerCase();\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * just re-set the touchAction value\r\n\t     */\r\n\t    update: function() {\r\n\t        this.set(this.manager.options.touchAction);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * compute the value for the touchAction property based on the recognizer's settings\r\n\t     * @returns {String} value\r\n\t     */\r\n\t    compute: function() {\r\n\t        var value;\r\n\t        var actions = [];\r\n\t\r\n\t        each(this.manager.recognizers, function(recognizer) {\r\n\t            if (boolOrFn(recognizer.options.enable, recognizer)) {\r\n\t                actions = actions.concat(recognizer.getTouchAction());\r\n\t            }\r\n\t        });\r\n\t        value = uniqueArray(actions).join(' ');\r\n\t        return cleanTouchActions(value);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * this method is called on each input cycle and provides the preventing of the browser behavior\r\n\t     * @param {Object} input\r\n\t     */\r\n\t    preventDefaults: function(input) {\r\n\t        // not needed with native support for the touchAction property\r\n\t        if (NATIVE_TOUCH_ACTION) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var srcEvent = input.srcEvent;\r\n\t        var direction = input.offsetDirection;\r\n\t\r\n\t        // if the touch action did prevented once this session\r\n\t        if (this.manager.session.prevented) {\r\n\t            srcEvent.preventDefault();\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var actions = this.actions;\r\n\t        var hasNone = inStr(actions, TOUCH_ACTION_NONE);\r\n\t        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\r\n\t        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\r\n\t\r\n\t        if (hasNone || (hasPanY && hasPanX) ||\r\n\t            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\r\n\t            (hasPanX && direction & DIRECTION_VERTICAL)) {\r\n\t            return this.preventSrc(srcEvent);\r\n\t        }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\r\n\t     * @param {Object} srcEvent\r\n\t     */\r\n\t    preventSrc: function(srcEvent) {\r\n\t        this.manager.session.prevented = true;\r\n\t        srcEvent.preventDefault();\r\n\t    }\r\n\t};\r\n\t\r\n\t/**\r\n\t * when the touchActions are collected they are not a valid value, so we need to clean things up. *\r\n\t * @param {String} actions\r\n\t * @returns {*}\r\n\t */\r\n\tfunction cleanTouchActions(actions) {\r\n\t    // none\r\n\t    if (inStr(actions, TOUCH_ACTION_NONE)) {\r\n\t        return TOUCH_ACTION_NONE;\r\n\t    }\r\n\t    // pan-x and pan-y can be combined\r\n\t    if (inStr(actions, TOUCH_ACTION_PAN_X) || inStr(actions, TOUCH_ACTION_PAN_Y)) {\r\n\t        return actions.replace(/[\\-\\w]+/g, function(action) {\r\n\t            if (/^pan\\-/.test(action)) {\r\n\t                return action;\r\n\t            }\r\n\t            return '';\r\n\t        });\r\n\t    }\r\n\t    // manipulation\r\n\t    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\r\n\t        return TOUCH_ACTION_MANIPULATION;\r\n\t    }\r\n\t\r\n\t    return TOUCH_ACTION_AUTO;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Recognizer flow explained; *\r\n\t * All recognizers have the initial state of POSSIBLE when a input session starts.\r\n\t * The definition of a input session is from the first input until the last input, with all it's movement in it. *\r\n\t * Example session for mouse-input: mousedown -> mousemove -> mouseup\r\n\t *\r\n\t * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\r\n\t * which determines with state it should be.\r\n\t *\r\n\t * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\r\n\t * POSSIBLE to give it another change on the next cycle.\r\n\t *\r\n\t *               Possible\r\n\t *                  |\r\n\t *            +-----+---------------+\r\n\t *            |                     |\r\n\t *      +-----+-----+               |\r\n\t *      |           |               |\r\n\t *   Failed      Cancelled          |\r\n\t *                          +-------+------+\r\n\t *                          |              |\r\n\t *                      Recognized       Began\r\n\t *                                         |\r\n\t *                                      Changed\r\n\t *                                         |\r\n\t *                                  Ended/Recognized\r\n\t */\r\n\tvar STATE_POSSIBLE = 1;\r\n\tvar STATE_BEGAN = 2;\r\n\tvar STATE_CHANGED = 4;\r\n\tvar STATE_ENDED = 8;\r\n\tvar STATE_RECOGNIZED = STATE_ENDED;\r\n\tvar STATE_CANCELLED = 16;\r\n\tvar STATE_FAILED = 32;\r\n\t\r\n\t/**\r\n\t * Recognizer\r\n\t * Every recognizer needs to extend from this class.\r\n\t * @constructor\r\n\t * @param {Object} options\r\n\t */\r\n\tfunction Recognizer(options) {\r\n\t    this.id = uniqueId();\r\n\t\r\n\t    this.manager = null;\r\n\t    this.options = merge(options || {}, this.defaults);\r\n\t\r\n\t    // default is enable true\r\n\t    this.options.enable = ifUndefined(this.options.enable, true);\r\n\t\r\n\t    this.state = STATE_POSSIBLE;\r\n\t\r\n\t    this.simultaneous = {};\r\n\t    this.requireFail = [];\r\n\t}\r\n\t\r\n\tRecognizer.prototype = {\r\n\t    /**\r\n\t     * @virtual\r\n\t     * @type {Object}\r\n\t     */\r\n\t    defaults: {},\r\n\t\r\n\t    /**\r\n\t     * set options\r\n\t     * @param {String} option\r\n\t     * @param {*} val\r\n\t     */\r\n\t    set: function(option, val) {\r\n\t        this.options[option] = val;\r\n\t\r\n\t        // also update the touchAction, in case something changed about the directions/enabled state\r\n\t        this.manager && this.manager.touchAction.update();\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * recognize simultaneous with an other recognizer.\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Recognizer} this\r\n\t     */\r\n\t    recognizeWith: function(otherRecognizer) {\r\n\t        var simultaneous = this.simultaneous;\r\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n\t        if (!simultaneous[otherRecognizer.id]) {\r\n\t            simultaneous[otherRecognizer.id] = otherRecognizer;\r\n\t            otherRecognizer.recognizeWith(this);\r\n\t        }\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Recognizer} this\r\n\t     */\r\n\t    dropRecognizeWith: function(otherRecognizer) {\r\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n\t        delete this.simultaneous[otherRecognizer.id];\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * recognizer can only run when an other is failing\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Recognizer} this\r\n\t     */\r\n\t    requireFailure: function(otherRecognizer) {\r\n\t        var requireFail = this.requireFail;\r\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n\t        if (inArray(requireFail, otherRecognizer) === -1) {\r\n\t            requireFail.push(otherRecognizer);\r\n\t            otherRecognizer.requireFailure(this);\r\n\t        }\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * drop the requireFailure link. it does not remove the link on the other recognizer.\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Recognizer} this\r\n\t     */\r\n\t    dropRequireFailure: function(otherRecognizer) {\r\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n\t        var index = inArray(this.requireFail, otherRecognizer);\r\n\t        if (index > -1) {\r\n\t            this.requireFail.splice(index, 1);\r\n\t        }\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * has require failures boolean\r\n\t     * @returns {boolean}\r\n\t     */\r\n\t    hasRequireFailures: function() {\r\n\t        return this.requireFail.length > 0;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * if the recognizer can recognize simultaneous with an other recognizer\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Boolean}\r\n\t     */\r\n\t    canRecognizeWith: function(otherRecognizer) {\r\n\t        return !!this.simultaneous[otherRecognizer.id];\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * You should use `tryEmit` instead of `emit` directly to check\r\n\t     * that all the needed recognizers has failed before emitting.\r\n\t     * @param {Object} input\r\n\t     */\r\n\t    emit: function(input) {\r\n\t        this.manager.emit(this.options.event, input); // simple 'eventName' events\r\n\t        this.manager.emit(this.options.event + stateStr(this.state), input); // like 'panmove' and 'panstart'\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Check that all the require failure recognizers has failed,\r\n\t     * if true, it emits a gesture event,\r\n\t     * otherwise, setup the state to FAILED.\r\n\t     * @param {Object} input\r\n\t     */\r\n\t    tryEmit: function(input) {\r\n\t        if (this.canEmit()) {\r\n\t            return this.emit(input);\r\n\t        }\r\n\t        // it's failing anyway\r\n\t        this.state = STATE_FAILED;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * can we emit?\r\n\t     * @returns {boolean}\r\n\t     */\r\n\t    canEmit: function() {\r\n\t        for (var i = 0; i < this.requireFail.length; i++) {\r\n\t            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\r\n\t                return false;\r\n\t            }\r\n\t        }\r\n\t        return true;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * update the recognizer\r\n\t     * @param {Object} inputData\r\n\t     */\r\n\t    recognize: function(inputData) {\r\n\t        // make a new copy of the inputData\r\n\t        // so we can change the inputData without messing up the other recognizers\r\n\t        var inputDataClone = extend({}, inputData);\r\n\t\r\n\t        // is is enabled and allow recognizing?\r\n\t        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\r\n\t            this.reset();\r\n\t            this.state = STATE_FAILED;\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        // reset when we've reached the end\r\n\t        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\r\n\t            this.state = STATE_POSSIBLE;\r\n\t        }\r\n\t\r\n\t        this.state = this.process(inputDataClone);\r\n\t\r\n\t        // the recognizer has recognized a gesture\r\n\t        // so trigger an event\r\n\t        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\r\n\t            this.tryEmit(inputDataClone);\r\n\t        }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * return the state of the recognizer\r\n\t     * the actual recognizing happens in this method\r\n\t     * @virtual\r\n\t     * @param {Object} inputData\r\n\t     * @returns {Const} STATE\r\n\t     */\r\n\t    process: function(inputData) { }, // jshint ignore:line\r\n\t\r\n\t    /**\r\n\t     * return the preferred touch-action\r\n\t     * @virtual\r\n\t     * @returns {Array}\r\n\t     */\r\n\t    getTouchAction: function() { },\r\n\t\r\n\t    /**\r\n\t     * called when the gesture isn't allowed to recognize\r\n\t     * like when another is being recognized or it is disabled\r\n\t     * @virtual\r\n\t     */\r\n\t    reset: function() { }\r\n\t};\r\n\t\r\n\t/**\r\n\t * get a usable string, used as event postfix\r\n\t * @param {Const} state\r\n\t * @returns {String} state\r\n\t */\r\n\tfunction stateStr(state) {\r\n\t    if (state & STATE_CANCELLED) {\r\n\t        return 'cancel';\r\n\t    } else if (state & STATE_ENDED) {\r\n\t        return 'end';\r\n\t    } else if (state & STATE_CHANGED) {\r\n\t        return 'move';\r\n\t    } else if (state & STATE_BEGAN) {\r\n\t        return 'start';\r\n\t    }\r\n\t    return '';\r\n\t}\r\n\t\r\n\t/**\r\n\t * direction cons to string\r\n\t * @param {Const} direction\r\n\t * @returns {String}\r\n\t */\r\n\tfunction directionStr(direction) {\r\n\t    if (direction == DIRECTION_DOWN) {\r\n\t        return 'down';\r\n\t    } else if (direction == DIRECTION_UP) {\r\n\t        return 'up';\r\n\t    } else if (direction == DIRECTION_LEFT) {\r\n\t        return 'left';\r\n\t    } else if (direction == DIRECTION_RIGHT) {\r\n\t        return 'right';\r\n\t    }\r\n\t    return '';\r\n\t}\r\n\t\r\n\t/**\r\n\t * get a recognizer by name if it is bound to a manager\r\n\t * @param {Recognizer|String} otherRecognizer\r\n\t * @param {Recognizer} recognizer\r\n\t * @returns {Recognizer}\r\n\t */\r\n\tfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\r\n\t    var manager = recognizer.manager;\r\n\t    if (manager) {\r\n\t        return manager.get(otherRecognizer);\r\n\t    }\r\n\t    return otherRecognizer;\r\n\t}\r\n\t\r\n\t/**\r\n\t * This recognizer is just used as a base for the simple attribute recognizers.\r\n\t * @constructor\r\n\t * @extends Recognizer\r\n\t */\r\n\tfunction AttrRecognizer() {\r\n\t    Recognizer.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(AttrRecognizer, Recognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof AttrRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        /**\r\n\t         * @type {Number}\r\n\t         * @default 1\r\n\t         */\r\n\t        pointers: 1\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Used to check if it the recognizer receives valid input, like input.distance > 10.\r\n\t     * @memberof AttrRecognizer\r\n\t     * @param {Object} input\r\n\t     * @returns {Boolean} recognized\r\n\t     */\r\n\t    attrTest: function(input) {\r\n\t        var optionPointers = this.options.pointers;\r\n\t        return optionPointers === 0 || input.pointers.length === optionPointers;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Process the input and return the state for the recognizer\r\n\t     * @memberof AttrRecognizer\r\n\t     * @param {Object} input\r\n\t     * @returns {*} State\r\n\t     */\r\n\t    process: function(input) {\r\n\t        var state = this.state;\r\n\t        var eventType = input.eventType;\r\n\t\r\n\t        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\r\n\t        var isValid = this.attrTest(input);\r\n\t\r\n\t        // on cancel input and we've recognized before, return STATE_CANCELLED\r\n\t        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\r\n\t            return state | STATE_CANCELLED;\r\n\t        } else if (isRecognized || isValid) {\r\n\t            if (eventType & INPUT_END) {\r\n\t                return state | STATE_ENDED;\r\n\t            } else if (!(state & STATE_BEGAN)) {\r\n\t                return STATE_BEGAN;\r\n\t            }\r\n\t            return state | STATE_CHANGED;\r\n\t        }\r\n\t        return STATE_FAILED;\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Pan\r\n\t * Recognized when the pointer is down and moved in the allowed direction.\r\n\t * @constructor\r\n\t * @extends AttrRecognizer\r\n\t */\r\n\tfunction PanRecognizer() {\r\n\t    AttrRecognizer.apply(this, arguments);\r\n\t\r\n\t    this.pX = null;\r\n\t    this.pY = null;\r\n\t}\r\n\t\r\n\tinherit(PanRecognizer, AttrRecognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof PanRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        event: 'pan',\r\n\t        threshold: 10,\r\n\t        pointers: 1,\r\n\t        direction: DIRECTION_ALL\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        var direction = this.options.direction;\r\n\t\r\n\t        if (direction === DIRECTION_ALL) {\r\n\t            return [TOUCH_ACTION_NONE];\r\n\t        }\r\n\t\r\n\t        var actions = [];\r\n\t        if (direction & DIRECTION_HORIZONTAL) {\r\n\t            actions.push(TOUCH_ACTION_PAN_Y);\r\n\t        }\r\n\t        if (direction & DIRECTION_VERTICAL) {\r\n\t            actions.push(TOUCH_ACTION_PAN_X);\r\n\t        }\r\n\t        return actions;\r\n\t    },\r\n\t\r\n\t    directionTest: function(input) {\r\n\t        var options = this.options;\r\n\t        var hasMoved = true;\r\n\t        var distance = input.distance;\r\n\t        var direction = input.direction;\r\n\t        var x = input.deltaX;\r\n\t        var y = input.deltaY;\r\n\t\r\n\t\r\n\t\r\n\t        // lock to axis?\r\n\t        if (!(direction & options.direction)) {\r\n\t            if (options.direction & DIRECTION_HORIZONTAL) {\r\n\t                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n\t                hasMoved = x != this.pX;\r\n\t                distance = Math.abs(input.deltaX);\r\n\t            } else {\r\n\t                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\r\n\t                hasMoved = y != this.pY;\r\n\t                distance = Math.abs(input.deltaY);\r\n\t            }\r\n\t        }\r\n\t        input.direction = direction;\r\n\t        return hasMoved && distance > options.threshold && direction & options.direction;\r\n\t    },\r\n\t\r\n\t    attrTest: function(input) {\r\n\t        return AttrRecognizer.prototype.attrTest.call(this, input) &&\r\n\t            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\r\n\t    },\r\n\t\r\n\t    emit: function(input) {\r\n\t        this.pX = input.deltaX;\r\n\t        this.pY = input.deltaY;\r\n\t\r\n\t        this._super.emit.call(this, input);\r\n\t\r\n\t        var direction = directionStr(input.direction);\r\n\t        if (direction) {\r\n\t            this.manager.emit(this.options.event + direction, input);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Pinch\r\n\t * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\r\n\t * @constructor\r\n\t * @extends AttrRecognizer\r\n\t */\r\n\tfunction PinchRecognizer() {\r\n\t    AttrRecognizer.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(PinchRecognizer, AttrRecognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof PinchRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        event: 'pinch',\r\n\t        threshold: 0,\r\n\t        pointers: 2\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return [TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y];\r\n\t    },\r\n\t\r\n\t    attrTest: function(input) {\r\n\t        return this._super.attrTest.call(this, input) &&\r\n\t            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\r\n\t    },\r\n\t\r\n\t    emit: function(input) {\r\n\t        this._super.emit.call(this, input);\r\n\t        if (input.scale !== 1) {\r\n\t            var inOut = input.scale < 1 ? 'in' : 'out';\r\n\t            this.manager.emit(this.options.event + inOut, input);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Press\r\n\t * Recognized when the pointer is down for x ms without any movement.\r\n\t * @constructor\r\n\t * @extends Recognizer\r\n\t */\r\n\tfunction PressRecognizer() {\r\n\t    Recognizer.apply(this, arguments);\r\n\t\r\n\t    this._timer = null;\r\n\t    this._input = null;\r\n\t}\r\n\t\r\n\tinherit(PressRecognizer, Recognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof PressRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        event: 'press',\r\n\t        pointers: 1,\r\n\t        time: 500, // minimal time of the pointer to be pressed\r\n\t        threshold: 5 // a minimal movement is ok, but keep it low\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return [TOUCH_ACTION_AUTO];\r\n\t    },\r\n\t\r\n\t    process: function(input) {\r\n\t        var options = this.options;\r\n\t\r\n\t        var validPointers = input.pointers.length === options.pointers;\r\n\t        var validMovement = input.distance < options.threshold;\r\n\t        var validTime = input.deltaTime > options.time;\r\n\t\r\n\t        this._input = input;\r\n\t\r\n\t        // we only allow little movement\r\n\t        // and we've reached an end event, so a tap is possible\r\n\t        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\r\n\t            this.reset();\r\n\t        } else if (input.eventType & INPUT_START) {\r\n\t            this.reset();\r\n\t            var self = this;\r\n\t            this._timer = setTimeout(function() {\r\n\t                self.state = STATE_RECOGNIZED;\r\n\t                self.tryEmit();\r\n\t            }, options.time);\r\n\t        }\r\n\t        return STATE_FAILED;\r\n\t    },\r\n\t\r\n\t    reset: function() {\r\n\t        clearTimeout(this._timer);\r\n\t        this._timer = null;\r\n\t    },\r\n\t\r\n\t    emit: function() {\r\n\t        if (this.state === STATE_RECOGNIZED) {\r\n\t            this._input.timeStamp = Date.now();\r\n\t            this.manager.emit(this.options.event, this._input);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Rotate\r\n\t * Recognized when two or more pointer are moving in a circular motion.\r\n\t * @constructor\r\n\t * @extends AttrRecognizer\r\n\t */\r\n\tfunction RotateRecognizer() {\r\n\t    AttrRecognizer.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(RotateRecognizer, AttrRecognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof RotateRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        event: 'rotate',\r\n\t        threshold: 0,\r\n\t        pointers: 2\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return [TOUCH_ACTION_NONE];\r\n\t    },\r\n\t\r\n\t    attrTest: function(input) {\r\n\t        return this._super.attrTest.call(this, input) &&\r\n\t            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Swipe\r\n\t * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\r\n\t * @constructor\r\n\t * @extends AttrRecognizer\r\n\t */\r\n\tfunction SwipeRecognizer() {\r\n\t    AttrRecognizer.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(SwipeRecognizer, AttrRecognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof SwipeRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        event: 'swipe',\r\n\t        threshold: 10,\r\n\t        velocity: 0.65,\r\n\t        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\r\n\t        pointers: 1\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return PanRecognizer.prototype.getTouchAction.call(this);\r\n\t    },\r\n\t\r\n\t    attrTest: function(input) {\r\n\t        var direction = this.options.direction;\r\n\t        var velocity;\r\n\t\r\n\t        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\r\n\t            velocity = input.velocity;\r\n\t        } else if (direction & DIRECTION_HORIZONTAL) {\r\n\t            velocity = input.velocityX;\r\n\t        } else if (direction & DIRECTION_VERTICAL) {\r\n\t            velocity = input.velocityY;\r\n\t        }\r\n\t\r\n\t        return this._super.attrTest.call(this, input) &&\r\n\t            direction & input.direction &&\r\n\t            velocity > this.options.velocity && input.eventType & INPUT_END;\r\n\t    },\r\n\t\r\n\t    emit: function(input) {\r\n\t        this.manager.emit(this.options.event, input);\r\n\t\r\n\t        var direction = directionStr(input.direction);\r\n\t        if (direction) {\r\n\t            this.manager.emit(this.options.event + direction, input);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\r\n\t * between the given interval and position. The delay option can be used to recognize multi-taps without firing\r\n\t * a single tap.\r\n\t *\r\n\t * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\r\n\t * multi-taps being recognized.\r\n\t * @constructor\r\n\t * @extends Recognizer\r\n\t */\r\n\tfunction TapRecognizer() {\r\n\t    Recognizer.apply(this, arguments);\r\n\t\r\n\t    // previous time and center,\r\n\t    // used for tap counting\r\n\t    this.pTime = false;\r\n\t    this.pCenter = false;\r\n\t\r\n\t    this._timer = null;\r\n\t    this._input = null;\r\n\t    this.count = 0;\r\n\t}\r\n\t\r\n\tinherit(TapRecognizer, Recognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof PinchRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        event: 'tap',\r\n\t        pointers: 1,\r\n\t        taps: 1,\r\n\t        delay: 300,\r\n\t        interval: 300, // max time between the multi-tap taps\r\n\t        time: 250, // max time of the pointer to be down (like finger on the screen)\r\n\t        threshold: 2, // a minimal movement is ok, but keep it low\r\n\t        posThreshold: 10 // a multi-tap can be a bit off the initial position\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return [TOUCH_ACTION_MANIPULATION];\r\n\t    },\r\n\t\r\n\t    process: function(input) {\r\n\t        var self = this;\r\n\t        var options = this.options;\r\n\t\r\n\t        var validPointers = input.pointers.length === options.pointers;\r\n\t        var validMovement = input.distance < options.threshold;\r\n\t        var validTouchTime = input.deltaTime < options.time;\r\n\t\r\n\t        this.reset();\r\n\t\r\n\t        if ((input.eventType & INPUT_START) && (this.count === 0)) {\r\n\t            return this._setupBeganState();\r\n\t        }\r\n\t\r\n\t        // we only allow little movement\r\n\t        // and we've reached an end event, so a tap is possible\r\n\t        if (validMovement && validTouchTime && validPointers) {\r\n\t            if (input.eventType & INPUT_END) {\r\n\t                var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\r\n\t                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\r\n\t\r\n\t                this.pTime = input.timeStamp;\r\n\t                this.pCenter = input.center;\r\n\t\r\n\t                if (!validMultiTap || !validInterval) {\r\n\t                    this.count = 1;\r\n\t                } else {\r\n\t                    this.count += 1;\r\n\t                }\r\n\t\r\n\t                this._input = input;\r\n\t\r\n\t                // if tap count matches we have recognized it,\r\n\t                // else it has began recognizing...\r\n\t                var tapCount = this.count % options.taps;\r\n\t                if (tapCount === 0) {\r\n\t                    if (!this.hasRequireFailures()) {\r\n\t                        return STATE_RECOGNIZED;\r\n\t                    } else {\r\n\t                        this._timer = setTimeout(function() {\r\n\t                            self.state = STATE_RECOGNIZED;\r\n\t                            self.tryEmit();\r\n\t                        }, options.delay);\r\n\t                        return STATE_BEGAN;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t\r\n\t            return this._setupBeganState();\r\n\t        }\r\n\t        return STATE_FAILED;\r\n\t    },\r\n\t\r\n\t    _setupBeganState: function() {\r\n\t        var self = this;\r\n\t        this._timer = setTimeout(function() {\r\n\t            self.state = STATE_FAILED;\r\n\t        }, this.options.delay);\r\n\t\r\n\t        return STATE_FAILED;\r\n\t    },\r\n\t\r\n\t    reset: function() {\r\n\t        clearTimeout(this._timer);\r\n\t    },\r\n\t\r\n\t    emit: function() {\r\n\t        if (this.state == STATE_RECOGNIZED ) {\r\n\t            this._input.tapCount = this.count;\r\n\t            this.manager.emit(this.options.event, this._input);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Simple way to create an manager with a default set of recognizers.\r\n\t * @param {HTMLElement} element\r\n\t * @param {Object} [options]\r\n\t * @constructor\r\n\t */\r\n\tfunction Hammer(element, options) {\r\n\t    options = options || {};\r\n\t    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.easyRecognizers);\r\n\t    return new Manager(element, options);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Current build version.\r\n\t * @const {string}\r\n\t */\r\n\tHammer.VERSION = '2.0.0dev';\r\n\t\r\n\t/**\r\n\t * default settings\r\n\t * @namespace\r\n\t */\r\n\tHammer.defaults = {\r\n\t    /**\r\n\t     * set if DOM events are being triggered.\r\n\t     * But this is slower and unused by simple implementations, so disabled by default.\r\n\t     * @type {Boolean}\r\n\t     * @default false\r\n\t     */\r\n\t    domEvents: false,\r\n\t\r\n\t    /**\r\n\t     * The value for the touchAction property/fallback.\r\n\t     * When set to `compute` it will magically set the correct value based on the added recognizers.\r\n\t     * @type {String}\r\n\t     * @default compute\r\n\t     */\r\n\t    touchAction: TOUCH_ACTION_COMPUTE,\r\n\t\r\n\t    /**\r\n\t     * @type {Boolean}\r\n\t     * @default true\r\n\t     */\r\n\t    enable: true,\r\n\t\r\n\t    /**\r\n\t     * Default recognizer setup when calling `Hammer()`\r\n\t     * When creating a new Manager these will be skipped.\r\n\t     * @type {Array}\r\n\t     */\r\n\t    easyRecognizers: [\r\n\t        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\r\n\t        [RotateRecognizer, { enable: false }],\r\n\t        [PinchRecognizer, { enable: false }, ['rotate']],\r\n\t        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],\r\n\t        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\r\n\t        [TapRecognizer],\r\n\t        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\r\n\t        [PressRecognizer]\r\n\t    ],\r\n\t\r\n\t    /**\r\n\t     * Some CSS properties can be used to improve the working of Hammer.\r\n\t     * Add them to this method and they will be set when creating a new Manager.\r\n\t     * @namespace\r\n\t     */\r\n\t    cssProps: {\r\n\t        /**\r\n\t         * Disables text selection to improve the dragging gesture. When the value is `none` it also sets\r\n\t         * `onselectstart=false` for IE9 on the element. Mainly for desktop browsers.\r\n\t         * @type {String}\r\n\t         * @default 'none'\r\n\t         */\r\n\t        userSelect: 'none',\r\n\t\r\n\t        /**\r\n\t         * Disable the Windows Phone grippers when pressing an element.\r\n\t         * @type {String}\r\n\t         * @default 'none'\r\n\t         */\r\n\t        touchSelect: 'none',\r\n\t\r\n\t        /**\r\n\t         * Disables the default callout shown when you touch and hold a touch target.\r\n\t         * On iOS, when you touch and hold a touch target such as a link, Safari displays\r\n\t         * a callout containing information about the link. This property allows you to disable that callout.\r\n\t         * @type {String}\r\n\t         * @default 'none'\r\n\t         */\r\n\t        touchCallout: 'none',\r\n\t\r\n\t        /**\r\n\t         * Specifies whether zooming is enabled. Used by IE10>\r\n\t         * @type {String}\r\n\t         * @default 'none'\r\n\t         */\r\n\t        contentZooming: 'none',\r\n\t\r\n\t        /**\r\n\t         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\r\n\t         * @type {String}\r\n\t         * @default 'none'\r\n\t         */\r\n\t        userDrag: 'none',\r\n\t\r\n\t        /**\r\n\t         * Overrides the highlight color shown when the user taps a link or a JavaScript\r\n\t         * clickable element in iOS. This property obeys the alpha value, if specified.\r\n\t         * @type {String}\r\n\t         * @default 'rgba(0,0,0,0)'\r\n\t         */\r\n\t        tapHighlightColor: 'rgba(0,0,0,0)'\r\n\t    }\r\n\t};\r\n\t\r\n\tvar STOP = 1;\r\n\tvar FORCED_STOP = 2;\r\n\t\r\n\t/**\r\n\t * Manager\r\n\t * @param {HTMLElement} element\r\n\t * @param {Object} [options]\r\n\t * @constructor\r\n\t */\r\n\tfunction Manager(element, options) {\r\n\t    options = options || {};\r\n\t\r\n\t    this.options = merge(options, Hammer.defaults);\r\n\t\r\n\t    this.handlers = {};\r\n\t    this.session = {};\r\n\t    this.recognizers = [];\r\n\t\r\n\t    this.element = element;\r\n\t    this.input = createInputInstance(this);\r\n\t    this.touchAction = new TouchAction(this, this.options.touchAction);\r\n\t\r\n\t    toggleCssProps(this, true);\r\n\t\r\n\t    each(options.recognizers, function(item) {\r\n\t        var recognizer = this.add(new (item[0])(item[1]));\r\n\t        item[2] && each(item[2], recognizer.recognizeWith, recognizer);\r\n\t        item[3] && each(item[3], recognizer.requireFailure, recognizer);\r\n\t    }, this);\r\n\t}\r\n\t\r\n\tManager.prototype = {\r\n\t    /**\r\n\t     * set options\r\n\t     * @param {String} option\r\n\t     * @param {*} val\r\n\t     */\r\n\t    set: function(option, val) {\r\n\t        this.options[option] = val;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * stop recognizing for this session.\r\n\t     * This session will be discarded, when a new [input]start event is fired.\r\n\t     * When forced, the recognizer cycle is stopped immediately.\r\n\t     * @param {Boolean} [force]\r\n\t     */\r\n\t    stop: function(force) {\r\n\t        this.session.stopped = force ? FORCED_STOP : STOP;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * run the recognizers!\r\n\t     * called by the inputHandler function on every movement of the pointers (touches)\r\n\t     * it walks through all the recognizers and tries to detect the gesture that is being made\r\n\t     * @param {Object} inputData\r\n\t     */\r\n\t    recognize: function(inputData) {\r\n\t        if (this.session.stopped) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        // run the touch-action polyfill\r\n\t        this.touchAction.preventDefaults(inputData);\r\n\t\r\n\t        var recognizer;\r\n\t        var session = this.session;\r\n\t\r\n\t        // this holds the recognizer that is being recognized.\r\n\t        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\r\n\t        // if no recognizer is detecting a thing, it is set to `null`\r\n\t        var curRecognizer = session.curRecognizer;\r\n\t\r\n\t        // reset when the last recognizer is recognized\r\n\t        // or when we're in a new session\r\n\t        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\r\n\t            curRecognizer = session.curRecognizer = null;\r\n\t        }\r\n\t\r\n\t        for (var i = 0, len = this.recognizers.length; i < len; i++) {\r\n\t            recognizer = this.recognizers[i];\r\n\t\r\n\t            // find out if we are allowed try to recognize the input for this one.\r\n\t            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\r\n\t            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\r\n\t            //      that is being recognized.\r\n\t            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\r\n\t            //      this can be setup with the `recognizeWith()` method on the recognizer.\r\n\t            if (this.session.stopped !== FORCED_STOP && ( // 1\r\n\t                    !curRecognizer || recognizer == curRecognizer || // 2\r\n\t                    recognizer.canRecognizeWith(curRecognizer))) { // 3\r\n\t                recognizer.recognize(inputData);\r\n\t            } else {\r\n\t                recognizer.reset();\r\n\t            }\r\n\t\r\n\t            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\r\n\t            // current active recognizer. but only if we don't already have an active recognizer\r\n\t            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\r\n\t                curRecognizer = session.curRecognizer = recognizer;\r\n\t            }\r\n\t        }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * get a recognizer by its event name.\r\n\t     * @param {Recognizer|String} recognizer\r\n\t     * @returns {Recognizer|Null}\r\n\t     */\r\n\t    get: function(recognizer) {\r\n\t        if (recognizer instanceof Recognizer) {\r\n\t            return recognizer;\r\n\t        }\r\n\t\r\n\t        var recognizers = this.recognizers;\r\n\t        for (var i = 0; i < recognizers.length; i++) {\r\n\t            if (recognizers[i].options.event == recognizer) {\r\n\t                return recognizers[i];\r\n\t            }\r\n\t        }\r\n\t        return null;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * add a recognizer to the manager\r\n\t     * existing recognizers with the same event name will be removed\r\n\t     * @param {Recognizer} recognizer\r\n\t     * @returns {Recognizer}\r\n\t     */\r\n\t    add: function(recognizer) {\r\n\t        // remove existing\r\n\t        var existing = this.get(recognizer.options.event);\r\n\t        if (existing) {\r\n\t            this.remove(existing);\r\n\t        }\r\n\t\r\n\t        this.recognizers.push(recognizer);\r\n\t        recognizer.manager = this;\r\n\t\r\n\t        this.touchAction.update();\r\n\t        return recognizer;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * remove a recognizer by name or instance\r\n\t     * @param {Recognizer|String} recognizer\r\n\t     */\r\n\t    remove: function(recognizer) {\r\n\t        var recognizers = this.recognizers;\r\n\t        recognizer = this.get(recognizer);\r\n\t        recognizers.splice(inArray(recognizers, recognizer), 1);\r\n\t\r\n\t        this.touchAction.update();\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * bind event\r\n\t     * @param {String} events\r\n\t     * @param {Function} handler\r\n\t     * @returns {EventEmitter} this\r\n\t     */\r\n\t    on: function(events, handler) {\r\n\t        var handlers = this.handlers;\r\n\t        each(splitStr(events), function(event) {\r\n\t            handlers[event] = handlers[event] || [];\r\n\t            handlers[event].push(handler);\r\n\t        });\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * unbind event, leave emit blank to remove all handlers\r\n\t     * @param {String} events\r\n\t     * @param {Function} [handler]\r\n\t     * @returns {EventEmitter} this\r\n\t     */\r\n\t    off: function(events, handler) {\r\n\t        var handlers = this.handlers;\r\n\t        each(splitStr(events), function(event) {\r\n\t            if (!handler) {\r\n\t                delete handlers[event];\r\n\t            } else {\r\n\t                handlers[event].splice(inArray(handlers[event], handler), 1);\r\n\t            }\r\n\t        });\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * emit event to the listeners\r\n\t     * @param {String} event\r\n\t     * @param {Object} data\r\n\t     */\r\n\t    emit: function(event, data) {\r\n\t        // we also want to trigger dom events\r\n\t        if (this.options.domEvents) {\r\n\t            triggerDomEvent(event, data);\r\n\t        }\r\n\t\r\n\t        // no handlers, so skip it all\r\n\t        var handlers = this.handlers[event];\r\n\t        if (!handlers || !handlers.length) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        data.type = event;\r\n\t        data.preventDefault = function() {\r\n\t            data.srcEvent.preventDefault();\r\n\t        };\r\n\t\r\n\t        for (var i = 0, len = handlers.length; i < len; i++) {\r\n\t            handlers[i](data);\r\n\t        }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * destroy the manager and unbinds all events\r\n\t     * it doesn't unbind dom events, that is the user own responsibility\r\n\t     */\r\n\t    destroy: function() {\r\n\t        if (this.element) {\r\n\t            toggleCssProps(this, false);\r\n\t        }\r\n\t\r\n\t        this.handlers = {};\r\n\t        this.session = {};\r\n\t        this.input.destroy();\r\n\t        this.element = null;\r\n\t    }\r\n\t};\r\n\t\r\n\t/**\r\n\t * add/remove the css properties as defined in manager.options.cssProps\r\n\t * @param {Manager} manager\r\n\t * @param {Boolean} add\r\n\t */\r\n\tfunction toggleCssProps(manager, add) {\r\n\t    var element = manager.element;\r\n\t    var cssProps = manager.options.cssProps;\r\n\t\r\n\t    each(cssProps, function(value, name) {\r\n\t        element.style[prefixed(element.style, name)] = add ? value : '';\r\n\t    });\r\n\t\r\n\t    var falseFn = add && function() { return false; };\r\n\t    if (cssProps.userSelect == 'none') { element.onselectstart = falseFn; }\r\n\t    if (cssProps.userDrag == 'none') { element.ondragstart = falseFn; }\r\n\t}\r\n\t\r\n\t/**\r\n\t * trigger dom event\r\n\t * @param {String} event\r\n\t * @param {Object} data\r\n\t */\r\n\tfunction triggerDomEvent(event, data) {\r\n\t    var gestureEvent = document.createEvent('Event');\r\n\t    gestureEvent.initEvent(event, true, true);\r\n\t    gestureEvent.gesture = data;\r\n\t    data.target.dispatchEvent(gestureEvent);\r\n\t}\r\n\t\r\n\textend(Hammer, {\r\n\t    INPUT_START: INPUT_START,\r\n\t    INPUT_MOVE: INPUT_MOVE,\r\n\t    INPUT_END: INPUT_END,\r\n\t    INPUT_CANCEL: INPUT_CANCEL,\r\n\t\r\n\t    STATE_POSSIBLE: STATE_POSSIBLE,\r\n\t    STATE_BEGAN: STATE_BEGAN,\r\n\t    STATE_CHANGED: STATE_CHANGED,\r\n\t    STATE_ENDED: STATE_ENDED,\r\n\t    STATE_RECOGNIZED: STATE_RECOGNIZED,\r\n\t    STATE_CANCELLED: STATE_CANCELLED,\r\n\t    STATE_FAILED: STATE_FAILED,\r\n\t\r\n\t    DIRECTION_NONE: DIRECTION_NONE,\r\n\t    DIRECTION_LEFT: DIRECTION_LEFT,\r\n\t    DIRECTION_RIGHT: DIRECTION_RIGHT,\r\n\t    DIRECTION_UP: DIRECTION_UP,\r\n\t    DIRECTION_DOWN: DIRECTION_DOWN,\r\n\t    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\r\n\t    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\r\n\t    DIRECTION_ALL: DIRECTION_ALL,\r\n\t\r\n\t    Manager: Manager,\r\n\t    Input: Input,\r\n\t    TouchAction: TouchAction,\r\n\t\r\n\t    Recognizer: Recognizer,\r\n\t    AttrRecognizer: AttrRecognizer,\r\n\t    Tap: TapRecognizer,\r\n\t    Pan: PanRecognizer,\r\n\t    Swipe: SwipeRecognizer,\r\n\t    Pinch: PinchRecognizer,\r\n\t    Rotate: RotateRecognizer,\r\n\t    Press: PressRecognizer,\r\n\t\r\n\t    on: addEventListeners,\r\n\t    off: removeEventListeners,\r\n\t    each: each,\r\n\t    merge: merge,\r\n\t    extend: extend,\r\n\t    inherit: inherit,\r\n\t    bindFn: bindFn,\r\n\t    prefixed: prefixed\r\n\t});\r\n\t\r\n\tif ('function' == TYPE_FUNCTION && __webpack_require__(4)) {\r\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\r\n\t        return Hammer;\r\n\t    }.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t} else if (typeof module != TYPE_UNDEFINED && module.exports) {\r\n\t    module.exports = Hammer;\r\n\t} else {\r\n\t    window.Hammer = Hammer;\r\n\t}\r\n\t\r\n\t})(window);\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ }\n/******/ ])"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/assets/js/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);","require('./trackers.js');\r\nrequire('./demo.js');\r\n","!function (d, s, id) {\r\n    var js, fjs = d.getElementsByTagName(s)[0];\r\n    if (!d.getElementById(id)) {\r\n        js = d.createElement(s);\r\n        js.id = id;\r\n        js.src = \"//platform.twitter.com/widgets.js\";\r\n        fjs.parentNode.insertBefore(js, fjs);\r\n    }\r\n}(document, \"script\", \"twitter-wjs\");\r\n\r\nif(location.href.indexOf(\"eightmedia.github.io\") > -1) {\r\n    var _gaq = _gaq || [];\r\n    _gaq.push(['_setAccount', 'UA-30289566-1']);\r\n    _gaq.push(['_trackPageview']);\r\n    (function () {\r\n        var ga = document.createElement('script');\r\n        ga.type = 'text/javascript';\r\n        ga.async = true;\r\n        ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';\r\n        var s = document.getElementsByTagName('script')[0];\r\n        s.parentNode.insertBefore(ga, s);\r\n    })();\r\n}\r\n","var Hammer = require('../../../node_modules/hammerjs/hammer.js');\r\n\r\n// polyfill\r\nvar reqAnimationFrame = (function () {\r\n    return window[Hammer.prefixed(window, 'requestAnimationFrame')] || function (callback) {\r\n        window.setTimeout(callback, 1000 / 60);\r\n    };\r\n})();\r\n\r\nvar el = document.querySelector(\"#hitarea\");\r\n\r\nvar startX = Math.round((el.parentNode.offsetWidth - el.offsetWidth) / 2);\r\nvar startY = Math.round((el.parentNode.offsetHeight - el.offsetHeight) / 2);\r\n\r\nvar ticking = false;\r\nvar transform;\r\n\r\nvar mc = new Hammer(el);\r\n\r\nmc.get('pinch').set('enable', true);\r\nmc.get('rotate').set('enable', true);\r\n\r\nmc.on(\"pan\", onPan);\r\nmc.on(\"swipe\", onSwipe);\r\nmc.on(\"rotate\", onRotate);\r\nmc.on(\"pinch\", onPinch);\r\nmc.on(\"tap\", onTap);\r\nmc.on(\"doubletap\", onDoubleTap);\r\nmc.on(\"hold\", onHold);\r\n\r\nmc.on(\"panstart rotatestart pinchstart\", resetElementStart);\r\nmc.on(\"panend rotateend pinchend pancancel rotatecancel pinchcancel\", resetElementEnd);\r\n\r\nfunction resetElementStart() {\r\n    el.className = '';\r\n}\r\n\r\nfunction resetElementEnd() {\r\n    transform = {\r\n        translate: { x: startX, y: startY },\r\n        scale: 1,\r\n        rotate: 0\r\n    };\r\n    el.className = 'animate';\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction updateElementTransform() {\r\n    var value = [\r\n        'translate3d(' + transform.translate.x + 'px, ' + transform.translate.y + 'px, 0)',\r\n        'scale(' + transform.scale + ', ' + transform.scale + ')',\r\n        'rotate(' + transform.rotate + 'deg)'];\r\n    el.style.webkitTransform = el.style.transform = value.join(\" \");\r\n    ticking = false;\r\n}\r\n\r\nfunction requestElementUpdate() {\r\n    if(!ticking) {\r\n        ticking = true;\r\n        reqAnimationFrame(updateElementTransform);\r\n    }\r\n}\r\n\r\nfunction onPan(ev) {\r\n    transform.translate = {\r\n        x: startX + ev.deltaX,\r\n        y: startY + ev.deltaY\r\n    };\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction onSwipe(ev) {\r\n    transform.translate = {\r\n        x: startX + (ev.deltaX * 1.2),\r\n        y: startY + (ev.deltaY * 1.2)\r\n    };\r\n    transform.scale = 1.2;\r\n    requestElementUpdate();\r\n\r\n    setTimeout(function () {\r\n        resetElementEnd();\r\n    }, 400);\r\n}\r\n\r\nfunction onPinch(ev) {\r\n    transform.scale = ev.scale;\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction onRotate(ev) {\r\n    transform.rotate = ev.rotation;\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction onTap(ev) {\r\n    transform.scale = .9;\r\n    requestElementUpdate();\r\n\r\n    setTimeout(function () {\r\n        transform.scale = 1;\r\n        requestElementUpdate();\r\n    }, 200);\r\n}\r\n\r\nfunction onDoubleTap(ev) {\r\n    transform.rotate = !transform.rotate ? 360 : 0;\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction onHold(ev) {\r\n    el.style.background = '#fd0';\r\n    setTimeout(function () {\r\n        el.style.background = 'white';\r\n        requestElementUpdate();\r\n    }, 500);\r\n}\r\n\r\nresetElementEnd();\r\n\r\ndocument.querySelector(\".device-button\").addEventListener(\"click\", function(){\r\n    document.querySelector(\".device\").classList.toggle('hammertime');\r\n}, false);\r\n","(function(window, undefined) {\r\n  'use strict';\r\n\r\nvar VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];\r\n\r\nvar TYPE_FUNCTION = 'function';\r\nvar TYPE_UNDEFINED = 'undefined';\r\n\r\n/**\r\n * walk objects and arrays\r\n * @param {Object} obj\r\n * @param {Function} iterator\r\n * @param {Object} context\r\n */\r\nfunction each(obj, iterator, context) {\r\n    var i, len;\r\n\r\n    if (!obj) {\r\n        return;\r\n    }\r\n\r\n    if (obj.forEach) {\r\n        obj.forEach(iterator, context);\r\n    } else if (obj.length !== undefined) {\r\n        for (i = 0, len = obj.length; i < len; i++) {\r\n            iterator.call(context, obj[i], i, obj);\r\n        }\r\n    } else {\r\n        for (i in obj) {\r\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * extend object.\r\n * means that properties in dest will be overwritten by the ones in src.\r\n * @param {Object} dest\r\n * @param {Object} src\r\n * @param {Boolean} [merge]\r\n * @returns {Object} dest\r\n */\r\nfunction extend(dest, src, merge) {\r\n    var keys = Object.keys(src);\r\n    for (var i = 0, len = keys.length; i < len; i++) {\r\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\r\n            dest[keys[i]] = src[keys[i]];\r\n        }\r\n    }\r\n    return dest;\r\n}\r\n\r\n/**\r\n * merge the values from src in the dest.\r\n * means that properties that exist in dest will not be overwritten by src\r\n * @param {Object} dest\r\n * @param {Object} src\r\n * @returns {Object} dest\r\n */\r\nfunction merge(dest, src) {\r\n    return extend(dest, src, true);\r\n}\r\n\r\n/**\r\n * simple class inheritance\r\n * @param {Function} child\r\n * @param {Function} base\r\n * @param {Object} [properties]\r\n */\r\nfunction inherit(child, base, properties) {\r\n    var baseP = base.prototype,\r\n        childP;\r\n\r\n    // object create is supported since IE9\r\n    if (Object.create) {\r\n        childP = child.prototype = Object.create(baseP);\r\n        childP.constructor = child;\r\n    } else {\r\n        extend(child, base);\r\n        var Inherited = function() {\r\n            this.constructor = child;\r\n        };\r\n        Inherited.prototype = baseP;\r\n        childP = child.prototype = new Inherited();\r\n    }\r\n\r\n    if (properties) {\r\n        extend(childP, properties);\r\n    }\r\n\r\n    childP._super = baseP;\r\n}\r\n\r\n/**\r\n * simple function bind\r\n * @param {Function} fn\r\n * @param {Object} context\r\n * @returns {Function}\r\n */\r\nfunction bindFn(fn, context) {\r\n    return function() {\r\n        return fn.apply(context, arguments);\r\n    };\r\n}\r\n\r\n/**\r\n * let a boolean value also be a function that must return a boolean\r\n * this first item in args will be used as the context\r\n * @param {Boolean|Function} val\r\n * @param {Array} [args]\r\n * @returns {Boolean}\r\n */\r\nfunction boolOrFn(val, args) {\r\n    if (typeof val == TYPE_FUNCTION) {\r\n        return val.apply(args ? args[0] || window : window, args);\r\n    }\r\n    return val;\r\n}\r\n\r\n/**\r\n * use the val2 when val1 is undefined\r\n * @param {*} val1\r\n * @param {*} val2\r\n * @returns {*}\r\n */\r\nfunction ifUndefined(val1, val2) {\r\n    return (val1 === undefined) ? val2 : val1;\r\n}\r\n\r\n/**\r\n * addEventListener with multiple events at once\r\n * @param {HTMLElement} element\r\n * @param {String} types\r\n * @param {Function} handler\r\n */\r\nfunction addEventListeners(element, types, handler) {\r\n    each(splitStr(types), function(type) {\r\n        element.addEventListener(type, handler, false);\r\n    });\r\n}\r\n\r\n/**\r\n * removeEventListener with multiple events at once\r\n * @param {HTMLElement} element\r\n * @param {String} types\r\n * @param {Function} handler\r\n */\r\nfunction removeEventListeners(element, types, handler) {\r\n    each(splitStr(types), function(type) {\r\n        element.removeEventListener(type, handler, false);\r\n    });\r\n}\r\n\r\n/**\r\n * find if a node is in the given parent\r\n * @method hasParent\r\n * @param {HTMLElement} node\r\n * @param {HTMLElement} parent\r\n * @return {Boolean} found\r\n */\r\nfunction hasParent(node, parent) {\r\n    while (node) {\r\n        if (node == parent) {\r\n            return true;\r\n        }\r\n        node = node.parentNode;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * store Math.round in a var, for better minimisation\r\n */\r\nvar round = Math.round;\r\n\r\n/**\r\n * small indexOf wrapper\r\n * @param {String} str\r\n * @param {String} find\r\n * @returns {Boolean} found\r\n */\r\nfunction inStr(str, find) {\r\n    return str.indexOf(find) > -1;\r\n}\r\n\r\n/**\r\n * split string on whitespace\r\n * @param {String} str\r\n * @returns {Array} words\r\n */\r\nfunction splitStr(str) {\r\n    return str.trim().split(/\\s+/g);\r\n}\r\n\r\n/**\r\n * find if a array contains the object using indexOf or a simple polyFill\r\n * @param {Array} src\r\n * @param {String} find\r\n * @param {String} [findByKey]\r\n * @return {Boolean|Number} false when not found, or the index\r\n */\r\nfunction inArray(src, find, findByKey) {\r\n    if (src.indexOf && !findByKey) {\r\n        return src.indexOf(find);\r\n    } else {\r\n        for (var i = 0, len = src.length; i < len; i++) {\r\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n\r\n/**\r\n * convert array-like objects to real arrays\r\n * @param {Object} obj\r\n * @returns {Array}\r\n */\r\nfunction toArray(obj) {\r\n    return Array.prototype.slice.call(obj, 0);\r\n}\r\n\r\n/**\r\n * unique array with objects based on a key (like 'id') or just by the array's value\r\n * @param {Array} src [{id:1},{id:2},{id:1}]\r\n * @param {String} [key]\r\n * @returns {Array} [{id:1},{id:2}]\r\n */\r\nfunction uniqueArray(src, key) {\r\n    var results = [];\r\n    var values = [];\r\n    for (var i = 0, len = src.length; i < len; i++) {\r\n        var val = key ? src[i][key] : src[i];\r\n        if (inArray(values, val) < 0) {\r\n            results.push(src[i]);\r\n        }\r\n        values[i] = val;\r\n    }\r\n    return results;\r\n}\r\n\r\n/**\r\n * get the prefixed property\r\n * @param {Object} obj\r\n * @param {String} property\r\n * @returns {String|Undefined} prefixed\r\n */\r\nfunction prefixed(obj, property) {\r\n    var prefix, prop;\r\n    var camelProp = property[0].toUpperCase() + property.slice(1);\r\n\r\n    for (var i = 0, len = VENDOR_PREFIXES.length; i < len; i++) {\r\n        prefix = VENDOR_PREFIXES[i];\r\n        prop = (prefix) ? prefix + camelProp : property;\r\n\r\n        if (prop in obj) {\r\n            return prop;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * get a unique id\r\n * @returns {number} uniqueId\r\n */\r\nvar _uniqueId = 1;\r\nfunction uniqueId() {\r\n    return _uniqueId++;\r\n}\r\n\r\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\r\n\r\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\r\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\r\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\r\n\r\nvar INPUT_TYPE_TOUCH = 'touch';\r\nvar INPUT_TYPE_PEN = 'pen';\r\nvar INPUT_TYPE_MOUSE = 'mouse';\r\nvar INPUT_TYPE_KINECT = 'kinect';\r\n\r\nvar COMPUTE_INTERVAL = 25;\r\n\r\nvar INPUT_START = 1;\r\nvar INPUT_MOVE = 2;\r\nvar INPUT_END = 4;\r\nvar INPUT_CANCEL = 8;\r\n\r\nvar DIRECTION_NONE = 1;\r\nvar DIRECTION_LEFT = 2;\r\nvar DIRECTION_RIGHT = 4;\r\nvar DIRECTION_UP = 8;\r\nvar DIRECTION_DOWN = 16;\r\n\r\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\r\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\r\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\r\n\r\nvar PROPS_XY = ['x', 'y'];\r\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\r\n\r\n/**\r\n * create new input type manager\r\n * @param {Manager} manager\r\n * @param {Function} callback\r\n * @returns {Input}\r\n * @constructor\r\n */\r\nfunction Input(manager, callback) {\r\n    var self = this;\r\n    this.manager = manager;\r\n    this.callback = callback;\r\n\r\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\r\n    // so when disabled the input events are completely bypassed.\r\n    this.domHandler = function(ev) {\r\n        if (boolOrFn(self.manager.options.enable, [self.manager])) {\r\n            self.handler(ev);\r\n        }\r\n    };\r\n\r\n    this.evEl && addEventListeners(this.manager.element, this.evEl, this.domHandler);\r\n    this.evWin && addEventListeners(window, this.evWin, this.domHandler);\r\n}\r\n\r\nInput.prototype = {\r\n    /**\r\n     * should handle the inputEvent data and trigger the callback\r\n     * @virtual\r\n     */\r\n    handler: function() { },\r\n\r\n    /**\r\n     * unbind the events\r\n     */\r\n    destroy: function() {\r\n        this.elEvents && removeEventListeners(this.manager.element, this.elEvents, this.domHandler);\r\n        this.winEvents && removeEventListeners(window, this.winEvents, this.domHandler);\r\n    }\r\n};\r\n\r\n/**\r\n * create new input type manager\r\n * @param {Hammer} manager\r\n * @returns {Input}\r\n */\r\nfunction createInputInstance(manager) {\r\n    var Type;\r\n    if (SUPPORT_POINTER_EVENTS) {\r\n        Type = PointerEventInput;\r\n    } else if (SUPPORT_ONLY_TOUCH) {\r\n        Type = TouchInput;\r\n    } else if (!SUPPORT_TOUCH) {\r\n        Type = MouseInput;\r\n    } else {\r\n        Type = TouchMouseInput;\r\n    }\r\n    return new (Type)(manager, inputHandler);\r\n}\r\n\r\n/**\r\n * handle input events\r\n * @param {Manager} manager\r\n * @param {String} eventType\r\n * @param {Object} input\r\n */\r\nfunction inputHandler(manager, eventType, input) {\r\n    var pointersLen = input.pointers.length;\r\n    var changedPointersLen = input.changedPointers.length;\r\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\r\n    var isFinal = (eventType & INPUT_END && (pointersLen - changedPointersLen === 0));\r\n\r\n    input.isFirst = isFirst;\r\n    input.isFinal = isFinal;\r\n\r\n    if (isFirst) {\r\n        manager.session = {};\r\n    }\r\n    // source event is the normalized value of the domEvents\r\n    // like 'touchstart, mouseup, pointerdown'\r\n    input.eventType = eventType;\r\n\r\n    // compute scale, rotation etc\r\n    computeInputData(manager, input);\r\n\r\n    manager.recognize(input);\r\n}\r\n\r\n/**\r\n * extend the data with some usable properties like scale, rotate, velocity etc\r\n * @param {Object} manager\r\n * @param {Object} input\r\n */\r\nfunction computeInputData(manager, input) {\r\n    var session = manager.session;\r\n    var pointers = input.pointers;\r\n    var pointersLength = pointers.length;\r\n\r\n    // store the first input to calculate the distance and direction\r\n    if (!session.firstInput) {\r\n        session.firstInput = simpleCloneInputData(input);\r\n    }\r\n\r\n    // to compute scale and rotation we need to store the multiple touches\r\n    if (pointersLength > 1 && !session.firstMultiple) {\r\n        session.firstMultiple = simpleCloneInputData(input);\r\n    } else if (pointersLength === 1) {\r\n        session.firstMultiple = false;\r\n    }\r\n\r\n    var firstInput = session.firstInput;\r\n    var firstMultiple = session.firstMultiple;\r\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\r\n    var center = getCenter(pointers);\r\n\r\n    input.timeStamp = Date.now();\r\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\r\n    input.deltaX = center.x - offsetCenter.x;\r\n    input.deltaY = center.y - offsetCenter.y;\r\n\r\n    input.center = center;\r\n    input.angle = getAngle(offsetCenter, center);\r\n    input.distance = getDistance(offsetCenter, center);\r\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\r\n\r\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\r\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\r\n\r\n    // find the correct target\r\n    var target = manager.element;\r\n    if (hasParent(input.srcEvent.target, target)) {\r\n        target = input.srcEvent.target;\r\n    }\r\n    input.target = target;\r\n\r\n    computeIntervalInputData(session, input);\r\n}\r\n\r\n/**\r\n * velocity is calculated every x ms\r\n * @param {Object} session\r\n * @param {Object} input\r\n */\r\nfunction computeIntervalInputData(session, input) {\r\n    var last = session.lastInterval;\r\n    if (!last) {\r\n        last = session.lastInterval = simpleCloneInputData(input);\r\n    }\r\n\r\n    var deltaTime = input.timeStamp - last.timeStamp,\r\n        velocity,\r\n        velocityX,\r\n        velocityY,\r\n        direction;\r\n\r\n    if (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined) {\r\n        var deltaX = last.deltaX - input.deltaX;\r\n        var deltaY = last.deltaY - input.deltaY;\r\n\r\n        var v = getVelocity(deltaTime, deltaX, deltaY);\r\n        velocityX = v.x;\r\n        velocityY = v.y;\r\n        velocity = Math.max(v.x, v.y);\r\n        direction = getDirection(deltaX, deltaY);\r\n    } else {\r\n        // use latest velocity info if it doesn't overtake a minimum period\r\n        velocity = last.velocity;\r\n        velocityX = last.velocityX;\r\n        velocityY = last.velocityY;\r\n        direction = last.direction;\r\n    }\r\n\r\n    input.velocity = velocity;\r\n    input.velocityX = velocityX;\r\n    input.velocityY = velocityY;\r\n    input.direction = direction;\r\n}\r\n\r\n/**\r\n * create a simple clone from the input used for storage of firstInput and firstMultiple\r\n * @param {Object} input\r\n * @returns {Object} clonedInputData\r\n */\r\nfunction simpleCloneInputData(input) {\r\n    // make a simple copy of the pointers because we will get a reference if we don't\r\n    // we only need clientXY for the calculations\r\n    var pointers = [];\r\n    for (var i = 0; i < input.pointers.length; i++) {\r\n        pointers[i] = {\r\n            clientX: round(input.pointers[i].clientX),\r\n            clientY: round(input.pointers[i].clientY)\r\n        };\r\n    }\r\n\r\n    return {\r\n        timeStamp: Date.now(),\r\n        pointers: pointers,\r\n        center: getCenter(pointers),\r\n        deltaX: input.deltaX,\r\n        deltaY: input.deltaY\r\n    };\r\n}\r\n\r\n/**\r\n * get the center of all the pointers\r\n * @param {Array} pointers\r\n * @return {Object} center contains `x` and `y` properties\r\n */\r\nfunction getCenter(pointers) {\r\n    var pointersLength = pointers.length;\r\n\r\n    // no need to loop when only one touch\r\n    if (pointersLength === 1) {\r\n        return {\r\n            x: round(pointers[0].clientX),\r\n            y: round(pointers[0].clientY)\r\n        };\r\n    }\r\n\r\n    var x = 0, y = 0;\r\n    for (var i = 0; i < pointersLength; i++) {\r\n        x += pointers[i].clientX;\r\n        y += pointers[i].clientY;\r\n    }\r\n\r\n    return {\r\n        x: round(x / pointersLength),\r\n        y: round(y / pointersLength)\r\n    };\r\n}\r\n\r\n/**\r\n * calculate the velocity between two points. unit is in px per ms.\r\n * @param {Number} deltaTime\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Object} velocity `x` and `y`\r\n */\r\nfunction getVelocity(deltaTime, x, y) {\r\n    return {\r\n        x: Math.abs(x / deltaTime) || 0,\r\n        y: Math.abs(y / deltaTime) || 0\r\n    };\r\n}\r\n\r\n/**\r\n * get the direction between two points\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Number} direction\r\n */\r\nfunction getDirection(x, y) {\r\n    if (x === y) {\r\n        return DIRECTION_NONE;\r\n    }\r\n\r\n    if (Math.abs(x) >= Math.abs(y)) {\r\n        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n    }\r\n    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\r\n}\r\n\r\n/**\r\n * calculate the absolute distance between two points\r\n * @param {Object} p1 {x, y}\r\n * @param {Object} p2 {x, y}\r\n * @param {Array} [props] containing x and y keys\r\n * @return {Number} distance\r\n */\r\nfunction getDistance(p1, p2, props) {\r\n    if (!props) {\r\n        props = PROPS_XY;\r\n    }\r\n    var x = p2[props[0]] - p1[props[0]],\r\n        y = p2[props[1]] - p1[props[1]];\r\n\r\n    return Math.sqrt((x * x) + (y * y));\r\n}\r\n\r\n/**\r\n * calculate the angle between two coordinates\r\n * @param {Object} p1\r\n * @param {Object} p2\r\n * @param {Array} [props] containing x and y keys\r\n * @return {Number} angle\r\n */\r\nfunction getAngle(p1, p2, props) {\r\n    if (!props) {\r\n        props = PROPS_XY;\r\n    }\r\n    var x = p2[props[0]] - p1[props[0]],\r\n        y = p2[props[1]] - p1[props[1]];\r\n    return Math.atan2(y, x) * 180 / Math.PI;\r\n}\r\n\r\n/**\r\n * calculate the rotation degrees between two pointersets\r\n * @param {Array} start array of pointers\r\n * @param {Array} end array of pointers\r\n * @return {Number} rotation\r\n */\r\nfunction getRotation(start, end) {\r\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);\r\n}\r\n\r\n/**\r\n * calculate the scale factor between two pointersets\r\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\r\n * @param {Array} start array of pointers\r\n * @param {Array} end array of pointers\r\n * @return {Number} scale\r\n */\r\nfunction getScale(start, end) {\r\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\r\n}\r\n\r\nvar MOUSE_INPUT_MAP = {\r\n    mousedown: INPUT_START,\r\n    mousemove: INPUT_MOVE,\r\n    mouseup: INPUT_END,\r\n    mouseout: INPUT_CANCEL\r\n};\r\n\r\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\r\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseout mouseup';\r\n\r\n/**\r\n * Mouse events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction MouseInput() {\r\n    this.evEl = MOUSE_ELEMENT_EVENTS;\r\n    this.evWin = MOUSE_WINDOW_EVENTS;\r\n\r\n    this.allow = true; // used by Input.TouchMouse to disable mouse events\r\n    this.pressed = false; // mousedown state\r\n\r\n    Input.apply(this, arguments);\r\n}\r\n\r\ninherit(MouseInput, Input, {\r\n    /**\r\n     * handle mouse events\r\n     * @param {Object} ev\r\n     */\r\n    handler: function(ev) {\r\n        var eventType = MOUSE_INPUT_MAP[ev.type];\r\n\r\n        // on start we want to have the left mouse button down\r\n        if (eventType & INPUT_START && ev.button === 0) {\r\n            this.pressed = true;\r\n        }\r\n\r\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\r\n            eventType = INPUT_END;\r\n        }\r\n\r\n        // mouse must be down, and mouse events are allowed (see the TouchMouse input)\r\n        if (!this.pressed || !this.allow) {\r\n            return;\r\n        }\r\n\r\n        // out of the window?\r\n        var target = ev.relatedTarget || ev.toElement || ev.target;\r\n        if (ev.type == 'mouseout' && target.nodeName != 'HTML') {\r\n            eventType = INPUT_MOVE;\r\n        }\r\n\r\n        if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n            this.pressed = false;\r\n        }\r\n\r\n        this.callback(this.manager, eventType, {\r\n            pointers: [ev],\r\n            changedPointers: [ev],\r\n            pointerType: INPUT_TYPE_MOUSE,\r\n            srcEvent: ev\r\n        });\r\n    },\r\n});\r\n\r\nvar POINTER_INPUT_MAP = {\r\n    pointerdown: INPUT_START,\r\n    pointermove: INPUT_MOVE,\r\n    pointerup: INPUT_END,\r\n    pointercancel: INPUT_CANCEL,\r\n    pointerout: INPUT_CANCEL\r\n};\r\n\r\n// in IE10 the pointer types is defined as an enum\r\nvar IE10_POINTER_TYPE_ENUM = {\r\n    2: INPUT_TYPE_TOUCH,\r\n    3: INPUT_TYPE_PEN,\r\n    4: INPUT_TYPE_MOUSE,\r\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\r\n};\r\n\r\nvar POINTER_ELEMENT_EVENTS = 'pointerdown pointermove pointerup pointercancel';\r\nvar POINTER_WINDOW_EVENTS = 'pointerout';\r\n\r\n// IE10 has prefixed support, and case-sensitive\r\nif (window.MSPointerEvent) {\r\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown MSPointerMove MSPointerUp MSPointerCancel';\r\n    POINTER_WINDOW_EVENTS = 'MSPointerOut';\r\n}\r\n\r\n/**\r\n * Pointer events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction PointerEventInput() {\r\n    this.evEl = POINTER_ELEMENT_EVENTS;\r\n    this.evWin = POINTER_WINDOW_EVENTS;\r\n\r\n    Input.apply(this, arguments);\r\n\r\n    this.store = (this.manager.session.pointerEvents = []);\r\n}\r\n\r\ninherit(PointerEventInput, Input, {\r\n    /**\r\n     * handle mouse events\r\n     * @param {Object} ev\r\n     */\r\n    handler: function(ev) {\r\n        var store = this.store;\r\n        var removePointer = false;\r\n\r\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\r\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\r\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\r\n\r\n        // out of the window?\r\n        var target = ev.relatedTarget || ev.toElement || ev.target;\r\n        if (eventTypeNormalized == 'pointerout' && target.nodeName != 'HTML') {\r\n            eventType = INPUT_MOVE;\r\n        }\r\n\r\n        // start and mouse must be down\r\n        if (eventType & INPUT_START && (ev.button === 0 || pointerType == INPUT_TYPE_TOUCH)) {\r\n            store.push(ev);\r\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n            removePointer = true;\r\n        }\r\n\r\n        // get index of the event in the store\r\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\r\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\r\n        if (storeIndex < 0) {\r\n            return;\r\n        }\r\n\r\n        // update the event in the store\r\n        store[storeIndex] = ev;\r\n\r\n        this.callback(this.manager, eventType, {\r\n            pointers: store,\r\n            changedPointers: [ev],\r\n            pointerType: pointerType,\r\n            srcEvent: ev\r\n        });\r\n\r\n        if (removePointer) {\r\n            // remove from the store\r\n            store.splice(storeIndex, 1);\r\n        }\r\n    }\r\n});\r\n\r\nvar TOUCH_INPUT_MAP = {\r\n    touchstart: INPUT_START,\r\n    touchmove: INPUT_MOVE,\r\n    touchend: INPUT_END,\r\n    touchcancel: INPUT_CANCEL\r\n};\r\n\r\nvar TOUCH_EVENTS = 'touchstart touchmove touchend touchcancel';\r\n\r\n/**\r\n * Touch events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction TouchInput() {\r\n    this.evEl = TOUCH_EVENTS;\r\n    this.targetIds = {};\r\n\r\n    Input.apply(this, arguments);\r\n}\r\n\r\ninherit(TouchInput, Input, {\r\n    /**\r\n     * handle touch events\r\n     * @param {Object} ev\r\n     */\r\n    handler: function(ev) {\r\n        var touches = normalizeTouches(ev, this);\r\n        this.callback(this.manager, TOUCH_INPUT_MAP[ev.type], {\r\n            pointers: touches[0],\r\n            changedPointers: touches[1],\r\n            pointerType: INPUT_TYPE_TOUCH,\r\n            srcEvent: ev\r\n        });\r\n    }\r\n});\r\n\r\n/**\r\n * make sure all browsers return the same touches\r\n * @param {Object} ev\r\n * @param {TouchInput} touchInput\r\n * @returns {Array} [all, changed]\r\n */\r\nfunction normalizeTouches(ev, touchInput) {\r\n    var i, len;\r\n\r\n    var targetIds = touchInput.targetIds;\r\n    var targetTouches = toArray(ev.targetTouches);\r\n    var changedTouches = toArray(ev.changedTouches);\r\n    var changedTargetTouches = [];\r\n\r\n    // collect touches\r\n    if (ev.type == 'touchstart') {\r\n        for (i = 0, len = targetTouches.length; i < len; i++) {\r\n            targetIds[targetTouches[i].identifier] = true;\r\n        }\r\n    }\r\n\r\n    // filter changed touches to only contain touches that exist in the collected target ids\r\n    for (i = 0, len = changedTouches.length; i < len; i++) {\r\n        if (targetIds[changedTouches[i].identifier]) {\r\n            changedTargetTouches.push(changedTouches[i]);\r\n        }\r\n\r\n        // cleanup removed touches\r\n        if (ev.type == 'touchend'|| ev.type == 'touchcancel') {\r\n            delete targetIds[changedTouches[i].identifier];\r\n        }\r\n    }\r\n\r\n    return [\r\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\r\n        // also removed the duplicates\r\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier'),\r\n\r\n        // only the changed :-)\r\n        changedTargetTouches\r\n    ];\r\n}\r\n\r\n/**\r\n * Combined touch and mouse input\r\n *\r\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\r\n * This because touch devices also emit mouse events while doing a touch.\r\n *\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction TouchMouseInput() {\r\n    Input.apply(this, arguments);\r\n\r\n    var handler = bindFn(this.handler, this);\r\n    this.touch = new TouchInput(this.manager, handler);\r\n    this.mouse = new MouseInput(this.manager, handler);\r\n}\r\n\r\ninherit(TouchMouseInput, Input, {\r\n    /**\r\n     * handle mouse and touch events\r\n     * @param {Hammer} manager\r\n     * @param {String} inputEvent\r\n     * @param {Object} inputData\r\n     */\r\n    handler: function(manager, inputEvent, inputData) {\r\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\r\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\r\n\r\n        // when we're in a touch event, so  block all upcoming mouse events\r\n        // most mobile browser also emit mouseevents, right after touchstart\r\n        if (isTouch) {\r\n            this.mouse.allow = false;\r\n        } else if (isMouse && !this.mouse.allow) {\r\n            return;\r\n        }\r\n\r\n        // reset the allowMouse when we're done\r\n        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {\r\n            this.mouse.allow = true;\r\n        }\r\n\r\n        this.callback(manager, inputEvent, inputData);\r\n    },\r\n\r\n    /**\r\n     * remove the event listeners\r\n     */\r\n    destroy: function() {\r\n        this.touch.destroy();\r\n        this.mouse.destroy();\r\n    }\r\n});\r\n\r\nvar PREFIXED_TOUCH_ACTION = prefixed(document.body.style, 'touchAction');\r\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\r\n\r\n// magical touchAction value\r\nvar TOUCH_ACTION_COMPUTE = 'compute';\r\nvar TOUCH_ACTION_AUTO = 'auto';\r\nvar TOUCH_ACTION_MANIPULATION = 'manipulation';\r\nvar TOUCH_ACTION_NONE = 'none';\r\nvar TOUCH_ACTION_PAN_X = 'pan-x';\r\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\r\n\r\n/**\r\n * Touch Action\r\n * sets the touchAction property or uses the js alternative\r\n * @param {Manager} manager\r\n * @param {String} value\r\n * @constructor\r\n */\r\nfunction TouchAction(manager, value) {\r\n    this.manager = manager;\r\n    this.set(value);\r\n}\r\n\r\nTouchAction.prototype = {\r\n    /**\r\n     * set the touchAction value on the element or enable the polyfill\r\n     * @param {String} value\r\n     */\r\n    set: function(value) {\r\n        // find out the touch-action by the event handlers\r\n        if (value == TOUCH_ACTION_COMPUTE) {\r\n            value = this.compute();\r\n        }\r\n\r\n        if (NATIVE_TOUCH_ACTION) {\r\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\r\n        }\r\n        this.actions = value.toLowerCase();\r\n    },\r\n\r\n    /**\r\n     * just re-set the touchAction value\r\n     */\r\n    update: function() {\r\n        this.set(this.manager.options.touchAction);\r\n    },\r\n\r\n    /**\r\n     * compute the value for the touchAction property based on the recognizer's settings\r\n     * @returns {String} value\r\n     */\r\n    compute: function() {\r\n        var value;\r\n        var actions = [];\r\n\r\n        each(this.manager.recognizers, function(recognizer) {\r\n            if (boolOrFn(recognizer.options.enable, recognizer)) {\r\n                actions = actions.concat(recognizer.getTouchAction());\r\n            }\r\n        });\r\n        value = uniqueArray(actions).join(' ');\r\n        return cleanTouchActions(value);\r\n    },\r\n\r\n    /**\r\n     * this method is called on each input cycle and provides the preventing of the browser behavior\r\n     * @param {Object} input\r\n     */\r\n    preventDefaults: function(input) {\r\n        // not needed with native support for the touchAction property\r\n        if (NATIVE_TOUCH_ACTION) {\r\n            return;\r\n        }\r\n\r\n        var srcEvent = input.srcEvent;\r\n        var direction = input.offsetDirection;\r\n\r\n        // if the touch action did prevented once this session\r\n        if (this.manager.session.prevented) {\r\n            srcEvent.preventDefault();\r\n            return;\r\n        }\r\n\r\n        var actions = this.actions;\r\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE);\r\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\r\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\r\n\r\n        if (hasNone || (hasPanY && hasPanX) ||\r\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\r\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\r\n            return this.preventSrc(srcEvent);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\r\n     * @param {Object} srcEvent\r\n     */\r\n    preventSrc: function(srcEvent) {\r\n        this.manager.session.prevented = true;\r\n        srcEvent.preventDefault();\r\n    }\r\n};\r\n\r\n/**\r\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\r\n * @param {String} actions\r\n * @returns {*}\r\n */\r\nfunction cleanTouchActions(actions) {\r\n    // none\r\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\r\n        return TOUCH_ACTION_NONE;\r\n    }\r\n    // pan-x and pan-y can be combined\r\n    if (inStr(actions, TOUCH_ACTION_PAN_X) || inStr(actions, TOUCH_ACTION_PAN_Y)) {\r\n        return actions.replace(/[\\-\\w]+/g, function(action) {\r\n            if (/^pan\\-/.test(action)) {\r\n                return action;\r\n            }\r\n            return '';\r\n        });\r\n    }\r\n    // manipulation\r\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\r\n        return TOUCH_ACTION_MANIPULATION;\r\n    }\r\n\r\n    return TOUCH_ACTION_AUTO;\r\n}\r\n\r\n/**\r\n * Recognizer flow explained; *\r\n * All recognizers have the initial state of POSSIBLE when a input session starts.\r\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\r\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\r\n *\r\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\r\n * which determines with state it should be.\r\n *\r\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\r\n * POSSIBLE to give it another change on the next cycle.\r\n *\r\n *               Possible\r\n *                  |\r\n *            +-----+---------------+\r\n *            |                     |\r\n *      +-----+-----+               |\r\n *      |           |               |\r\n *   Failed      Cancelled          |\r\n *                          +-------+------+\r\n *                          |              |\r\n *                      Recognized       Began\r\n *                                         |\r\n *                                      Changed\r\n *                                         |\r\n *                                  Ended/Recognized\r\n */\r\nvar STATE_POSSIBLE = 1;\r\nvar STATE_BEGAN = 2;\r\nvar STATE_CHANGED = 4;\r\nvar STATE_ENDED = 8;\r\nvar STATE_RECOGNIZED = STATE_ENDED;\r\nvar STATE_CANCELLED = 16;\r\nvar STATE_FAILED = 32;\r\n\r\n/**\r\n * Recognizer\r\n * Every recognizer needs to extend from this class.\r\n * @constructor\r\n * @param {Object} options\r\n */\r\nfunction Recognizer(options) {\r\n    this.id = uniqueId();\r\n\r\n    this.manager = null;\r\n    this.options = merge(options || {}, this.defaults);\r\n\r\n    // default is enable true\r\n    this.options.enable = ifUndefined(this.options.enable, true);\r\n\r\n    this.state = STATE_POSSIBLE;\r\n\r\n    this.simultaneous = {};\r\n    this.requireFail = [];\r\n}\r\n\r\nRecognizer.prototype = {\r\n    /**\r\n     * @virtual\r\n     * @type {Object}\r\n     */\r\n    defaults: {},\r\n\r\n    /**\r\n     * set options\r\n     * @param {String} option\r\n     * @param {*} val\r\n     */\r\n    set: function(option, val) {\r\n        this.options[option] = val;\r\n\r\n        // also update the touchAction, in case something changed about the directions/enabled state\r\n        this.manager && this.manager.touchAction.update();\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * recognize simultaneous with an other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    recognizeWith: function(otherRecognizer) {\r\n        var simultaneous = this.simultaneous;\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        if (!simultaneous[otherRecognizer.id]) {\r\n            simultaneous[otherRecognizer.id] = otherRecognizer;\r\n            otherRecognizer.recognizeWith(this);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    dropRecognizeWith: function(otherRecognizer) {\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        delete this.simultaneous[otherRecognizer.id];\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * recognizer can only run when an other is failing\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    requireFailure: function(otherRecognizer) {\r\n        var requireFail = this.requireFail;\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        if (inArray(requireFail, otherRecognizer) === -1) {\r\n            requireFail.push(otherRecognizer);\r\n            otherRecognizer.requireFailure(this);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    dropRequireFailure: function(otherRecognizer) {\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        var index = inArray(this.requireFail, otherRecognizer);\r\n        if (index > -1) {\r\n            this.requireFail.splice(index, 1);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * has require failures boolean\r\n     * @returns {boolean}\r\n     */\r\n    hasRequireFailures: function() {\r\n        return this.requireFail.length > 0;\r\n    },\r\n\r\n    /**\r\n     * if the recognizer can recognize simultaneous with an other recognizer\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Boolean}\r\n     */\r\n    canRecognizeWith: function(otherRecognizer) {\r\n        return !!this.simultaneous[otherRecognizer.id];\r\n    },\r\n\r\n    /**\r\n     * You should use `tryEmit` instead of `emit` directly to check\r\n     * that all the needed recognizers has failed before emitting.\r\n     * @param {Object} input\r\n     */\r\n    emit: function(input) {\r\n        this.manager.emit(this.options.event, input); // simple 'eventName' events\r\n        this.manager.emit(this.options.event + stateStr(this.state), input); // like 'panmove' and 'panstart'\r\n    },\r\n\r\n    /**\r\n     * Check that all the require failure recognizers has failed,\r\n     * if true, it emits a gesture event,\r\n     * otherwise, setup the state to FAILED.\r\n     * @param {Object} input\r\n     */\r\n    tryEmit: function(input) {\r\n        if (this.canEmit()) {\r\n            return this.emit(input);\r\n        }\r\n        // it's failing anyway\r\n        this.state = STATE_FAILED;\r\n    },\r\n\r\n    /**\r\n     * can we emit?\r\n     * @returns {boolean}\r\n     */\r\n    canEmit: function() {\r\n        for (var i = 0; i < this.requireFail.length; i++) {\r\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * update the recognizer\r\n     * @param {Object} inputData\r\n     */\r\n    recognize: function(inputData) {\r\n        // make a new copy of the inputData\r\n        // so we can change the inputData without messing up the other recognizers\r\n        var inputDataClone = extend({}, inputData);\r\n\r\n        // is is enabled and allow recognizing?\r\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\r\n            this.reset();\r\n            this.state = STATE_FAILED;\r\n            return;\r\n        }\r\n\r\n        // reset when we've reached the end\r\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\r\n            this.state = STATE_POSSIBLE;\r\n        }\r\n\r\n        this.state = this.process(inputDataClone);\r\n\r\n        // the recognizer has recognized a gesture\r\n        // so trigger an event\r\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\r\n            this.tryEmit(inputDataClone);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * return the state of the recognizer\r\n     * the actual recognizing happens in this method\r\n     * @virtual\r\n     * @param {Object} inputData\r\n     * @returns {Const} STATE\r\n     */\r\n    process: function(inputData) { }, // jshint ignore:line\r\n\r\n    /**\r\n     * return the preferred touch-action\r\n     * @virtual\r\n     * @returns {Array}\r\n     */\r\n    getTouchAction: function() { },\r\n\r\n    /**\r\n     * called when the gesture isn't allowed to recognize\r\n     * like when another is being recognized or it is disabled\r\n     * @virtual\r\n     */\r\n    reset: function() { }\r\n};\r\n\r\n/**\r\n * get a usable string, used as event postfix\r\n * @param {Const} state\r\n * @returns {String} state\r\n */\r\nfunction stateStr(state) {\r\n    if (state & STATE_CANCELLED) {\r\n        return 'cancel';\r\n    } else if (state & STATE_ENDED) {\r\n        return 'end';\r\n    } else if (state & STATE_CHANGED) {\r\n        return 'move';\r\n    } else if (state & STATE_BEGAN) {\r\n        return 'start';\r\n    }\r\n    return '';\r\n}\r\n\r\n/**\r\n * direction cons to string\r\n * @param {Const} direction\r\n * @returns {String}\r\n */\r\nfunction directionStr(direction) {\r\n    if (direction == DIRECTION_DOWN) {\r\n        return 'down';\r\n    } else if (direction == DIRECTION_UP) {\r\n        return 'up';\r\n    } else if (direction == DIRECTION_LEFT) {\r\n        return 'left';\r\n    } else if (direction == DIRECTION_RIGHT) {\r\n        return 'right';\r\n    }\r\n    return '';\r\n}\r\n\r\n/**\r\n * get a recognizer by name if it is bound to a manager\r\n * @param {Recognizer|String} otherRecognizer\r\n * @param {Recognizer} recognizer\r\n * @returns {Recognizer}\r\n */\r\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\r\n    var manager = recognizer.manager;\r\n    if (manager) {\r\n        return manager.get(otherRecognizer);\r\n    }\r\n    return otherRecognizer;\r\n}\r\n\r\n/**\r\n * This recognizer is just used as a base for the simple attribute recognizers.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nfunction AttrRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(AttrRecognizer, Recognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof AttrRecognizer\r\n     */\r\n    defaults: {\r\n        /**\r\n         * @type {Number}\r\n         * @default 1\r\n         */\r\n        pointers: 1\r\n    },\r\n\r\n    /**\r\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\r\n     * @memberof AttrRecognizer\r\n     * @param {Object} input\r\n     * @returns {Boolean} recognized\r\n     */\r\n    attrTest: function(input) {\r\n        var optionPointers = this.options.pointers;\r\n        return optionPointers === 0 || input.pointers.length === optionPointers;\r\n    },\r\n\r\n    /**\r\n     * Process the input and return the state for the recognizer\r\n     * @memberof AttrRecognizer\r\n     * @param {Object} input\r\n     * @returns {*} State\r\n     */\r\n    process: function(input) {\r\n        var state = this.state;\r\n        var eventType = input.eventType;\r\n\r\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\r\n        var isValid = this.attrTest(input);\r\n\r\n        // on cancel input and we've recognized before, return STATE_CANCELLED\r\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\r\n            return state | STATE_CANCELLED;\r\n        } else if (isRecognized || isValid) {\r\n            if (eventType & INPUT_END) {\r\n                return state | STATE_ENDED;\r\n            } else if (!(state & STATE_BEGAN)) {\r\n                return STATE_BEGAN;\r\n            }\r\n            return state | STATE_CHANGED;\r\n        }\r\n        return STATE_FAILED;\r\n    }\r\n});\r\n\r\n/**\r\n * Pan\r\n * Recognized when the pointer is down and moved in the allowed direction.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction PanRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n\r\n    this.pX = null;\r\n    this.pY = null;\r\n}\r\n\r\ninherit(PanRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PanRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'pan',\r\n        threshold: 10,\r\n        pointers: 1,\r\n        direction: DIRECTION_ALL\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        var direction = this.options.direction;\r\n\r\n        if (direction === DIRECTION_ALL) {\r\n            return [TOUCH_ACTION_NONE];\r\n        }\r\n\r\n        var actions = [];\r\n        if (direction & DIRECTION_HORIZONTAL) {\r\n            actions.push(TOUCH_ACTION_PAN_Y);\r\n        }\r\n        if (direction & DIRECTION_VERTICAL) {\r\n            actions.push(TOUCH_ACTION_PAN_X);\r\n        }\r\n        return actions;\r\n    },\r\n\r\n    directionTest: function(input) {\r\n        var options = this.options;\r\n        var hasMoved = true;\r\n        var distance = input.distance;\r\n        var direction = input.direction;\r\n        var x = input.deltaX;\r\n        var y = input.deltaY;\r\n\r\n\r\n\r\n        // lock to axis?\r\n        if (!(direction & options.direction)) {\r\n            if (options.direction & DIRECTION_HORIZONTAL) {\r\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n                hasMoved = x != this.pX;\r\n                distance = Math.abs(input.deltaX);\r\n            } else {\r\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\r\n                hasMoved = y != this.pY;\r\n                distance = Math.abs(input.deltaY);\r\n            }\r\n        }\r\n        input.direction = direction;\r\n        return hasMoved && distance > options.threshold && direction & options.direction;\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\r\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\r\n    },\r\n\r\n    emit: function(input) {\r\n        this.pX = input.deltaX;\r\n        this.pY = input.deltaY;\r\n\r\n        this._super.emit.call(this, input);\r\n\r\n        var direction = directionStr(input.direction);\r\n        if (direction) {\r\n            this.manager.emit(this.options.event + direction, input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Pinch\r\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction PinchRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(PinchRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PinchRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'pinch',\r\n        threshold: 0,\r\n        pointers: 2\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y];\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return this._super.attrTest.call(this, input) &&\r\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\r\n    },\r\n\r\n    emit: function(input) {\r\n        this._super.emit.call(this, input);\r\n        if (input.scale !== 1) {\r\n            var inOut = input.scale < 1 ? 'in' : 'out';\r\n            this.manager.emit(this.options.event + inOut, input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Press\r\n * Recognized when the pointer is down for x ms without any movement.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nfunction PressRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n\r\n    this._timer = null;\r\n    this._input = null;\r\n}\r\n\r\ninherit(PressRecognizer, Recognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PressRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'press',\r\n        pointers: 1,\r\n        time: 500, // minimal time of the pointer to be pressed\r\n        threshold: 5 // a minimal movement is ok, but keep it low\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_AUTO];\r\n    },\r\n\r\n    process: function(input) {\r\n        var options = this.options;\r\n\r\n        var validPointers = input.pointers.length === options.pointers;\r\n        var validMovement = input.distance < options.threshold;\r\n        var validTime = input.deltaTime > options.time;\r\n\r\n        this._input = input;\r\n\r\n        // we only allow little movement\r\n        // and we've reached an end event, so a tap is possible\r\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\r\n            this.reset();\r\n        } else if (input.eventType & INPUT_START) {\r\n            this.reset();\r\n            var self = this;\r\n            this._timer = setTimeout(function() {\r\n                self.state = STATE_RECOGNIZED;\r\n                self.tryEmit();\r\n            }, options.time);\r\n        }\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    reset: function() {\r\n        clearTimeout(this._timer);\r\n        this._timer = null;\r\n    },\r\n\r\n    emit: function() {\r\n        if (this.state === STATE_RECOGNIZED) {\r\n            this._input.timeStamp = Date.now();\r\n            this.manager.emit(this.options.event, this._input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Rotate\r\n * Recognized when two or more pointer are moving in a circular motion.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction RotateRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(RotateRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof RotateRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'rotate',\r\n        threshold: 0,\r\n        pointers: 2\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_NONE];\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return this._super.attrTest.call(this, input) &&\r\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\r\n    }\r\n});\r\n\r\n/**\r\n * Swipe\r\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction SwipeRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(SwipeRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof SwipeRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'swipe',\r\n        threshold: 10,\r\n        velocity: 0.65,\r\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\r\n        pointers: 1\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return PanRecognizer.prototype.getTouchAction.call(this);\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        var direction = this.options.direction;\r\n        var velocity;\r\n\r\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\r\n            velocity = input.velocity;\r\n        } else if (direction & DIRECTION_HORIZONTAL) {\r\n            velocity = input.velocityX;\r\n        } else if (direction & DIRECTION_VERTICAL) {\r\n            velocity = input.velocityY;\r\n        }\r\n\r\n        return this._super.attrTest.call(this, input) &&\r\n            direction & input.direction &&\r\n            velocity > this.options.velocity && input.eventType & INPUT_END;\r\n    },\r\n\r\n    emit: function(input) {\r\n        this.manager.emit(this.options.event, input);\r\n\r\n        var direction = directionStr(input.direction);\r\n        if (direction) {\r\n            this.manager.emit(this.options.event + direction, input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\r\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\r\n * a single tap.\r\n *\r\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\r\n * multi-taps being recognized.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nfunction TapRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n\r\n    // previous time and center,\r\n    // used for tap counting\r\n    this.pTime = false;\r\n    this.pCenter = false;\r\n\r\n    this._timer = null;\r\n    this._input = null;\r\n    this.count = 0;\r\n}\r\n\r\ninherit(TapRecognizer, Recognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PinchRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'tap',\r\n        pointers: 1,\r\n        taps: 1,\r\n        delay: 300,\r\n        interval: 300, // max time between the multi-tap taps\r\n        time: 250, // max time of the pointer to be down (like finger on the screen)\r\n        threshold: 2, // a minimal movement is ok, but keep it low\r\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_MANIPULATION];\r\n    },\r\n\r\n    process: function(input) {\r\n        var self = this;\r\n        var options = this.options;\r\n\r\n        var validPointers = input.pointers.length === options.pointers;\r\n        var validMovement = input.distance < options.threshold;\r\n        var validTouchTime = input.deltaTime < options.time;\r\n\r\n        this.reset();\r\n\r\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\r\n            return this._setupBeganState();\r\n        }\r\n\r\n        // we only allow little movement\r\n        // and we've reached an end event, so a tap is possible\r\n        if (validMovement && validTouchTime && validPointers) {\r\n            if (input.eventType & INPUT_END) {\r\n                var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\r\n                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\r\n\r\n                this.pTime = input.timeStamp;\r\n                this.pCenter = input.center;\r\n\r\n                if (!validMultiTap || !validInterval) {\r\n                    this.count = 1;\r\n                } else {\r\n                    this.count += 1;\r\n                }\r\n\r\n                this._input = input;\r\n\r\n                // if tap count matches we have recognized it,\r\n                // else it has began recognizing...\r\n                var tapCount = this.count % options.taps;\r\n                if (tapCount === 0) {\r\n                    if (!this.hasRequireFailures()) {\r\n                        return STATE_RECOGNIZED;\r\n                    } else {\r\n                        this._timer = setTimeout(function() {\r\n                            self.state = STATE_RECOGNIZED;\r\n                            self.tryEmit();\r\n                        }, options.delay);\r\n                        return STATE_BEGAN;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return this._setupBeganState();\r\n        }\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    _setupBeganState: function() {\r\n        var self = this;\r\n        this._timer = setTimeout(function() {\r\n            self.state = STATE_FAILED;\r\n        }, this.options.delay);\r\n\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    reset: function() {\r\n        clearTimeout(this._timer);\r\n    },\r\n\r\n    emit: function() {\r\n        if (this.state == STATE_RECOGNIZED ) {\r\n            this._input.tapCount = this.count;\r\n            this.manager.emit(this.options.event, this._input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Simple way to create an manager with a default set of recognizers.\r\n * @param {HTMLElement} element\r\n * @param {Object} [options]\r\n * @constructor\r\n */\r\nfunction Hammer(element, options) {\r\n    options = options || {};\r\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.easyRecognizers);\r\n    return new Manager(element, options);\r\n}\r\n\r\n/**\r\n * Current build version.\r\n * @const {string}\r\n */\r\nHammer.VERSION = '2.0.0dev';\r\n\r\n/**\r\n * default settings\r\n * @namespace\r\n */\r\nHammer.defaults = {\r\n    /**\r\n     * set if DOM events are being triggered.\r\n     * But this is slower and unused by simple implementations, so disabled by default.\r\n     * @type {Boolean}\r\n     * @default false\r\n     */\r\n    domEvents: false,\r\n\r\n    /**\r\n     * The value for the touchAction property/fallback.\r\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\r\n     * @type {String}\r\n     * @default compute\r\n     */\r\n    touchAction: TOUCH_ACTION_COMPUTE,\r\n\r\n    /**\r\n     * @type {Boolean}\r\n     * @default true\r\n     */\r\n    enable: true,\r\n\r\n    /**\r\n     * Default recognizer setup when calling `Hammer()`\r\n     * When creating a new Manager these will be skipped.\r\n     * @type {Array}\r\n     */\r\n    easyRecognizers: [\r\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\r\n        [RotateRecognizer, { enable: false }],\r\n        [PinchRecognizer, { enable: false }, ['rotate']],\r\n        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],\r\n        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\r\n        [TapRecognizer],\r\n        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\r\n        [PressRecognizer]\r\n    ],\r\n\r\n    /**\r\n     * Some CSS properties can be used to improve the working of Hammer.\r\n     * Add them to this method and they will be set when creating a new Manager.\r\n     * @namespace\r\n     */\r\n    cssProps: {\r\n        /**\r\n         * Disables text selection to improve the dragging gesture. When the value is `none` it also sets\r\n         * `onselectstart=false` for IE9 on the element. Mainly for desktop browsers.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        userSelect: 'none',\r\n\r\n        /**\r\n         * Disable the Windows Phone grippers when pressing an element.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        touchSelect: 'none',\r\n\r\n        /**\r\n         * Disables the default callout shown when you touch and hold a touch target.\r\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\r\n         * a callout containing information about the link. This property allows you to disable that callout.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        touchCallout: 'none',\r\n\r\n        /**\r\n         * Specifies whether zooming is enabled. Used by IE10>\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        contentZooming: 'none',\r\n\r\n        /**\r\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        userDrag: 'none',\r\n\r\n        /**\r\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\r\n         * clickable element in iOS. This property obeys the alpha value, if specified.\r\n         * @type {String}\r\n         * @default 'rgba(0,0,0,0)'\r\n         */\r\n        tapHighlightColor: 'rgba(0,0,0,0)'\r\n    }\r\n};\r\n\r\nvar STOP = 1;\r\nvar FORCED_STOP = 2;\r\n\r\n/**\r\n * Manager\r\n * @param {HTMLElement} element\r\n * @param {Object} [options]\r\n * @constructor\r\n */\r\nfunction Manager(element, options) {\r\n    options = options || {};\r\n\r\n    this.options = merge(options, Hammer.defaults);\r\n\r\n    this.handlers = {};\r\n    this.session = {};\r\n    this.recognizers = [];\r\n\r\n    this.element = element;\r\n    this.input = createInputInstance(this);\r\n    this.touchAction = new TouchAction(this, this.options.touchAction);\r\n\r\n    toggleCssProps(this, true);\r\n\r\n    each(options.recognizers, function(item) {\r\n        var recognizer = this.add(new (item[0])(item[1]));\r\n        item[2] && each(item[2], recognizer.recognizeWith, recognizer);\r\n        item[3] && each(item[3], recognizer.requireFailure, recognizer);\r\n    }, this);\r\n}\r\n\r\nManager.prototype = {\r\n    /**\r\n     * set options\r\n     * @param {String} option\r\n     * @param {*} val\r\n     */\r\n    set: function(option, val) {\r\n        this.options[option] = val;\r\n    },\r\n\r\n    /**\r\n     * stop recognizing for this session.\r\n     * This session will be discarded, when a new [input]start event is fired.\r\n     * When forced, the recognizer cycle is stopped immediately.\r\n     * @param {Boolean} [force]\r\n     */\r\n    stop: function(force) {\r\n        this.session.stopped = force ? FORCED_STOP : STOP;\r\n    },\r\n\r\n    /**\r\n     * run the recognizers!\r\n     * called by the inputHandler function on every movement of the pointers (touches)\r\n     * it walks through all the recognizers and tries to detect the gesture that is being made\r\n     * @param {Object} inputData\r\n     */\r\n    recognize: function(inputData) {\r\n        if (this.session.stopped) {\r\n            return;\r\n        }\r\n\r\n        // run the touch-action polyfill\r\n        this.touchAction.preventDefaults(inputData);\r\n\r\n        var recognizer;\r\n        var session = this.session;\r\n\r\n        // this holds the recognizer that is being recognized.\r\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\r\n        // if no recognizer is detecting a thing, it is set to `null`\r\n        var curRecognizer = session.curRecognizer;\r\n\r\n        // reset when the last recognizer is recognized\r\n        // or when we're in a new session\r\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\r\n            curRecognizer = session.curRecognizer = null;\r\n        }\r\n\r\n        for (var i = 0, len = this.recognizers.length; i < len; i++) {\r\n            recognizer = this.recognizers[i];\r\n\r\n            // find out if we are allowed try to recognize the input for this one.\r\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\r\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\r\n            //      that is being recognized.\r\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\r\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\r\n            if (this.session.stopped !== FORCED_STOP && ( // 1\r\n                    !curRecognizer || recognizer == curRecognizer || // 2\r\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\r\n                recognizer.recognize(inputData);\r\n            } else {\r\n                recognizer.reset();\r\n            }\r\n\r\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\r\n            // current active recognizer. but only if we don't already have an active recognizer\r\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\r\n                curRecognizer = session.curRecognizer = recognizer;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * get a recognizer by its event name.\r\n     * @param {Recognizer|String} recognizer\r\n     * @returns {Recognizer|Null}\r\n     */\r\n    get: function(recognizer) {\r\n        if (recognizer instanceof Recognizer) {\r\n            return recognizer;\r\n        }\r\n\r\n        var recognizers = this.recognizers;\r\n        for (var i = 0; i < recognizers.length; i++) {\r\n            if (recognizers[i].options.event == recognizer) {\r\n                return recognizers[i];\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * add a recognizer to the manager\r\n     * existing recognizers with the same event name will be removed\r\n     * @param {Recognizer} recognizer\r\n     * @returns {Recognizer}\r\n     */\r\n    add: function(recognizer) {\r\n        // remove existing\r\n        var existing = this.get(recognizer.options.event);\r\n        if (existing) {\r\n            this.remove(existing);\r\n        }\r\n\r\n        this.recognizers.push(recognizer);\r\n        recognizer.manager = this;\r\n\r\n        this.touchAction.update();\r\n        return recognizer;\r\n    },\r\n\r\n    /**\r\n     * remove a recognizer by name or instance\r\n     * @param {Recognizer|String} recognizer\r\n     */\r\n    remove: function(recognizer) {\r\n        var recognizers = this.recognizers;\r\n        recognizer = this.get(recognizer);\r\n        recognizers.splice(inArray(recognizers, recognizer), 1);\r\n\r\n        this.touchAction.update();\r\n    },\r\n\r\n    /**\r\n     * bind event\r\n     * @param {String} events\r\n     * @param {Function} handler\r\n     * @returns {EventEmitter} this\r\n     */\r\n    on: function(events, handler) {\r\n        var handlers = this.handlers;\r\n        each(splitStr(events), function(event) {\r\n            handlers[event] = handlers[event] || [];\r\n            handlers[event].push(handler);\r\n        });\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * unbind event, leave emit blank to remove all handlers\r\n     * @param {String} events\r\n     * @param {Function} [handler]\r\n     * @returns {EventEmitter} this\r\n     */\r\n    off: function(events, handler) {\r\n        var handlers = this.handlers;\r\n        each(splitStr(events), function(event) {\r\n            if (!handler) {\r\n                delete handlers[event];\r\n            } else {\r\n                handlers[event].splice(inArray(handlers[event], handler), 1);\r\n            }\r\n        });\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * emit event to the listeners\r\n     * @param {String} event\r\n     * @param {Object} data\r\n     */\r\n    emit: function(event, data) {\r\n        // we also want to trigger dom events\r\n        if (this.options.domEvents) {\r\n            triggerDomEvent(event, data);\r\n        }\r\n\r\n        // no handlers, so skip it all\r\n        var handlers = this.handlers[event];\r\n        if (!handlers || !handlers.length) {\r\n            return;\r\n        }\r\n\r\n        data.type = event;\r\n        data.preventDefault = function() {\r\n            data.srcEvent.preventDefault();\r\n        };\r\n\r\n        for (var i = 0, len = handlers.length; i < len; i++) {\r\n            handlers[i](data);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * destroy the manager and unbinds all events\r\n     * it doesn't unbind dom events, that is the user own responsibility\r\n     */\r\n    destroy: function() {\r\n        if (this.element) {\r\n            toggleCssProps(this, false);\r\n        }\r\n\r\n        this.handlers = {};\r\n        this.session = {};\r\n        this.input.destroy();\r\n        this.element = null;\r\n    }\r\n};\r\n\r\n/**\r\n * add/remove the css properties as defined in manager.options.cssProps\r\n * @param {Manager} manager\r\n * @param {Boolean} add\r\n */\r\nfunction toggleCssProps(manager, add) {\r\n    var element = manager.element;\r\n    var cssProps = manager.options.cssProps;\r\n\r\n    each(cssProps, function(value, name) {\r\n        element.style[prefixed(element.style, name)] = add ? value : '';\r\n    });\r\n\r\n    var falseFn = add && function() { return false; };\r\n    if (cssProps.userSelect == 'none') { element.onselectstart = falseFn; }\r\n    if (cssProps.userDrag == 'none') { element.ondragstart = falseFn; }\r\n}\r\n\r\n/**\r\n * trigger dom event\r\n * @param {String} event\r\n * @param {Object} data\r\n */\r\nfunction triggerDomEvent(event, data) {\r\n    var gestureEvent = document.createEvent('Event');\r\n    gestureEvent.initEvent(event, true, true);\r\n    gestureEvent.gesture = data;\r\n    data.target.dispatchEvent(gestureEvent);\r\n}\r\n\r\nextend(Hammer, {\r\n    INPUT_START: INPUT_START,\r\n    INPUT_MOVE: INPUT_MOVE,\r\n    INPUT_END: INPUT_END,\r\n    INPUT_CANCEL: INPUT_CANCEL,\r\n\r\n    STATE_POSSIBLE: STATE_POSSIBLE,\r\n    STATE_BEGAN: STATE_BEGAN,\r\n    STATE_CHANGED: STATE_CHANGED,\r\n    STATE_ENDED: STATE_ENDED,\r\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\r\n    STATE_CANCELLED: STATE_CANCELLED,\r\n    STATE_FAILED: STATE_FAILED,\r\n\r\n    DIRECTION_NONE: DIRECTION_NONE,\r\n    DIRECTION_LEFT: DIRECTION_LEFT,\r\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\r\n    DIRECTION_UP: DIRECTION_UP,\r\n    DIRECTION_DOWN: DIRECTION_DOWN,\r\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\r\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\r\n    DIRECTION_ALL: DIRECTION_ALL,\r\n\r\n    Manager: Manager,\r\n    Input: Input,\r\n    TouchAction: TouchAction,\r\n\r\n    Recognizer: Recognizer,\r\n    AttrRecognizer: AttrRecognizer,\r\n    Tap: TapRecognizer,\r\n    Pan: PanRecognizer,\r\n    Swipe: SwipeRecognizer,\r\n    Pinch: PinchRecognizer,\r\n    Rotate: RotateRecognizer,\r\n    Press: PressRecognizer,\r\n\r\n    on: addEventListeners,\r\n    off: removeEventListeners,\r\n    each: each,\r\n    merge: merge,\r\n    extend: extend,\r\n    inherit: inherit,\r\n    bindFn: bindFn,\r\n    prefixed: prefixed\r\n});\r\n\r\nif (typeof define == TYPE_FUNCTION && define.amd) {\r\n    define(function() {\r\n        return Hammer;\r\n    });\r\n} else if (typeof module != TYPE_UNDEFINED && module.exports) {\r\n    module.exports = Hammer;\r\n} else {\r\n    window.Hammer = Hammer;\r\n}\r\n\r\n})(window);","module.exports = __webpack_amd_options__;\r\n"],"sourceRoot":"webpack-module://"}