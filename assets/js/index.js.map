{"version":3,"file":"index.js","sources":["index.js","webpack/bootstrap e27f34f3fa28630b8bab","./src/assets/js/index.js","./src/assets/js/trackers.js","./src/assets/js/demo.js","./~/hammerjs/hammer.js","(webpack)/buildin/amd-options.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","d","s","js","fjs","getElementsByTagName","getElementById","createElement","src","parentNode","insertBefore","document","location","href","indexOf","_gaq","push","ga","type","async","protocol","resetElementStart","el","className","resetElementEnd","transform","translate","x","startX","y","startY","scale","rotate","requestElementUpdate","updateElementTransform","value","style","webkitTransform","join","ticking","reqAnimationFrame","onPan","ev","deltaX","deltaY","onSwipe","setTimeout","onPinch","onRotate","rotation","onTap","onDoubleTap","onHold","background","Hammer","window","prefixed","callback","querySelector","Math","round","offsetWidth","offsetHeight","mc","get","set","on","addEventListener","classList","toggle","__WEBPACK_AMD_DEFINE_RESULT__","undefined","each","obj","iterator","context","i","len","forEach","length","hasOwnProperty","extend","dest","merge","keys","Object","inherit","child","base","properties","childP","baseP","prototype","create","constructor","Inherited","this","_super","bindFn","fn","apply","arguments","boolOrFn","val","args","TYPE_FUNCTION","addEventListeners","element","types","handler","splitStr","removeEventListeners","removeEventListener","hasParent","node","parent","inStr","str","find","trim","split","inArray","findByKey","toArray","Array","slice","uniqueArray","key","results","values","property","prefix","prop","camelProp","toUpperCase","VENDOR_PREFIXES","uniqueId","_uniqueId","Input","manager","self","domHandler","options","enable","elEvents","winEvents","createInputInstance","Type","SUPPORT_POINTER_EVENTS","PointerEventInput","SUPPORT_ONLY_TOUCH","TouchInput","SUPPORT_TOUCH","TouchMouseInput","MouseInput","inputHandler","eventType","input","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","INPUT_START","isFinal","INPUT_END","session","computeInputData","recognize","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","timeStamp","Date","now","deltaTime","angle","getAngle","distance","getDistance","offsetDirection","getDirection","getScale","getRotation","target","srcEvent","computeIntervalInputData","last","lastInterval","COMPUTE_INTERVAL","velocity","getVelocity","direction","max","velocityX","velocityY","clientX","clientY","abs","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","p1","p2","props","PROPS_XY","sqrt","atan2","PI","start","end","PROPS_CLIENT_XY","MOUSE_ELEMENT_EVENTS","MOUSE_WINDOW_EVENTS","allow","pressed","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","store","pointerEvents","TOUCH_EVENTS","targetIds","normalizeTouches","touchInput","targetTouches","changedTouches","changedTargetTouches","identifier","concat","_handler","touch","mouse","TouchAction","cleanTouchActions","actions","TOUCH_ACTION_NONE","TOUCH_ACTION_PAN_X","TOUCH_ACTION_PAN_Y","replace","action","test","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_AUTO","Recognizer","defaults","state","STATE_FAILED","simultaneous","requireFail","stateStr","STATE_CANCELLED","STATE_ENDED","STATE_CHANGED","STATE_BEGAN","directionStr","getRecognizerByNameIfManager","otherRecognizer","recognizer","AttrRecognizer","PanRecognizer","pX","pY","PinchRecognizer","PressRecognizer","_timer","_input","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","count","recognizers","setupRecognizers","Manager","handlers","touchAction","toggleCssProps","item","add","recognizeWith","requireFailure","cssProps","name","falseFn","userSelect","onselectstart","userDrag","ondragstart","triggerDomEvent","event","data","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","TYPE_UNDEFINED","MOBILE_REGEX","navigator","userAgent","INPUT_TYPE_TOUCH","INPUT_TYPE_PEN","INPUT_TYPE_MOUSE","INPUT_TYPE_KINECT","INPUT_MOVE","INPUT_CANCEL","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","destroy","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","mouseout","button","which","relatedTarget","toElement","nodeName","pointerType","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM",2,3,4,5,"MSPointerEvent","removePointer","eventTypeNormalized","toLowerCase","storeIndex","pointerId","splice","TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","touches","inputEvent","inputData","isTouch","isMouse","PREFIXED_TOUCH_ACTION","body","NATIVE_TOUCH_ACTION","TOUCH_ACTION_COMPUTE","compute","update","getTouchAction","preventDefaults","prevented","preventDefault","hasNone","hasPanY","hasPanX","preventSrc","STATE_POSSIBLE","STATE_RECOGNIZED","option","emit","dropRecognizeWith","dropRequireFailure","index","canRecognizeWith","canRecognize","inputDataClone","process","reset","attrTest","optionPointers","isRecognized","isValid","threshold","directionTest","hasMoved","inOut","time","validPointers","validMovement","validTime","clearTimeout","taps","interval","delay","posThreshold","validTouchTime","validInterval","validMultiTap","tapCount","VERSION","domEvents","touchSelect","touchCallout","contentZooming","tapHighlightColor","stop","force","stopped","curRecognizer","existing","remove","events","off","Tap","Pan","Swipe","Pinch","Rotate","Press","__webpack_amd_options__"],"mappings":"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","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/assets/js/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\r\n\t__webpack_require__(2);\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t!function (d, s, id) {\r\n\t    var js, fjs = d.getElementsByTagName(s)[0];\r\n\t    if (!d.getElementById(id)) {\r\n\t        js = d.createElement(s);\r\n\t        js.id = id;\r\n\t        js.src = \"//platform.twitter.com/widgets.js\";\r\n\t        fjs.parentNode.insertBefore(js, fjs);\r\n\t    }\r\n\t}(document, \"script\", \"twitter-wjs\");\r\n\t\r\n\tif(location.href.indexOf(\"eightmedia.github.io\") > -1) {\r\n\t    var _gaq = _gaq || [];\r\n\t    _gaq.push(['_setAccount', 'UA-30289566-1']);\r\n\t    _gaq.push(['_trackPageview']);\r\n\t    (function () {\r\n\t        var ga = document.createElement('script');\r\n\t        ga.type = 'text/javascript';\r\n\t        ga.async = true;\r\n\t        ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';\r\n\t        var s = document.getElementsByTagName('script')[0];\r\n\t        s.parentNode.insertBefore(ga, s);\r\n\t    })();\r\n\t}\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Hammer = __webpack_require__(3);\r\n\t\r\n\t// polyfill\r\n\tvar reqAnimationFrame = (function () {\r\n\t    return window[Hammer.prefixed(window, 'requestAnimationFrame')] || function (callback) {\r\n\t        window.setTimeout(callback, 1000 / 60);\r\n\t    };\r\n\t})();\r\n\t\r\n\tvar el = document.querySelector(\"#hitarea\");\r\n\t\r\n\tvar startX = Math.round((el.parentNode.offsetWidth - el.offsetWidth) / 2);\r\n\tvar startY = Math.round((el.parentNode.offsetHeight - el.offsetHeight) / 2);\r\n\t\r\n\tvar ticking = false;\r\n\tvar transform;\r\n\t\r\n\tvar mc = new Hammer(el);\r\n\t\r\n\tmc.get('pinch').set('enable', true);\r\n\tmc.get('rotate').set('enable', true);\r\n\t\r\n\tmc.on(\"pan\", onPan);\r\n\tmc.on(\"swipe\", onSwipe);\r\n\tmc.on(\"rotate\", onRotate);\r\n\tmc.on(\"pinch\", onPinch);\r\n\tmc.on(\"tap\", onTap);\r\n\tmc.on(\"doubletap\", onDoubleTap);\r\n\tmc.on(\"hold\", onHold);\r\n\t\r\n\tmc.on(\"panstart rotatestart pinchstart\", resetElementStart);\r\n\tmc.on(\"panend rotateend pinchend pancancel rotatecancel pinchcancel\", resetElementEnd);\r\n\t\r\n\tfunction resetElementStart() {\r\n\t    el.className = '';\r\n\t}\r\n\t\r\n\tfunction resetElementEnd() {\r\n\t    transform = {\r\n\t        translate: { x: startX, y: startY },\r\n\t        scale: 1,\r\n\t        rotate: 0\r\n\t    };\r\n\t    el.className = 'animate';\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction updateElementTransform() {\r\n\t    var value = [\r\n\t        'translate3d(' + transform.translate.x + 'px, ' + transform.translate.y + 'px, 0)',\r\n\t        'scale(' + transform.scale + ', ' + transform.scale + ')',\r\n\t        'rotate(' + transform.rotate + 'deg)'];\r\n\t    el.style.webkitTransform = el.style.transform = value.join(\" \");\r\n\t    ticking = false;\r\n\t}\r\n\t\r\n\tfunction requestElementUpdate() {\r\n\t    if(!ticking) {\r\n\t        ticking = true;\r\n\t        reqAnimationFrame(updateElementTransform);\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction onPan(ev) {\r\n\t    transform.translate = {\r\n\t        x: startX + ev.deltaX,\r\n\t        y: startY + ev.deltaY\r\n\t    };\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction onSwipe(ev) {\r\n\t    transform.translate = {\r\n\t        x: startX + (ev.deltaX * 1.2),\r\n\t        y: startY + (ev.deltaY * 1.2)\r\n\t    };\r\n\t    transform.scale = 1.2;\r\n\t    requestElementUpdate();\r\n\t\r\n\t    setTimeout(function () {\r\n\t        resetElementEnd();\r\n\t    }, 400);\r\n\t}\r\n\t\r\n\tfunction onPinch(ev) {\r\n\t    transform.scale = ev.scale;\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction onRotate(ev) {\r\n\t    transform.rotate = ev.rotation;\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction onTap(ev) {\r\n\t    transform.scale = .9;\r\n\t    requestElementUpdate();\r\n\t\r\n\t    setTimeout(function () {\r\n\t        transform.scale = 1;\r\n\t        requestElementUpdate();\r\n\t    }, 200);\r\n\t}\r\n\t\r\n\tfunction onDoubleTap(ev) {\r\n\t    transform.rotate = !transform.rotate ? 360 : 0;\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction onHold(ev) {\r\n\t    el.style.background = '#fd0';\r\n\t    setTimeout(function () {\r\n\t        el.style.background = 'white';\r\n\t        requestElementUpdate();\r\n\t    }, 500);\r\n\t}\r\n\t\r\n\tresetElementEnd();\r\n\t\r\n\tdocument.querySelector(\".device-button\").addEventListener(\"click\", function(){\r\n\t    document.querySelector(\".device\").classList.toggle('hammertime');\r\n\t}, false);\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;(function(window, undefined) {\r\n\t  'use strict';\r\n\t\r\n\tvar VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];\r\n\t\r\n\tvar TYPE_FUNCTION = 'function';\r\n\tvar TYPE_UNDEFINED = 'undefined';\r\n\t\r\n\t/**\r\n\t * walk objects and arrays\r\n\t * @param {Object} obj\r\n\t * @param {Function} iterator\r\n\t * @param {Object} context\r\n\t */\r\n\tfunction each(obj, iterator, context) {\r\n\t    var i, len;\r\n\t\r\n\t    if (!obj) {\r\n\t        return;\r\n\t    }\r\n\t\r\n\t    if (obj.forEach) {\r\n\t        obj.forEach(iterator, context);\r\n\t    } else if (obj.length !== undefined) {\r\n\t        for (i = 0, len = obj.length; i < len; i++) {\r\n\t            iterator.call(context, obj[i], i, obj);\r\n\t        }\r\n\t    } else {\r\n\t        for (i in obj) {\r\n\t            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\t/**\r\n\t * extend object.\r\n\t * means that properties in dest will be overwritten by the ones in src.\r\n\t * @param {Object} dest\r\n\t * @param {Object} src\r\n\t * @param {Boolean} [merge]\r\n\t * @returns {Object} dest\r\n\t */\r\n\tfunction extend(dest, src, merge) {\r\n\t    var keys = Object.keys(src);\r\n\t    for (var i = 0, len = keys.length; i < len; i++) {\r\n\t        if (!merge || (merge && dest[keys[i]] === undefined)) {\r\n\t            dest[keys[i]] = src[keys[i]];\r\n\t        }\r\n\t    }\r\n\t    return dest;\r\n\t}\r\n\t\r\n\t/**\r\n\t * merge the values from src in the dest.\r\n\t * means that properties that exist in dest will not be overwritten by src\r\n\t * @param {Object} dest\r\n\t * @param {Object} src\r\n\t * @returns {Object} dest\r\n\t */\r\n\tfunction merge(dest, src) {\r\n\t    return extend(dest, src, true);\r\n\t}\r\n\t\r\n\t/**\r\n\t * simple class inheritance\r\n\t * @param {Function} child\r\n\t * @param {Function} base\r\n\t * @param {Object} [properties]\r\n\t */\r\n\tfunction inherit(child, base, properties) {\r\n\t    var baseP = base.prototype,\r\n\t        childP;\r\n\t\r\n\t    // object create is supported since IE9\r\n\t    if (Object.create) {\r\n\t        childP = child.prototype = Object.create(baseP);\r\n\t        childP.constructor = child;\r\n\t    } else {\r\n\t        extend(child, base);\r\n\t        var Inherited = function() {\r\n\t            this.constructor = child;\r\n\t        };\r\n\t        Inherited.prototype = baseP;\r\n\t        childP = child.prototype = new Inherited();\r\n\t    }\r\n\t\r\n\t    if (properties) {\r\n\t        extend(childP, properties);\r\n\t    }\r\n\t\r\n\t    childP._super = baseP;\r\n\t}\r\n\t\r\n\t/**\r\n\t * simple function bind\r\n\t * @param {Function} fn\r\n\t * @param {Object} context\r\n\t * @returns {Function}\r\n\t */\r\n\tfunction bindFn(fn, context) {\r\n\t    return function() {\r\n\t        return fn.apply(context, arguments);\r\n\t    };\r\n\t}\r\n\t\r\n\t/**\r\n\t * let a boolean value also be a function that must return a boolean\r\n\t * this first item in args will be used as the context\r\n\t * @param {Boolean|Function} val\r\n\t * @param {Array} [args]\r\n\t * @returns {Boolean}\r\n\t */\r\n\tfunction boolOrFn(val, args) {\r\n\t    if (typeof val == TYPE_FUNCTION) {\r\n\t        return val.apply(args ? args[0] || window : window, args);\r\n\t    }\r\n\t    return val;\r\n\t}\r\n\t\r\n\t/**\r\n\t * addEventListener with multiple events at once\r\n\t * @param {HTMLElement} element\r\n\t * @param {String} types\r\n\t * @param {Function} handler\r\n\t */\r\n\tfunction addEventListeners(element, types, handler) {\r\n\t    each(splitStr(types), function(type) {\r\n\t        element.addEventListener(type, handler, false);\r\n\t    });\r\n\t}\r\n\t\r\n\t/**\r\n\t * removeEventListener with multiple events at once\r\n\t * @param {HTMLElement} element\r\n\t * @param {String} types\r\n\t * @param {Function} handler\r\n\t */\r\n\tfunction removeEventListeners(element, types, handler) {\r\n\t    each(splitStr(types), function(type) {\r\n\t        element.removeEventListener(type, handler, false);\r\n\t    });\r\n\t}\r\n\t\r\n\t/**\r\n\t * find if a node is in the given parent\r\n\t * @method hasParent\r\n\t * @param {HTMLElement} node\r\n\t * @param {HTMLElement} parent\r\n\t * @return {Boolean} found\r\n\t */\r\n\tfunction hasParent(node, parent) {\r\n\t    while (node) {\r\n\t        if (node == parent) {\r\n\t            return true;\r\n\t        }\r\n\t        node = node.parentNode;\r\n\t    }\r\n\t    return false;\r\n\t}\r\n\t\r\n\t/**\r\n\t * store Math.round in a var, for better minimisation\r\n\t */\r\n\tvar round = Math.round;\r\n\t\r\n\t/**\r\n\t * small indexOf wrapper\r\n\t * @param {String} str\r\n\t * @param {String} find\r\n\t * @returns {Boolean} found\r\n\t */\r\n\tfunction inStr(str, find) {\r\n\t    return str.indexOf(find) > -1;\r\n\t}\r\n\t\r\n\t/**\r\n\t * split string on whitespace\r\n\t * @param {String} str\r\n\t * @returns {Array} words\r\n\t */\r\n\tfunction splitStr(str) {\r\n\t    return str.trim().split(/\\s+/g);\r\n\t}\r\n\t\r\n\t/**\r\n\t * find if a array contains the object using indexOf or a simple polyFill\r\n\t * @param {Array} src\r\n\t * @param {String} find\r\n\t * @param {String} [findByKey]\r\n\t * @return {Boolean|Number} false when not found, or the index\r\n\t */\r\n\tfunction inArray(src, find, findByKey) {\r\n\t    if (src.indexOf && !findByKey) {\r\n\t        return src.indexOf(find);\r\n\t    } else {\r\n\t        for (var i = 0, len = src.length; i < len; i++) {\r\n\t            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\r\n\t                return i;\r\n\t            }\r\n\t        }\r\n\t        return -1;\r\n\t    }\r\n\t}\r\n\t\r\n\t/**\r\n\t * convert array-like objects to real arrays\r\n\t * @param {Object} obj\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction toArray(obj) {\r\n\t    return Array.prototype.slice.call(obj, 0);\r\n\t}\r\n\t\r\n\t/**\r\n\t * unique array with objects based on a key (like 'id') or just by the array's value\r\n\t * @param {Array} src [{id:1},{id:2},{id:1}]\r\n\t * @param {String} [key]\r\n\t * @returns {Array} [{id:1},{id:2}]\r\n\t */\r\n\tfunction uniqueArray(src, key) {\r\n\t    var results = [];\r\n\t    var values = [];\r\n\t    for (var i = 0, len = src.length; i < len; i++) {\r\n\t        var val = key ? src[i][key] : src[i];\r\n\t        if (inArray(values, val) < 0) {\r\n\t            results.push(src[i]);\r\n\t        }\r\n\t        values[i] = val;\r\n\t    }\r\n\t    return results;\r\n\t}\r\n\t\r\n\t/**\r\n\t * get the prefixed property\r\n\t * @param {Object} obj\r\n\t * @param {String} property\r\n\t * @returns {String|Undefined} prefixed\r\n\t */\r\n\tfunction prefixed(obj, property) {\r\n\t    var prefix, prop;\r\n\t    var camelProp = property[0].toUpperCase() + property.slice(1);\r\n\t\r\n\t    for (var i = 0, len = VENDOR_PREFIXES.length; i < len; i++) {\r\n\t        prefix = VENDOR_PREFIXES[i];\r\n\t        prop = (prefix) ? prefix + camelProp : property;\r\n\t\r\n\t        if (prop in obj) {\r\n\t            return prop;\r\n\t        }\r\n\t    }\r\n\t    return undefined;\r\n\t}\r\n\t\r\n\t/**\r\n\t * get a unique id\r\n\t * @returns {number} uniqueId\r\n\t */\r\n\tvar _uniqueId = 1;\r\n\tfunction uniqueId() {\r\n\t    return _uniqueId++;\r\n\t}\r\n\t\r\n\tvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\r\n\t\r\n\tvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\r\n\tvar SUPPORT_TOUCH = ('ontouchstart' in window);\r\n\tvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\r\n\t\r\n\tvar INPUT_TYPE_TOUCH = 'touch';\r\n\tvar INPUT_TYPE_PEN = 'pen';\r\n\tvar INPUT_TYPE_MOUSE = 'mouse';\r\n\tvar INPUT_TYPE_KINECT = 'kinect';\r\n\t\r\n\tvar COMPUTE_INTERVAL = 25;\r\n\t\r\n\tvar INPUT_START = 1;\r\n\tvar INPUT_MOVE = 2;\r\n\tvar INPUT_END = 4;\r\n\tvar INPUT_CANCEL = 8;\r\n\t\r\n\tvar DIRECTION_NONE = 1;\r\n\tvar DIRECTION_LEFT = 2;\r\n\tvar DIRECTION_RIGHT = 4;\r\n\tvar DIRECTION_UP = 8;\r\n\tvar DIRECTION_DOWN = 16;\r\n\t\r\n\tvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\r\n\tvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\r\n\tvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\r\n\t\r\n\tvar PROPS_XY = ['x', 'y'];\r\n\tvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\r\n\t\r\n\t/**\r\n\t * create new input type manager\r\n\t * @param {Manager} manager\r\n\t * @param {Function} callback\r\n\t * @returns {Input}\r\n\t * @constructor\r\n\t */\r\n\tfunction Input(manager, callback) {\r\n\t    var self = this;\r\n\t    this.manager = manager;\r\n\t    this.callback = callback;\r\n\t\r\n\t    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\r\n\t    // so when disabled the input events are completely bypassed.\r\n\t    this.domHandler = function(ev) {\r\n\t        if (boolOrFn(self.manager.options.enable, [self.manager])) {\r\n\t            self.handler(ev);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    this.elEvents && addEventListeners(this.manager.element, this.elEvents, this.domHandler);\r\n\t    this.winEvents && addEventListeners(window, this.winEvents, this.domHandler);\r\n\t}\r\n\t\r\n\tInput.prototype = {\r\n\t    /**\r\n\t     * unbind the events\r\n\t     */\r\n\t    destroy: function() {\r\n\t        this.elEvents && removeEventListeners(this.manager.element, this.elEvents, this.domHandler);\r\n\t        this.winEvents && removeEventListeners(window, this.winEvents, this.domHandler);\r\n\t    }\r\n\t};\r\n\t\r\n\t/**\r\n\t * create new input type manager\r\n\t * @param {Hammer} manager\r\n\t * @returns {Input}\r\n\t */\r\n\tfunction createInputInstance(manager) {\r\n\t    var Type;\r\n\t    if (SUPPORT_POINTER_EVENTS) {\r\n\t        Type = PointerEventInput;\r\n\t    } else if (SUPPORT_ONLY_TOUCH) {\r\n\t        Type = TouchInput;\r\n\t    } else if (!SUPPORT_TOUCH) {\r\n\t        Type = MouseInput;\r\n\t    } else {\r\n\t        Type = TouchMouseInput;\r\n\t    }\r\n\t    return new (Type)(manager, inputHandler);\r\n\t}\r\n\t\r\n\t/**\r\n\t * handle input events\r\n\t * @param {Manager} manager\r\n\t * @param {String} eventType\r\n\t * @param {Object} input\r\n\t */\r\n\tfunction inputHandler(manager, eventType, input) {\r\n\t    var pointersLen = input.pointers.length;\r\n\t    var changedPointersLen = input.changedPointers.length;\r\n\t    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\r\n\t    var isFinal = (eventType & INPUT_END && (pointersLen - changedPointersLen === 0));\r\n\t\r\n\t    input.isFirst = isFirst;\r\n\t    input.isFinal = isFinal;\r\n\t\r\n\t    if (isFirst) {\r\n\t        manager.session = {};\r\n\t    }\r\n\t    // source event is the normalized value of the domEvents\r\n\t    // like 'touchstart, mouseup, pointerdown'\r\n\t    input.eventType = eventType;\r\n\t\r\n\t    // compute scale, rotation etc\r\n\t    computeInputData(manager, input);\r\n\t\r\n\t    manager.recognize(input);\r\n\t}\r\n\t\r\n\t/**\r\n\t * extend the data with some usable properties like scale, rotate, velocity etc\r\n\t * @param {Object} manager\r\n\t * @param {Object} input\r\n\t */\r\n\tfunction computeInputData(manager, input) {\r\n\t    var session = manager.session;\r\n\t    var pointers = input.pointers;\r\n\t    var pointersLength = pointers.length;\r\n\t\r\n\t    // store the first input to calculate the distance and direction\r\n\t    if (!session.firstInput) {\r\n\t        session.firstInput = simpleCloneInputData(input);\r\n\t    }\r\n\t\r\n\t    // to compute scale and rotation we need to store the multiple touches\r\n\t    if (pointersLength > 1 && !session.firstMultiple) {\r\n\t        session.firstMultiple = simpleCloneInputData(input);\r\n\t    } else if (pointersLength === 1) {\r\n\t        session.firstMultiple = false;\r\n\t    }\r\n\t\r\n\t    var firstInput = session.firstInput;\r\n\t    var firstMultiple = session.firstMultiple;\r\n\t    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\r\n\t    var center = getCenter(pointers);\r\n\t\r\n\t    input.timeStamp = Date.now();//input.srcEvent.timeStamp;\r\n\t    input.deltaTime = input.timeStamp - firstInput.timeStamp;\r\n\t    input.deltaX = center.x - offsetCenter.x;\r\n\t    input.deltaY = center.y - offsetCenter.y;\r\n\t\r\n\t    input.center = center;\r\n\t    input.angle = getAngle(offsetCenter, center);\r\n\t    input.distance = getDistance(offsetCenter, center);\r\n\t    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\r\n\t\r\n\t    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\r\n\t    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\r\n\t\r\n\t    // find the correct target\r\n\t    var target = manager.element;\r\n\t    if (hasParent(input.srcEvent.target, target)) {\r\n\t        target = input.srcEvent.target;\r\n\t    }\r\n\t    input.target = target;\r\n\t\r\n\t    computeIntervalInputData(session, input);\r\n\t}\r\n\t\r\n\t/**\r\n\t * velocity is calculated every x ms\r\n\t * @param {Object} session\r\n\t * @param {Object} input\r\n\t */\r\n\tfunction computeIntervalInputData(session, input) {\r\n\t    var last = session.lastInterval;\r\n\t    if (!last) {\r\n\t        last = session.lastInterval = simpleCloneInputData(input);\r\n\t    }\r\n\t\r\n\t    var deltaTime = input.timeStamp - last.timeStamp;\r\n\t    if (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined) {\r\n\t        var deltaX = last.deltaX - input.deltaX;\r\n\t        var deltaY = last.deltaY - input.deltaY;\r\n\t\r\n\t        last = session.lastInterval = simpleCloneInputData(input);\r\n\t        last.velocity = getVelocity(deltaTime, deltaX, deltaY);\r\n\t        last.direction = getDirection(deltaX, deltaY);\r\n\t    }\r\n\t\r\n\t    var velocity = last.velocity;\r\n\t    input.velocity = Math.max(velocity.x, velocity.y);\r\n\t    input.velocityX = velocity.x;\r\n\t    input.velocityY = velocity.y;\r\n\t\r\n\t    input.direction = last.direction;\r\n\t}\r\n\t\r\n\t/**\r\n\t * create a simple clone from the input used for storage of firstInput and firstMultiple\r\n\t * @param {Object} input\r\n\t * @returns {Object} clonedInputData\r\n\t */\r\n\tfunction simpleCloneInputData(input) {\r\n\t    // make a simple copy of the pointers because we will get a reference if we don't\r\n\t    // we only need clientXY for the calculations\r\n\t    var pointers = [];\r\n\t    for (var i = 0; i < input.pointers.length; i++) {\r\n\t        pointers[i] = {\r\n\t            clientX: round(input.pointers[i].clientX),\r\n\t            clientY: round(input.pointers[i].clientY)\r\n\t        };\r\n\t    }\r\n\t\r\n\t    return {\r\n\t        timeStamp: Date.now(),\r\n\t        pointers: pointers,\r\n\t        center: getCenter(pointers),\r\n\t        deltaX: input.deltaX,\r\n\t        deltaY: input.deltaY\r\n\t    };\r\n\t}\r\n\t\r\n\t/**\r\n\t * get the center of all the pointers\r\n\t * @param {Array} pointers\r\n\t * @return {Object} center contains `x` and `y` properties\r\n\t */\r\n\tfunction getCenter(pointers) {\r\n\t    var pointersLength = pointers.length;\r\n\t\r\n\t    // no need to loop when only one touch\r\n\t    if (pointersLength === 1) {\r\n\t        return {\r\n\t            x: round(pointers[0].clientX),\r\n\t            y: round(pointers[0].clientY)\r\n\t        };\r\n\t    }\r\n\t\r\n\t    var x = 0, y = 0;\r\n\t    for (var i = 0; i < pointersLength; i++) {\r\n\t        x += pointers[i].clientX;\r\n\t        y += pointers[i].clientY;\r\n\t    }\r\n\t\r\n\t    return {\r\n\t        x: round(x / pointersLength),\r\n\t        y: round(y / pointersLength)\r\n\t    };\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the velocity between two points. unit is in px per ms.\r\n\t * @param {Number} deltaTime\r\n\t * @param {Number} x\r\n\t * @param {Number} y\r\n\t * @return {Object} velocity `x` and `y`\r\n\t */\r\n\tfunction getVelocity(deltaTime, x, y) {\r\n\t    return {\r\n\t        x: Math.abs(x / deltaTime) || 0,\r\n\t        y: Math.abs(y / deltaTime) || 0\r\n\t    };\r\n\t}\r\n\t\r\n\t/**\r\n\t * get the direction between two points\r\n\t * @param {Number} x\r\n\t * @param {Number} y\r\n\t * @return {Number} direction\r\n\t */\r\n\tfunction getDirection(x, y) {\r\n\t    if (x === y) {\r\n\t        return DIRECTION_NONE;\r\n\t    }\r\n\t\r\n\t    if (Math.abs(x) >= Math.abs(y)) {\r\n\t        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n\t    }\r\n\t    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the absolute distance between two points\r\n\t * @param {Object} p1 {x, y}\r\n\t * @param {Object} p2 {x, y}\r\n\t * @param {Array} [props] containing x and y keys\r\n\t * @return {Number} distance\r\n\t */\r\n\tfunction getDistance(p1, p2, props) {\r\n\t    if (!props) {\r\n\t        props = PROPS_XY;\r\n\t    }\r\n\t    var x = p2[props[0]] - p1[props[0]],\r\n\t        y = p2[props[1]] - p1[props[1]];\r\n\t\r\n\t    return Math.sqrt((x * x) + (y * y));\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the angle between two coordinates\r\n\t * @param {Object} p1\r\n\t * @param {Object} p2\r\n\t * @param {Array} [props] containing x and y keys\r\n\t * @return {Number} angle\r\n\t */\r\n\tfunction getAngle(p1, p2, props) {\r\n\t    if (!props) {\r\n\t        props = PROPS_XY;\r\n\t    }\r\n\t    var x = p2[props[0]] - p1[props[0]],\r\n\t        y = p2[props[1]] - p1[props[1]];\r\n\t    return Math.atan2(y, x) * 180 / Math.PI;\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the rotation degrees between two pointersets\r\n\t * @param {Array} start array of pointers\r\n\t * @param {Array} end array of pointers\r\n\t * @return {Number} rotation\r\n\t */\r\n\tfunction getRotation(start, end) {\r\n\t    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the scale factor between two pointersets\r\n\t * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\r\n\t * @param {Array} start array of pointers\r\n\t * @param {Array} end array of pointers\r\n\t * @return {Number} scale\r\n\t */\r\n\tfunction getScale(start, end) {\r\n\t    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\r\n\t}\r\n\t\r\n\tvar MOUSE_INPUT_MAP = {\r\n\t    mousedown: INPUT_START,\r\n\t    mousemove: INPUT_MOVE,\r\n\t    mouseup: INPUT_END,\r\n\t    mouseout: INPUT_CANCEL\r\n\t};\r\n\t\r\n\tvar MOUSE_ELEMENT_EVENTS = 'mousedown';\r\n\tvar MOUSE_WINDOW_EVENTS = 'mousemove mouseout mouseup';\r\n\t\r\n\t/**\r\n\t * Mouse events input\r\n\t * @constructor\r\n\t */\r\n\tfunction MouseInput() {\r\n\t    this.elEvents = MOUSE_ELEMENT_EVENTS;\r\n\t    this.winEvents = MOUSE_WINDOW_EVENTS;\r\n\t\r\n\t    this.allow = true; // used by Input.TouchMouse to disable mouse events\r\n\t    this.pressed = false; // mousedown state\r\n\t\r\n\t    Input.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(MouseInput, Input, {\r\n\t    /**\r\n\t     * handle mouse events\r\n\t     * @param {Object} ev\r\n\t     */\r\n\t    handler: function(ev) {\r\n\t        var eventType = MOUSE_INPUT_MAP[ev.type];\r\n\t\r\n\t        // on start we want to have the left mouse button down\r\n\t        if (eventType & INPUT_START && ev.button === 0) {\r\n\t            this.pressed = true;\r\n\t        }\r\n\t\r\n\t        if (eventType & INPUT_MOVE && ev.which !== 1) {\r\n\t            eventType = INPUT_END;\r\n\t        }\r\n\t\r\n\t        // mouse must be down, and mouse events are allowed (see the TouchMouse input)\r\n\t        if (!this.pressed || !this.allow) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        // out of the window?\r\n\t        var target = ev.relatedTarget || ev.toElement || ev.target;\r\n\t        if (ev.type == 'mouseout' && target.nodeName != 'HTML') {\r\n\t            eventType = INPUT_MOVE;\r\n\t        }\r\n\t\r\n\t        if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n\t            this.pressed = false;\r\n\t        }\r\n\t\r\n\t        this.callback(this.manager, eventType, {\r\n\t            pointers: [ev],\r\n\t            changedPointers: [ev],\r\n\t            pointerType: INPUT_TYPE_MOUSE,\r\n\t            srcEvent: ev\r\n\t        });\r\n\t    },\r\n\t});\r\n\t\r\n\tvar POINTER_INPUT_MAP = {\r\n\t    pointerdown: INPUT_START,\r\n\t    pointermove: INPUT_MOVE,\r\n\t    pointerup: INPUT_END,\r\n\t    pointercancel: INPUT_CANCEL,\r\n\t    pointerout: INPUT_CANCEL\r\n\t};\r\n\t\r\n\t// in IE10 the pointer types is defined as an enum\r\n\tvar IE10_POINTER_TYPE_ENUM = {\r\n\t    2: INPUT_TYPE_TOUCH,\r\n\t    3: INPUT_TYPE_PEN,\r\n\t    4: INPUT_TYPE_MOUSE,\r\n\t    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\r\n\t};\r\n\t\r\n\tvar POINTER_ELEMENT_EVENTS = 'pointerdown pointermove pointerup pointercancel';\r\n\tvar POINTER_WINDOW_EVENTS = 'pointerout';\r\n\t\r\n\t// IE10 has prefixed support, and case-sensitive\r\n\tif (window.MSPointerEvent) {\r\n\t    POINTER_ELEMENT_EVENTS = 'MSPointerDown MSPointerMove MSPointerUp MSPointerCancel';\r\n\t    POINTER_WINDOW_EVENTS = 'MSPointerOut';\r\n\t}\r\n\t\r\n\t/**\r\n\t * Pointer events input\r\n\t * @constructor\r\n\t */\r\n\tfunction PointerEventInput() {\r\n\t    this.elEvents = POINTER_ELEMENT_EVENTS;\r\n\t    this.winEvents = POINTER_WINDOW_EVENTS;\r\n\t\r\n\t    Input.apply(this, arguments);\r\n\t\r\n\t    this.store = (this.manager.session.pointerEvents = []);\r\n\t}\r\n\t\r\n\tinherit(PointerEventInput, Input, {\r\n\t    /**\r\n\t     * handle mouse events\r\n\t     * @param {Object} ev\r\n\t     */\r\n\t    handler: function(ev) {\r\n\t        var store = this.store;\r\n\t        var removePointer = false;\r\n\t\r\n\t        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\r\n\t        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\r\n\t        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\r\n\t\r\n\t        // out of the window?\r\n\t        var target = ev.relatedTarget || ev.toElement || ev.target;\r\n\t        if (eventTypeNormalized == 'pointerout' && target.nodeName != 'HTML') {\r\n\t            eventType = INPUT_MOVE;\r\n\t        }\r\n\t\r\n\t        // start and mouse must be down\r\n\t        if (eventType & INPUT_START && (ev.button === 0 || pointerType == INPUT_TYPE_TOUCH)) {\r\n\t            store.push(ev);\r\n\t        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n\t            removePointer = true;\r\n\t        }\r\n\t\r\n\t        // get index of the event in the store\r\n\t        // it not found, so the pointer hasn't been down (so it's probably a hover)\r\n\t        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\r\n\t        if (storeIndex < 0) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        // update the event in the store\r\n\t        store[storeIndex] = ev;\r\n\t\r\n\t        this.callback(this.manager, eventType, {\r\n\t            pointers: store,\r\n\t            changedPointers: [ev],\r\n\t            pointerType: pointerType,\r\n\t            srcEvent: ev\r\n\t        });\r\n\t\r\n\t        if (removePointer) {\r\n\t            // remove from the store\r\n\t            store.splice(storeIndex, 1);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\tvar TOUCH_INPUT_MAP = {\r\n\t    touchstart: INPUT_START,\r\n\t    touchmove: INPUT_MOVE,\r\n\t    touchend: INPUT_END,\r\n\t    touchcancel: INPUT_CANCEL\r\n\t};\r\n\t\r\n\tvar TOUCH_EVENTS = 'touchstart touchmove touchend touchcancel';\r\n\t\r\n\t/**\r\n\t * Touch events input\r\n\t * @constructor\r\n\t */\r\n\tfunction TouchInput() {\r\n\t    this.elEvents = TOUCH_EVENTS;\r\n\t    this.targetIds = {};\r\n\t\r\n\t    Input.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(TouchInput, Input, {\r\n\t    /**\r\n\t     * handle touch events\r\n\t     * @param {Object} ev\r\n\t     */\r\n\t    handler: function(ev) {\r\n\t        var touches = normalizeTouches(ev, this);\r\n\t        this.callback(this.manager, TOUCH_INPUT_MAP[ev.type], {\r\n\t            pointers: touches[0],\r\n\t            changedPointers: touches[1],\r\n\t            pointerType: INPUT_TYPE_TOUCH,\r\n\t            srcEvent: ev\r\n\t        });\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * make sure all browsers return the same touches\r\n\t * @param {Object} ev\r\n\t * @param {TouchInput} touchInput\r\n\t * @returns {Array} [all, changed]\r\n\t */\r\n\tfunction normalizeTouches(ev, touchInput) {\r\n\t    var i, len;\r\n\t\r\n\t    var targetIds = touchInput.targetIds;\r\n\t    var targetTouches = toArray(ev.targetTouches);\r\n\t    var changedTouches = toArray(ev.changedTouches);\r\n\t    var changedTargetTouches = [];\r\n\t\r\n\t    // collect touches\r\n\t    if (ev.type == 'touchstart') {\r\n\t        for (i = 0, len = targetTouches.length; i < len; i++) {\r\n\t            targetIds[targetTouches[i].identifier] = true;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    // filter changed touches to only contain touches that exist in the collected target ids\r\n\t    for (i = 0, len = changedTouches.length; i < len; i++) {\r\n\t        if (targetIds[changedTouches[i].identifier]) {\r\n\t            changedTargetTouches.push(changedTouches[i]);\r\n\t        }\r\n\t\r\n\t        // cleanup removed touches\r\n\t        if (ev.type == 'touchend'|| ev.type == 'touchcancel') {\r\n\t            delete targetIds[changedTouches[i].identifier];\r\n\t        }\r\n\t    }\r\n\t\r\n\t    return [\r\n\t        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\r\n\t        // also removed the duplicates\r\n\t        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier'),\r\n\t\r\n\t        // only the changed :-)\r\n\t        changedTargetTouches\r\n\t    ];\r\n\t}\r\n\t\r\n\t/**\r\n\t * Combined touch and mouse input\r\n\t *\r\n\t * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\r\n\t * This because touch devices also emit mouse events while doing a touch.\r\n\t *\r\n\t * @constructor\r\n\t */\r\n\tfunction TouchMouseInput() {\r\n\t    Input.apply(this, arguments);\r\n\t\r\n\t    this._handler = bindFn(this.handler, this);\r\n\t    this.touch = new TouchInput(this.manager, this._handler);\r\n\t    this.mouse = new MouseInput(this.manager, this._handler);\r\n\t}\r\n\t\r\n\tinherit(TouchMouseInput, Input, {\r\n\t    /**\r\n\t     * handle mouse and touch events\r\n\t     * @param {Hammer} manager\r\n\t     * @param {String} inputEvent\r\n\t     * @param {Object} inputData\r\n\t     */\r\n\t    handler: function(manager, inputEvent, inputData) {\r\n\t        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\r\n\t            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\r\n\t\r\n\t        // when we're in a touch event, so  block all upcoming mouse events\r\n\t        // most mobile browser also emit mouseevents, right after touchstart\r\n\t        if (isTouch) {\r\n\t            this.mouse.allow = false;\r\n\t        } else if (isMouse && !this.mouse.allow) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        // reset the allowMouse when we're done\r\n\t        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {\r\n\t            this.mouse.allow = true;\r\n\t        }\r\n\t\r\n\t        this.callback(manager, inputEvent, inputData);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * remove the event listeners\r\n\t     */\r\n\t    destroy: function() {\r\n\t        this.touch.destroy();\r\n\t        this.mouse.destroy();\r\n\t    }\r\n\t});\r\n\t\r\n\tvar PREFIXED_TOUCH_ACTION = prefixed(document.body.style, 'touchAction');\r\n\tvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\r\n\t\r\n\t// magical touchAction value\r\n\tvar TOUCH_ACTION_COMPUTE = 'compute';\r\n\t\r\n\tvar TOUCH_ACTION_AUTO = 'auto';\r\n\tvar TOUCH_ACTION_MANIPULATION = 'manipulation';\r\n\tvar TOUCH_ACTION_NONE = 'none';\r\n\tvar TOUCH_ACTION_PAN_X = 'pan-x';\r\n\tvar TOUCH_ACTION_PAN_Y = 'pan-y';\r\n\t\r\n\t/**\r\n\t * Touch Action\r\n\t * sets the touchAction property or uses the js alternative\r\n\t * @param {Manager} manager\r\n\t * @param {String} value\r\n\t * @constructor\r\n\t */\r\n\tfunction TouchAction(manager, value) {\r\n\t    this.manager = manager;\r\n\t    this.set(value);\r\n\t}\r\n\t\r\n\tTouchAction.prototype = {\r\n\t    /**\r\n\t     * set the touchAction value on the element or enable the polyfill\r\n\t     * @param {String} value\r\n\t     */\r\n\t    set: function(value) {\r\n\t        // find out the touch-action by the event handlers\r\n\t        if (value == TOUCH_ACTION_COMPUTE) {\r\n\t            value = this.compute();\r\n\t        }\r\n\t\r\n\t        if (NATIVE_TOUCH_ACTION) {\r\n\t            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\r\n\t        }\r\n\t        this.actions = value.toLowerCase();\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * just re-set the touchAction value\r\n\t     */\r\n\t    update: function() {\r\n\t        this.set(this.manager.options.touchAction);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * compute the value for the touchAction property based on the recognizer's settings\r\n\t     * @returns {String} value\r\n\t     */\r\n\t    compute: function() {\r\n\t        var value;\r\n\t        var actions = [];\r\n\t\r\n\t        each(this.manager.recognizers, function(recognizer) {\r\n\t            if (boolOrFn(recognizer.options.enable, recognizer)) {\r\n\t                actions = actions.concat(recognizer.getTouchAction());\r\n\t            }\r\n\t        });\r\n\t        value = uniqueArray(actions).join(' ');\r\n\t        return cleanTouchActions(value);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * this method is called on each input cycle and provides the preventing of the browser behavior\r\n\t     * @param {Object} input\r\n\t     */\r\n\t    preventDefaults: function(input) {\r\n\t        // not needed with native support for the touchAction property\r\n\t        if (NATIVE_TOUCH_ACTION) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var srcEvent = input.srcEvent;\r\n\t        var direction = input.offsetDirection;\r\n\t\r\n\t        // if the touch action did prevented once this session\r\n\t        if (this.manager.session.prevented) {\r\n\t            srcEvent.preventDefault();\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var actions = this.actions;\r\n\t        var hasNone = inStr(actions, TOUCH_ACTION_NONE);\r\n\t        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\r\n\t        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\r\n\t\r\n\t        if (hasNone || (hasPanY && hasPanX) ||\r\n\t            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\r\n\t            (hasPanX && direction & DIRECTION_VERTICAL)) {\r\n\t            return this.preventSrc(srcEvent);\r\n\t        }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\r\n\t     * @param {Object} srcEvent\r\n\t     */\r\n\t    preventSrc: function(srcEvent) {\r\n\t        this.manager.session.prevented = true;\r\n\t        srcEvent.preventDefault();\r\n\t    }\r\n\t};\r\n\t\r\n\t/**\r\n\t * when the touchActions are collected they are not a valid value, so we need to clean things up. *\r\n\t * @param {String} actions\r\n\t * @returns {*}\r\n\t */\r\n\tfunction cleanTouchActions(actions) {\r\n\t    // none\r\n\t    if (inStr(actions, TOUCH_ACTION_NONE)) {\r\n\t        return TOUCH_ACTION_NONE;\r\n\t    }\r\n\t    // pan-x and pan-y can be combined\r\n\t    if (inStr(actions, TOUCH_ACTION_PAN_X) || inStr(actions, TOUCH_ACTION_PAN_Y)) {\r\n\t        return actions.replace(/[\\-\\w]+/g, function(action) {\r\n\t            if (/^pan\\-/.test(action)) {\r\n\t                return action;\r\n\t            }\r\n\t            return '';\r\n\t        });\r\n\t    }\r\n\t    // manipulation\r\n\t    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\r\n\t        return TOUCH_ACTION_MANIPULATION;\r\n\t    }\r\n\t\r\n\t    return TOUCH_ACTION_AUTO;\r\n\t}\r\n\t\r\n\tvar STATE_POSSIBLE = 1;\r\n\tvar STATE_BEGAN = 2;\r\n\tvar STATE_CHANGED = 4;\r\n\tvar STATE_ENDED = 8;\r\n\tvar STATE_RECOGNIZED = STATE_ENDED;\r\n\tvar STATE_CANCELLED = 16;\r\n\tvar STATE_FAILED = 32;\r\n\t\r\n\t/**\r\n\t * Recognizer\r\n\t * Every recognizer needs to extend from this class.\r\n\t * @constructor\r\n\t * @param {Object} options\r\n\t */\r\n\tfunction Recognizer(options) {\r\n\t    this.id = uniqueId();\r\n\t\r\n\t    this.manager = null;\r\n\t    this.options = merge(options || {}, this.defaults);\r\n\t\r\n\t    // default is enable true\r\n\t    this.options.enable = (options.enable === undefined) ? true : options.enable;\r\n\t\r\n\t    this.state = STATE_FAILED;\r\n\t\r\n\t    this.simultaneous = {};\r\n\t    this.requireFail = [];\r\n\t}\r\n\t\r\n\tRecognizer.prototype = {\r\n\t    /**\r\n\t     * default settings\r\n\t     */\r\n\t    defaults: {},\r\n\t\r\n\t    /**\r\n\t     * set options\r\n\t     * @param {String} option\r\n\t     * @param {*} val\r\n\t     */\r\n\t    set: function(option, val) {\r\n\t        this.options[option] = val;\r\n\t\r\n\t        // also update the touchAction, in case something changed about the directions/enabled state\r\n\t        this.manager && this.manager.touchAction.update();\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * default emitter\r\n\t     * @param {Object} input\r\n\t     */\r\n\t    emit: function(input) {\r\n\t        this.manager.emit(this.options.event, input); // simple 'eventName' events\r\n\t        this.manager.emit(this.options.event + stateStr(this.state), input); // like 'panmove' and 'panstart'\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * recognize simultaneous with an other recognizer.\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Recognizer} this\r\n\t     */\r\n\t    recognizeWith: function(otherRecognizer) {\r\n\t        var simultaneous = this.simultaneous;\r\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n\t        if (!simultaneous[otherRecognizer.id]) {\r\n\t            simultaneous[otherRecognizer.id] = otherRecognizer;\r\n\t            otherRecognizer.recognizeWith(this);\r\n\t        }\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Recognizer} this\r\n\t     */\r\n\t    dropRecognizeWith: function(otherRecognizer) {\r\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n\t        delete this.simultaneous[otherRecognizer.id];\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * recognizer can only run when an other is failing\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Recognizer} this\r\n\t     */\r\n\t    requireFailure: function(otherRecognizer) {\r\n\t        var requireFail = this.requireFail;\r\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n\t        if (inArray(requireFail, otherRecognizer) === -1) {\r\n\t            requireFail.push(otherRecognizer);\r\n\t            otherRecognizer.requireFailure(this);\r\n\t        }\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * drop the requireFailure link. it does not remove the link on the other recognizer.\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Recognizer} this\r\n\t     */\r\n\t    dropRequireFailure: function(otherRecognizer) {\r\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n\t        var index = inArray(this.requireFail, otherRecognizer);\r\n\t        if (index > -1) {\r\n\t            this.requireFail.splice(index, 1);\r\n\t        }\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * if the recognizer can recognize simultaneous with an other recognizer\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Boolean}\r\n\t     */\r\n\t    canRecognizeWith: function(otherRecognizer) {\r\n\t        return !!this.simultaneous[otherRecognizer.id];\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * update the recognizer\r\n\t     * @param {Object} inputData\r\n\t     */\r\n\t    recognize: function(inputData) {\r\n\t        // require failure of other recognizers\r\n\t        var canRecognize = true;\r\n\t        for (var i = 0; i < this.requireFail.length; i++) {\r\n\t            if (!(this.requireFail[i].state & STATE_FAILED)) {\r\n\t                canRecognize = false;\r\n\t                break;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        // make a new copy of the inputData\r\n\t        // so we can change the inputData without messing up the other recognizers\r\n\t        var inputDataClone = extend({}, inputData);\r\n\t\r\n\t        // is is enabled and allow recognizing?\r\n\t        if (!canRecognize || !boolOrFn(this.options.enable, [this, inputDataClone])) {\r\n\t            this.reset();\r\n\t            this.state = STATE_FAILED;\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        // reset when we've reached the end\r\n\t        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\r\n\t            this.state = STATE_POSSIBLE;\r\n\t        }\r\n\t\r\n\t        this.state = this.process(inputDataClone);\r\n\t\r\n\t        // the recognizer has recognized a gesture\r\n\t        // so trigger an event\r\n\t        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\r\n\t            this.emit(inputDataClone);\r\n\t        }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * return the state of the recognizer\r\n\t     * the actual recognizing happens in this method\r\n\t     * @virtual\r\n\t     * @param {Object} inputData\r\n\t     * @returns {Const} STATE_*\r\n\t     */\r\n\t    process: function(inputData) { }, // jshint ignore:line\r\n\t\r\n\t    /**\r\n\t     * return the preferred touch-action\r\n\t     * @virtual\r\n\t     * @returns {Array}\r\n\t     */\r\n\t    getTouchAction: function() { },\r\n\t\r\n\t    /**\r\n\t     * called when the gesture isn't allowed to recognize\r\n\t     * like when another is being recognized or it is disabled\r\n\t     * @virtual\r\n\t     */\r\n\t    reset: function() { }\r\n\t};\r\n\t\r\n\t/**\r\n\t * get a usable string, used as event postfix\r\n\t * @param {Const} state\r\n\t * @returns {String} state\r\n\t */\r\n\tfunction stateStr(state) {\r\n\t    if (state & STATE_CANCELLED) {\r\n\t        return 'cancel';\r\n\t    } else if (state & STATE_ENDED) {\r\n\t        return 'end';\r\n\t    } else if (state & STATE_CHANGED) {\r\n\t        return 'move';\r\n\t    } else if (state & STATE_BEGAN) {\r\n\t        return 'start';\r\n\t    }\r\n\t    return '';\r\n\t}\r\n\t\r\n\t/**\r\n\t * direction cons to string\r\n\t * @param {Const} direction\r\n\t * @returns {String}\r\n\t */\r\n\tfunction directionStr(direction) {\r\n\t    if (direction == DIRECTION_DOWN) {\r\n\t        return 'down';\r\n\t    } else if (direction == DIRECTION_UP) {\r\n\t        return 'up';\r\n\t    } else if (direction == DIRECTION_LEFT) {\r\n\t        return 'left';\r\n\t    } else if (direction == DIRECTION_RIGHT) {\r\n\t        return 'right';\r\n\t    }\r\n\t    return '';\r\n\t}\r\n\t\r\n\t/**\r\n\t * get a recognizer by name if it is bound to a manager\r\n\t * @param {Recognizer|String} otherRecognizer\r\n\t * @param {Recognizer} recognizer\r\n\t * @returns {Recognizer}\r\n\t */\r\n\tfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\r\n\t    var manager = recognizer.manager;\r\n\t    if (manager) {\r\n\t        return manager.get(otherRecognizer);\r\n\t    }\r\n\t    return otherRecognizer;\r\n\t}\r\n\t\r\n\t/**\r\n\t * this recognizer is just used as a base for the simple\r\n\t * pan, pinch, rotate and swipe recognizers\r\n\t * @constructor\r\n\t */\r\n\tfunction AttrRecognizer() {\r\n\t    Recognizer.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(AttrRecognizer, Recognizer, {\r\n\t    defaults: {\r\n\t        pointers: 1\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * used to check if it the recognizer receives valid input, like input.distance > 10\r\n\t     * this should be overwritten\r\n\t     * @virtual\r\n\t     * @param {Object} input\r\n\t     * @returns {Boolean} recognized\r\n\t     */\r\n\t    attrTest: function(input) {\r\n\t        var optionPointers = this.options.pointers;\r\n\t        return optionPointers === 0 || input.pointers.length === optionPointers;\r\n\t    },\r\n\t\r\n\t    process: function(input) {\r\n\t        var state = this.state;\r\n\t        var eventType = input.eventType;\r\n\t\r\n\t        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\r\n\t        var isValid = this.attrTest(input);\r\n\t\r\n\t        // on cancel input and we've recognized before, return STATE_CANCELLED\r\n\t        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\r\n\t            return state | STATE_CANCELLED;\r\n\t        } else if (isRecognized || isValid) {\r\n\t            if (eventType & INPUT_END) {\r\n\t                return state | STATE_ENDED;\r\n\t            } else if (!(state & STATE_BEGAN)) {\r\n\t                return state | STATE_BEGAN;\r\n\t            }\r\n\t            return state | STATE_CHANGED;\r\n\t        }\r\n\t        return STATE_FAILED;\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Pan\r\n\t * Recognized when the pointer is down and moved in the allowed direction.\r\n\t * @constructor\r\n\t */\r\n\tfunction PanRecognizer() {\r\n\t    AttrRecognizer.apply(this, arguments);\r\n\t\r\n\t    this.pX = null;\r\n\t    this.pY = null;\r\n\t}\r\n\t\r\n\tinherit(PanRecognizer, AttrRecognizer, {\r\n\t    defaults: {\r\n\t        event: 'pan',\r\n\t        threshold: 10,\r\n\t        pointers: 1,\r\n\t        direction: DIRECTION_ALL\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        var direction = this.options.direction;\r\n\t\r\n\t        if (direction === DIRECTION_ALL) {\r\n\t            return [TOUCH_ACTION_NONE];\r\n\t        }\r\n\t\r\n\t        var actions = [];\r\n\t        if (direction & DIRECTION_HORIZONTAL) {\r\n\t            actions.push(TOUCH_ACTION_PAN_Y);\r\n\t        }\r\n\t        if (direction & DIRECTION_VERTICAL) {\r\n\t            actions.push(TOUCH_ACTION_PAN_X);\r\n\t        }\r\n\t        return actions;\r\n\t    },\r\n\t\r\n\t    directionTest: function(input) {\r\n\t        var options = this.options;\r\n\t        var hasMoved = true;\r\n\t        var distance = input.distance;\r\n\t        var direction = input.direction;\r\n\t        var x = input.deltaX;\r\n\t        var y = input.deltaY;\r\n\t\r\n\t        // lock to axis?\r\n\t        if (!(direction & options.direction)) {\r\n\t            if (options.direction & DIRECTION_HORIZONTAL) {\r\n\t                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n\t                hasMoved = x != this.pX;\r\n\t                distance = Math.abs(input.deltaX);\r\n\t            } else {\r\n\t                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\r\n\t                hasMoved = y != this.pY;\r\n\t                distance = Math.abs(input.deltaY);\r\n\t            }\r\n\t        }\r\n\t        input.direction = direction;\r\n\t        return hasMoved && distance > options.threshold && direction & options.direction;\r\n\t    },\r\n\t\r\n\t    attrTest: function(input) {\r\n\t        return AttrRecognizer.prototype.attrTest.call(this, input) &&\r\n\t            this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input));\r\n\t    },\r\n\t\r\n\t    emit: function(input) {\r\n\t        this.pX = input.deltaX;\r\n\t        this.pY = input.deltaY;\r\n\t\r\n\t        this._super.emit.call(this, input);\r\n\t\r\n\t        var direction = directionStr(input.direction);\r\n\t        if (direction) {\r\n\t            this.manager.emit(this.options.event + direction, input);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Pinch\r\n\t * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\r\n\t * @constructor\r\n\t */\r\n\tfunction PinchRecognizer() {\r\n\t    AttrRecognizer.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(PinchRecognizer, AttrRecognizer, {\r\n\t    defaults: {\r\n\t        event: 'pinch',\r\n\t        threshold: 0,\r\n\t        pointers: 2\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return [TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y];\r\n\t    },\r\n\t\r\n\t    attrTest: function(input) {\r\n\t        return this._super.attrTest.call(this, input) &&\r\n\t            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\r\n\t    },\r\n\t\r\n\t    emit: function(input) {\r\n\t        this._super.emit.call(this, input);\r\n\t        if (input.scale !== 1) {\r\n\t            var inOut = input.scale < 1 ? 'in' : 'out';\r\n\t            this.manager.emit(this.options.event + inOut, input);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Press\r\n\t * Recognized when the pointer is down for x ms without any movement.\r\n\t * @constructor\r\n\t */\r\n\tfunction PressRecognizer() {\r\n\t    Recognizer.apply(this, arguments);\r\n\t\r\n\t    this._timer = null;\r\n\t    this._input = null;\r\n\t}\r\n\t\r\n\tinherit(PressRecognizer, Recognizer, {\r\n\t    defaults: {\r\n\t        event: 'press',\r\n\t        pointers: 1,\r\n\t        time: 500, // minimal time of the pointer to be pressed\r\n\t        threshold: 5 // a minimal movement is ok, but keep it low\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return [TOUCH_ACTION_AUTO];\r\n\t    },\r\n\t\r\n\t    process: function(input) {\r\n\t        var options = this.options;\r\n\t\r\n\t        var validPointers = input.pointers.length === options.pointers;\r\n\t        var validMovement = input.distance < options.threshold;\r\n\t        var validTime = input.deltaTime > options.time;\r\n\t\r\n\t        this._input = input;\r\n\t\r\n\t        // we only allow little movement\r\n\t        // and we've reached an end event, so a tap is possible\r\n\t        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\r\n\t            this.reset();\r\n\t        } else if (input.eventType & INPUT_START) {\r\n\t            this.reset();\r\n\t            this._timer = setTimeout(bindFn(this.emit, this), options.time);\r\n\t        }\r\n\t        return STATE_FAILED;\r\n\t    },\r\n\t\r\n\t    reset: function() {\r\n\t        clearTimeout(this._timer);\r\n\t        this._timer = null;\r\n\t    },\r\n\t\r\n\t    emit: function() {\r\n\t        this._input.timeStamp = Date.now();\r\n\t        this.manager.emit(this.options.event, this._input);\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Rotate\r\n\t * Recognized when two or more pointer are moving in a circular motion.\r\n\t * @constructor\r\n\t */\r\n\tfunction RotateRecognizer() {\r\n\t    AttrRecognizer.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(RotateRecognizer, AttrRecognizer, {\r\n\t    defaults: {\r\n\t        event: 'rotate',\r\n\t        threshold: 0,\r\n\t        pointers: 2\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return [TOUCH_ACTION_NONE];\r\n\t    },\r\n\t\r\n\t    attrTest: function(input) {\r\n\t        return this._super.attrTest.call(this, input) &&\r\n\t            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Swipe\r\n\t * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\r\n\t * @constructor\r\n\t */\r\n\tfunction SwipeRecognizer() {\r\n\t    AttrRecognizer.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(SwipeRecognizer, AttrRecognizer, {\r\n\t    defaults: {\r\n\t        event: 'swipe',\r\n\t        threshold: 10,\r\n\t        velocity: 0.65,\r\n\t        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\r\n\t        pointers: 1\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return PanRecognizer.prototype.getTouchAction.call(this);\r\n\t    },\r\n\t\r\n\t    attrTest: function(input) {\r\n\t        var direction = this.options.direction;\r\n\t        var velocity;\r\n\t\r\n\t        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\r\n\t            velocity = input.velocity;\r\n\t        } else if (direction & DIRECTION_HORIZONTAL) {\r\n\t            velocity = input.velocityX;\r\n\t        } else if (direction & DIRECTION_VERTICAL) {\r\n\t            velocity = input.velocityY;\r\n\t        }\r\n\t\r\n\t        return this._super.attrTest.call(this, input) &&\r\n\t            direction & input.direction &&\r\n\t            velocity > this.options.velocity && input.eventType & INPUT_END;\r\n\t    },\r\n\t\r\n\t    emit: function(input) {\r\n\t        this.manager.emit(this.options.event, input);\r\n\t\r\n\t        var direction = directionStr(input.direction);\r\n\t        if (direction) {\r\n\t            this.manager.emit(this.options.event + direction, input);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Tap\r\n\t * Recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur between the given\r\n\t * interval and position. The delay option can be used to recognize multi-taps without firing a single tap.\r\n\t *\r\n\t * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\r\n\t * multi-taps being recognized.\r\n\t * @constructor\r\n\t */\r\n\tfunction TapRecognizer() {\r\n\t    Recognizer.apply(this, arguments);\r\n\t\r\n\t    // previous time and center,\r\n\t    // used for tap counting\r\n\t    this.pTime = false;\r\n\t    this.pCenter = false;\r\n\t\r\n\t    this._timer = null;\r\n\t    this._input = null;\r\n\t    this.count = 0;\r\n\t}\r\n\t\r\n\tinherit(TapRecognizer, Recognizer, {\r\n\t    defaults: {\r\n\t        event: 'tap',\r\n\t        pointers: 1,\r\n\t        taps: 1,\r\n\t        interval: 300, // max time between the multi-tap taps\r\n\t        delay: 0, // delay after triggering the tap. useful if you don't want to recognize a tap on each touchend\r\n\t        time: 250, // max time of the pointer to be down (like finger on the screen)\r\n\t        threshold: 2, // a minimal movement is ok, but keep it low\r\n\t        posThreshold: 10 // a multi-tap can be a bit off the initial position\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return [TOUCH_ACTION_MANIPULATION];\r\n\t    },\r\n\t\r\n\t    process: function(input) {\r\n\t        var self = this;\r\n\t        var options = this.options;\r\n\t\r\n\t        var validPointers = input.pointers.length === options.pointers;\r\n\t        var validMovement = input.distance < options.threshold;\r\n\t        var validTouchTime = input.deltaTime < options.time;\r\n\t\r\n\t        // we only allow little movement\r\n\t        // and we've reached an end event, so a tap is possible\r\n\t        if (input.eventType & INPUT_END && validMovement && validTouchTime && validPointers) {\r\n\t            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\r\n\t            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\r\n\t\r\n\t            this.pTime = input.timeStamp;\r\n\t            this.pCenter = input.center;\r\n\t\r\n\t            if (!validMultiTap || !validInterval) {\r\n\t                this.count = 1;\r\n\t            } else {\r\n\t                this.count += 1;\r\n\t            }\r\n\t\r\n\t            this._input = input;\r\n\t            this.reset();\r\n\t\r\n\t            // if tap count matches we have recognized it,\r\n\t            // else it has began recognizing...\r\n\t            var tapCount = this.count % options.taps;\r\n\t            if (tapCount === 0) {\r\n\t                if (!options.delay) {\r\n\t                    return STATE_RECOGNIZED;\r\n\t                } else {\r\n\t                    this._timer = setTimeout(function() {\r\n\t                        self.state = STATE_RECOGNIZED;\r\n\t                        self.emit();\r\n\t                    }, options.delay);\r\n\t                    return STATE_BEGAN;\r\n\t                }\r\n\t            }\r\n\t            if (!options.delay) {\r\n\t                return STATE_BEGAN;\r\n\t            }\r\n\t        }\r\n\t        return STATE_FAILED;\r\n\t    },\r\n\t\r\n\t    reset: function() {\r\n\t        clearTimeout(this._timer);\r\n\t    },\r\n\t\r\n\t    emit: function() {\r\n\t        if (this.state == STATE_RECOGNIZED) {\r\n\t            this._input.tapCount = this.count;\r\n\t            this.manager.emit(this.options.event, this._input);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * create an manager with a default set of recognizers\r\n\t * @param {HTMLElement} element\r\n\t * @param {Object} [options]\r\n\t * @constructor\r\n\t */\r\n\tfunction Hammer(element, options) {\r\n\t    options = options || {};\r\n\t    options.recognizers = Hammer.defaults.setupRecognizers;\r\n\t    return new Manager(element, options);\r\n\t}\r\n\t\r\n\tHammer.VERSION = '2.0.0dev';\r\n\t\r\n\tHammer.defaults = {\r\n\t    // when set to true, dom events are being triggered.\r\n\t    // but this is slower and unused by simple implementations, so disabled by default.\r\n\t    domEvents: false,\r\n\t\r\n\t    // this value is used when a touch-action isn't defined on the element.style\r\n\t    touchAction: TOUCH_ACTION_COMPUTE,\r\n\t\r\n\t    // default enabled state\r\n\t    enable: true,\r\n\t\r\n\t    // default recognizer setup when calling Hammer()\r\n\t    // when creating a new manager these will be skipped.\r\n\t    setupRecognizers: [\r\n\t        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\r\n\t        [RotateRecognizer, { enable: false }],\r\n\t        [PinchRecognizer, { enable: false }, ['rotate']],\r\n\t        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],\r\n\t        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\r\n\t        [TapRecognizer],\r\n\t        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\r\n\t        [PressRecognizer]\r\n\t    ],\r\n\t\r\n\t    // with some style attributes you can improve the experience.\r\n\t    cssProps: {\r\n\t        // Disables text selection to improve the dragging gesture. When the value is `none` it also sets\r\n\t        // `onselectstart=false` for IE9 on the element. Mainly for desktop browsers.\r\n\t        userSelect: 'none',\r\n\t\r\n\t        // Disable the Windows Phone grippers when pressing an element.\r\n\t        touchSelect: 'none',\r\n\t\r\n\t        // Disables the default callout shown when you touch and hold a touch target.\r\n\t        // On iOS, when you touch and hold a touch target such as a link, Safari displays\r\n\t        // a callout containing information about the link. This property allows you to disable that callout.\r\n\t        touchCallout: 'none',\r\n\t\r\n\t        // Specifies whether zooming is enabled. Used by IE10>\r\n\t        contentZooming: 'none',\r\n\t\r\n\t        // Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\r\n\t        userDrag: 'none',\r\n\t\r\n\t        // Overrides the highlight color shown when the user taps a link or a JavaScript\r\n\t        // clickable element in iOS. This property obeys the alpha value, if specified.\r\n\t        tapHighlightColor: 'rgba(0,0,0,0)'\r\n\t    }\r\n\t};\r\n\t\r\n\t/**\r\n\t * Manager\r\n\t * @param {HTMLElement} element\r\n\t * @param {Object} [options]\r\n\t * @constructor\r\n\t */\r\n\tfunction Manager(element, options) {\r\n\t    options = options || {};\r\n\t\r\n\t    this.options = merge(options, Hammer.defaults);\r\n\t\r\n\t    this.handlers = {};\r\n\t    this.session = {};\r\n\t    this.recognizers = [];\r\n\t\r\n\t    this.element = element;\r\n\t    this.input = createInputInstance(this);\r\n\t    this.touchAction = new TouchAction(this, this.options.touchAction);\r\n\t\r\n\t    toggleCssProps(this, true);\r\n\t\r\n\t    each(options.recognizers, function(item) {\r\n\t        var recognizer = this.add(new (item[0])(item[1]));\r\n\t        item[2] && each(item[2], recognizer.recognizeWith, recognizer);\r\n\t        item[3] && each(item[3], recognizer.requireFailure, recognizer);\r\n\t    }, this);\r\n\t}\r\n\t\r\n\tManager.prototype = {\r\n\t    /**\r\n\t     * set options\r\n\t     * @param {String} option\r\n\t     * @param {*} val\r\n\t     */\r\n\t    set: function(option, val) {\r\n\t        this.options[option] = val;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * stop recognizing for this session.\r\n\t     * This session will be discarded, when a new [input]start event is fired.\r\n\t     * When forced, the recognizer cycle is stopped immediately.\r\n\t     * @param {Boolean} [force]\r\n\t     */\r\n\t    stop: function(force) {\r\n\t        this.session.stopped = force ? 2 : 1;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * run the recognizers!\r\n\t     * called by the inputHandler function\r\n\t     * @param {Object} inputData\r\n\t     */\r\n\t    recognize: function(inputData) {\r\n\t        if (this.session.stopped) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        this.touchAction.preventDefaults(inputData);\r\n\t\r\n\t        var recognizer;\r\n\t        var session = this.session;\r\n\t        var curRecognizer = session.curRecognizer;\r\n\t\r\n\t        // reset when the last recognizer is done, or this is a new session\r\n\t        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\r\n\t            curRecognizer = session.curRecognizer = null;\r\n\t        }\r\n\t\r\n\t        // we're in a active recognizer\r\n\t        for (var i = 0, len = this.recognizers.length; i < len; i++) {\r\n\t            recognizer = this.recognizers[i];\r\n\t\r\n\t            if (this.session.stopped !== 2 && (\r\n\t                    !curRecognizer || recognizer == curRecognizer ||\r\n\t                    recognizer.canRecognizeWith(curRecognizer))) {\r\n\t                recognizer.recognize(inputData);\r\n\t            } else {\r\n\t                recognizer.reset();\r\n\t            }\r\n\t\r\n\t            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\r\n\t                curRecognizer = session.curRecognizer = recognizer;\r\n\t            }\r\n\t        }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * get a recognizer by its event name.\r\n\t     * @param {Recognizer|String} recognizer\r\n\t     * @returns {Recognizer|Null}\r\n\t     */\r\n\t    get: function(recognizer) {\r\n\t        if (recognizer instanceof Recognizer) {\r\n\t            return recognizer;\r\n\t        }\r\n\t\r\n\t        var recognizers = this.recognizers;\r\n\t        for (var i = 0; i < recognizers.length; i++) {\r\n\t            if (recognizers[i].options.event == recognizer) {\r\n\t                return recognizers[i];\r\n\t            }\r\n\t        }\r\n\t        return null;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * add a recognizer to the manager\r\n\t     * existing recognizers with the same event name will be removed\r\n\t     * @param {Recognizer} recognizer\r\n\t     * @returns {Recognizer}\r\n\t     */\r\n\t    add: function(recognizer) {\r\n\t        // remove existing\r\n\t        var existing = this.get(recognizer.options.event);\r\n\t        if (existing) {\r\n\t            this.remove(existing);\r\n\t        }\r\n\t\r\n\t        this.recognizers.push(recognizer);\r\n\t        recognizer.manager = this;\r\n\t\r\n\t        this.touchAction.update();\r\n\t        return recognizer;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * remove a recognizer by name or instance\r\n\t     * @param {Recognizer|String} recognizer\r\n\t     */\r\n\t    remove: function(recognizer) {\r\n\t        var recognizers = this.recognizers;\r\n\t        recognizer = this.get(recognizer);\r\n\t        recognizers.splice(inArray(recognizers, recognizer), 1);\r\n\t\r\n\t        this.touchAction.update();\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * bind event\r\n\t     * @param {String} events\r\n\t     * @param {Function} handler\r\n\t     * @returns {EventEmitter} this\r\n\t     */\r\n\t    on: function(events, handler) {\r\n\t        var handlers = this.handlers;\r\n\t        each(splitStr(events), function(event) {\r\n\t            handlers[event] = handlers[event] || [];\r\n\t            handlers[event].push(handler);\r\n\t        });\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * unbind event, leave emit blank to remove all handlers\r\n\t     * @param {String} events\r\n\t     * @param {Function} [handler]\r\n\t     * @returns {EventEmitter} this\r\n\t     */\r\n\t    off: function(events, handler) {\r\n\t        var handlers = this.handlers;\r\n\t        each(splitStr(events), function(event) {\r\n\t            if (!handler) {\r\n\t                delete handlers[event];\r\n\t            } else {\r\n\t                handlers[event].splice(inArray(handlers[event], handler), 1);\r\n\t            }\r\n\t        });\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * emit event to the listeners\r\n\t     * @param {String} event\r\n\t     * @param {Object} data\r\n\t     */\r\n\t    emit: function(event, data) {\r\n\t        // we also want to trigger dom events\r\n\t        if (this.options.domEvents) {\r\n\t            triggerDomEvent(event, data);\r\n\t        }\r\n\t\r\n\t        // no handlers, so skip it all\r\n\t        var handlers = this.handlers[event];\r\n\t        if (!handlers || !handlers.length) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        data.type = event;\r\n\t        data.preventDefault = function() {\r\n\t            data.srcEvent.preventDefault();\r\n\t        };\r\n\t\r\n\t        for (var i = 0, len = handlers.length; i < len; i++) {\r\n\t            handlers[i](data);\r\n\t        }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * destroy the manager and unbinds all events\r\n\t     * it doesn't unbind dom events, that is the user own responsibility\r\n\t     */\r\n\t    destroy: function() {\r\n\t        toggleCssProps(this, false);\r\n\t\r\n\t        this.handlers = {};\r\n\t        this.session = {};\r\n\t        this.input.destroy();\r\n\t        this.element = null;\r\n\t    }\r\n\t};\r\n\t\r\n\t/**\r\n\t * add/remove the css properties as defined in manager.options.cssProps\r\n\t * @param {Manager} manager\r\n\t * @param {Boolean} add\r\n\t */\r\n\tfunction toggleCssProps(manager, add) {\r\n\t    var element = manager.element;\r\n\t    var cssProps = manager.options.cssProps;\r\n\t\r\n\t    each(cssProps, function(value, name) {\r\n\t        element.style[prefixed(element.style, name)] = add ? value : '';\r\n\t    });\r\n\t\r\n\t    var falseFn = add && function() { return false; };\r\n\t    if (cssProps.userSelect == 'none') { element.onselectstart = falseFn; }\r\n\t    if (cssProps.userDrag == 'none') { element.ondragstart = falseFn; }\r\n\t}\r\n\t\r\n\t/**\r\n\t * trigger dom event\r\n\t * @param {String} event\r\n\t * @param {Object} data\r\n\t */\r\n\tfunction triggerDomEvent(event, data) {\r\n\t    var gestureEvent = document.createEvent('Event');\r\n\t    gestureEvent.initEvent(event, true, true);\r\n\t    gestureEvent.gesture = data;\r\n\t    data.target.dispatchEvent(gestureEvent);\r\n\t}\r\n\t\r\n\tHammer.INPUT_START = INPUT_START;\r\n\tHammer.INPUT_MOVE = INPUT_MOVE;\r\n\tHammer.INPUT_END = INPUT_END;\r\n\tHammer.INPUT_CANCEL = INPUT_CANCEL;\r\n\t\r\n\tHammer.STATE_POSSIBLE = STATE_POSSIBLE;\r\n\tHammer.STATE_BEGAN = STATE_BEGAN;\r\n\tHammer.STATE_CHANGED = STATE_CHANGED;\r\n\tHammer.STATE_ENDED = STATE_ENDED;\r\n\tHammer.STATE_RECOGNIZED = STATE_RECOGNIZED;\r\n\tHammer.STATE_CANCELLED = STATE_CANCELLED;\r\n\tHammer.STATE_FAILED = STATE_FAILED;\r\n\t\r\n\tHammer.DIRECTION_NONE = DIRECTION_NONE;\r\n\tHammer.DIRECTION_LEFT = DIRECTION_LEFT;\r\n\tHammer.DIRECTION_RIGHT = DIRECTION_RIGHT;\r\n\tHammer.DIRECTION_UP = DIRECTION_UP;\r\n\tHammer.DIRECTION_DOWN = DIRECTION_DOWN;\r\n\tHammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\r\n\tHammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;\r\n\tHammer.DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\r\n\t\r\n\tHammer.Manager = Manager;\r\n\tHammer.Input = Input;\r\n\tHammer.TouchAction = TouchAction;\r\n\t\r\n\tHammer.Recognizer = Recognizer;\r\n\tHammer.AttrRecognizer = AttrRecognizer;\r\n\tHammer.Tap = TapRecognizer;\r\n\tHammer.Pan = PanRecognizer;\r\n\tHammer.Swipe = SwipeRecognizer;\r\n\tHammer.Pinch = PinchRecognizer;\r\n\tHammer.Rotate = RotateRecognizer;\r\n\tHammer.Press = PressRecognizer;\r\n\t\r\n\tHammer.on = addEventListeners;\r\n\tHammer.off = removeEventListeners;\r\n\tHammer.each = each;\r\n\tHammer.merge = merge;\r\n\tHammer.extend = extend;\r\n\tHammer.inherit = inherit;\r\n\tHammer.bindFn = bindFn;\r\n\tHammer.prefixed = prefixed;\r\n\t\r\n\tif ('function' == TYPE_FUNCTION && __webpack_require__(4)) {\r\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\r\n\t        return Hammer;\r\n\t    }.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t} else if (typeof module != TYPE_UNDEFINED && module.exports) {\r\n\t    module.exports = Hammer;\r\n\t} else {\r\n\t    window.Hammer = Hammer;\r\n\t}\r\n\t\r\n\t})(window);\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ }\n/******/ ])"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/assets/js/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);","require('./trackers.js');\r\nrequire('./demo.js');\r\n","!function (d, s, id) {\r\n    var js, fjs = d.getElementsByTagName(s)[0];\r\n    if (!d.getElementById(id)) {\r\n        js = d.createElement(s);\r\n        js.id = id;\r\n        js.src = \"//platform.twitter.com/widgets.js\";\r\n        fjs.parentNode.insertBefore(js, fjs);\r\n    }\r\n}(document, \"script\", \"twitter-wjs\");\r\n\r\nif(location.href.indexOf(\"eightmedia.github.io\") > -1) {\r\n    var _gaq = _gaq || [];\r\n    _gaq.push(['_setAccount', 'UA-30289566-1']);\r\n    _gaq.push(['_trackPageview']);\r\n    (function () {\r\n        var ga = document.createElement('script');\r\n        ga.type = 'text/javascript';\r\n        ga.async = true;\r\n        ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';\r\n        var s = document.getElementsByTagName('script')[0];\r\n        s.parentNode.insertBefore(ga, s);\r\n    })();\r\n}\r\n","var Hammer = require('../../../node_modules/hammerjs/hammer.js');\r\n\r\n// polyfill\r\nvar reqAnimationFrame = (function () {\r\n    return window[Hammer.prefixed(window, 'requestAnimationFrame')] || function (callback) {\r\n        window.setTimeout(callback, 1000 / 60);\r\n    };\r\n})();\r\n\r\nvar el = document.querySelector(\"#hitarea\");\r\n\r\nvar startX = Math.round((el.parentNode.offsetWidth - el.offsetWidth) / 2);\r\nvar startY = Math.round((el.parentNode.offsetHeight - el.offsetHeight) / 2);\r\n\r\nvar ticking = false;\r\nvar transform;\r\n\r\nvar mc = new Hammer(el);\r\n\r\nmc.get('pinch').set('enable', true);\r\nmc.get('rotate').set('enable', true);\r\n\r\nmc.on(\"pan\", onPan);\r\nmc.on(\"swipe\", onSwipe);\r\nmc.on(\"rotate\", onRotate);\r\nmc.on(\"pinch\", onPinch);\r\nmc.on(\"tap\", onTap);\r\nmc.on(\"doubletap\", onDoubleTap);\r\nmc.on(\"hold\", onHold);\r\n\r\nmc.on(\"panstart rotatestart pinchstart\", resetElementStart);\r\nmc.on(\"panend rotateend pinchend pancancel rotatecancel pinchcancel\", resetElementEnd);\r\n\r\nfunction resetElementStart() {\r\n    el.className = '';\r\n}\r\n\r\nfunction resetElementEnd() {\r\n    transform = {\r\n        translate: { x: startX, y: startY },\r\n        scale: 1,\r\n        rotate: 0\r\n    };\r\n    el.className = 'animate';\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction updateElementTransform() {\r\n    var value = [\r\n        'translate3d(' + transform.translate.x + 'px, ' + transform.translate.y + 'px, 0)',\r\n        'scale(' + transform.scale + ', ' + transform.scale + ')',\r\n        'rotate(' + transform.rotate + 'deg)'];\r\n    el.style.webkitTransform = el.style.transform = value.join(\" \");\r\n    ticking = false;\r\n}\r\n\r\nfunction requestElementUpdate() {\r\n    if(!ticking) {\r\n        ticking = true;\r\n        reqAnimationFrame(updateElementTransform);\r\n    }\r\n}\r\n\r\nfunction onPan(ev) {\r\n    transform.translate = {\r\n        x: startX + ev.deltaX,\r\n        y: startY + ev.deltaY\r\n    };\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction onSwipe(ev) {\r\n    transform.translate = {\r\n        x: startX + (ev.deltaX * 1.2),\r\n        y: startY + (ev.deltaY * 1.2)\r\n    };\r\n    transform.scale = 1.2;\r\n    requestElementUpdate();\r\n\r\n    setTimeout(function () {\r\n        resetElementEnd();\r\n    }, 400);\r\n}\r\n\r\nfunction onPinch(ev) {\r\n    transform.scale = ev.scale;\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction onRotate(ev) {\r\n    transform.rotate = ev.rotation;\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction onTap(ev) {\r\n    transform.scale = .9;\r\n    requestElementUpdate();\r\n\r\n    setTimeout(function () {\r\n        transform.scale = 1;\r\n        requestElementUpdate();\r\n    }, 200);\r\n}\r\n\r\nfunction onDoubleTap(ev) {\r\n    transform.rotate = !transform.rotate ? 360 : 0;\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction onHold(ev) {\r\n    el.style.background = '#fd0';\r\n    setTimeout(function () {\r\n        el.style.background = 'white';\r\n        requestElementUpdate();\r\n    }, 500);\r\n}\r\n\r\nresetElementEnd();\r\n\r\ndocument.querySelector(\".device-button\").addEventListener(\"click\", function(){\r\n    document.querySelector(\".device\").classList.toggle('hammertime');\r\n}, false);\r\n","(function(window, undefined) {\r\n  'use strict';\r\n\r\nvar VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];\r\n\r\nvar TYPE_FUNCTION = 'function';\r\nvar TYPE_UNDEFINED = 'undefined';\r\n\r\n/**\r\n * walk objects and arrays\r\n * @param {Object} obj\r\n * @param {Function} iterator\r\n * @param {Object} context\r\n */\r\nfunction each(obj, iterator, context) {\r\n    var i, len;\r\n\r\n    if (!obj) {\r\n        return;\r\n    }\r\n\r\n    if (obj.forEach) {\r\n        obj.forEach(iterator, context);\r\n    } else if (obj.length !== undefined) {\r\n        for (i = 0, len = obj.length; i < len; i++) {\r\n            iterator.call(context, obj[i], i, obj);\r\n        }\r\n    } else {\r\n        for (i in obj) {\r\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * extend object.\r\n * means that properties in dest will be overwritten by the ones in src.\r\n * @param {Object} dest\r\n * @param {Object} src\r\n * @param {Boolean} [merge]\r\n * @returns {Object} dest\r\n */\r\nfunction extend(dest, src, merge) {\r\n    var keys = Object.keys(src);\r\n    for (var i = 0, len = keys.length; i < len; i++) {\r\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\r\n            dest[keys[i]] = src[keys[i]];\r\n        }\r\n    }\r\n    return dest;\r\n}\r\n\r\n/**\r\n * merge the values from src in the dest.\r\n * means that properties that exist in dest will not be overwritten by src\r\n * @param {Object} dest\r\n * @param {Object} src\r\n * @returns {Object} dest\r\n */\r\nfunction merge(dest, src) {\r\n    return extend(dest, src, true);\r\n}\r\n\r\n/**\r\n * simple class inheritance\r\n * @param {Function} child\r\n * @param {Function} base\r\n * @param {Object} [properties]\r\n */\r\nfunction inherit(child, base, properties) {\r\n    var baseP = base.prototype,\r\n        childP;\r\n\r\n    // object create is supported since IE9\r\n    if (Object.create) {\r\n        childP = child.prototype = Object.create(baseP);\r\n        childP.constructor = child;\r\n    } else {\r\n        extend(child, base);\r\n        var Inherited = function() {\r\n            this.constructor = child;\r\n        };\r\n        Inherited.prototype = baseP;\r\n        childP = child.prototype = new Inherited();\r\n    }\r\n\r\n    if (properties) {\r\n        extend(childP, properties);\r\n    }\r\n\r\n    childP._super = baseP;\r\n}\r\n\r\n/**\r\n * simple function bind\r\n * @param {Function} fn\r\n * @param {Object} context\r\n * @returns {Function}\r\n */\r\nfunction bindFn(fn, context) {\r\n    return function() {\r\n        return fn.apply(context, arguments);\r\n    };\r\n}\r\n\r\n/**\r\n * let a boolean value also be a function that must return a boolean\r\n * this first item in args will be used as the context\r\n * @param {Boolean|Function} val\r\n * @param {Array} [args]\r\n * @returns {Boolean}\r\n */\r\nfunction boolOrFn(val, args) {\r\n    if (typeof val == TYPE_FUNCTION) {\r\n        return val.apply(args ? args[0] || window : window, args);\r\n    }\r\n    return val;\r\n}\r\n\r\n/**\r\n * addEventListener with multiple events at once\r\n * @param {HTMLElement} element\r\n * @param {String} types\r\n * @param {Function} handler\r\n */\r\nfunction addEventListeners(element, types, handler) {\r\n    each(splitStr(types), function(type) {\r\n        element.addEventListener(type, handler, false);\r\n    });\r\n}\r\n\r\n/**\r\n * removeEventListener with multiple events at once\r\n * @param {HTMLElement} element\r\n * @param {String} types\r\n * @param {Function} handler\r\n */\r\nfunction removeEventListeners(element, types, handler) {\r\n    each(splitStr(types), function(type) {\r\n        element.removeEventListener(type, handler, false);\r\n    });\r\n}\r\n\r\n/**\r\n * find if a node is in the given parent\r\n * @method hasParent\r\n * @param {HTMLElement} node\r\n * @param {HTMLElement} parent\r\n * @return {Boolean} found\r\n */\r\nfunction hasParent(node, parent) {\r\n    while (node) {\r\n        if (node == parent) {\r\n            return true;\r\n        }\r\n        node = node.parentNode;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * store Math.round in a var, for better minimisation\r\n */\r\nvar round = Math.round;\r\n\r\n/**\r\n * small indexOf wrapper\r\n * @param {String} str\r\n * @param {String} find\r\n * @returns {Boolean} found\r\n */\r\nfunction inStr(str, find) {\r\n    return str.indexOf(find) > -1;\r\n}\r\n\r\n/**\r\n * split string on whitespace\r\n * @param {String} str\r\n * @returns {Array} words\r\n */\r\nfunction splitStr(str) {\r\n    return str.trim().split(/\\s+/g);\r\n}\r\n\r\n/**\r\n * find if a array contains the object using indexOf or a simple polyFill\r\n * @param {Array} src\r\n * @param {String} find\r\n * @param {String} [findByKey]\r\n * @return {Boolean|Number} false when not found, or the index\r\n */\r\nfunction inArray(src, find, findByKey) {\r\n    if (src.indexOf && !findByKey) {\r\n        return src.indexOf(find);\r\n    } else {\r\n        for (var i = 0, len = src.length; i < len; i++) {\r\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n\r\n/**\r\n * convert array-like objects to real arrays\r\n * @param {Object} obj\r\n * @returns {Array}\r\n */\r\nfunction toArray(obj) {\r\n    return Array.prototype.slice.call(obj, 0);\r\n}\r\n\r\n/**\r\n * unique array with objects based on a key (like 'id') or just by the array's value\r\n * @param {Array} src [{id:1},{id:2},{id:1}]\r\n * @param {String} [key]\r\n * @returns {Array} [{id:1},{id:2}]\r\n */\r\nfunction uniqueArray(src, key) {\r\n    var results = [];\r\n    var values = [];\r\n    for (var i = 0, len = src.length; i < len; i++) {\r\n        var val = key ? src[i][key] : src[i];\r\n        if (inArray(values, val) < 0) {\r\n            results.push(src[i]);\r\n        }\r\n        values[i] = val;\r\n    }\r\n    return results;\r\n}\r\n\r\n/**\r\n * get the prefixed property\r\n * @param {Object} obj\r\n * @param {String} property\r\n * @returns {String|Undefined} prefixed\r\n */\r\nfunction prefixed(obj, property) {\r\n    var prefix, prop;\r\n    var camelProp = property[0].toUpperCase() + property.slice(1);\r\n\r\n    for (var i = 0, len = VENDOR_PREFIXES.length; i < len; i++) {\r\n        prefix = VENDOR_PREFIXES[i];\r\n        prop = (prefix) ? prefix + camelProp : property;\r\n\r\n        if (prop in obj) {\r\n            return prop;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * get a unique id\r\n * @returns {number} uniqueId\r\n */\r\nvar _uniqueId = 1;\r\nfunction uniqueId() {\r\n    return _uniqueId++;\r\n}\r\n\r\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\r\n\r\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\r\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\r\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\r\n\r\nvar INPUT_TYPE_TOUCH = 'touch';\r\nvar INPUT_TYPE_PEN = 'pen';\r\nvar INPUT_TYPE_MOUSE = 'mouse';\r\nvar INPUT_TYPE_KINECT = 'kinect';\r\n\r\nvar COMPUTE_INTERVAL = 25;\r\n\r\nvar INPUT_START = 1;\r\nvar INPUT_MOVE = 2;\r\nvar INPUT_END = 4;\r\nvar INPUT_CANCEL = 8;\r\n\r\nvar DIRECTION_NONE = 1;\r\nvar DIRECTION_LEFT = 2;\r\nvar DIRECTION_RIGHT = 4;\r\nvar DIRECTION_UP = 8;\r\nvar DIRECTION_DOWN = 16;\r\n\r\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\r\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\r\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\r\n\r\nvar PROPS_XY = ['x', 'y'];\r\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\r\n\r\n/**\r\n * create new input type manager\r\n * @param {Manager} manager\r\n * @param {Function} callback\r\n * @returns {Input}\r\n * @constructor\r\n */\r\nfunction Input(manager, callback) {\r\n    var self = this;\r\n    this.manager = manager;\r\n    this.callback = callback;\r\n\r\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\r\n    // so when disabled the input events are completely bypassed.\r\n    this.domHandler = function(ev) {\r\n        if (boolOrFn(self.manager.options.enable, [self.manager])) {\r\n            self.handler(ev);\r\n        }\r\n    };\r\n\r\n    this.elEvents && addEventListeners(this.manager.element, this.elEvents, this.domHandler);\r\n    this.winEvents && addEventListeners(window, this.winEvents, this.domHandler);\r\n}\r\n\r\nInput.prototype = {\r\n    /**\r\n     * unbind the events\r\n     */\r\n    destroy: function() {\r\n        this.elEvents && removeEventListeners(this.manager.element, this.elEvents, this.domHandler);\r\n        this.winEvents && removeEventListeners(window, this.winEvents, this.domHandler);\r\n    }\r\n};\r\n\r\n/**\r\n * create new input type manager\r\n * @param {Hammer} manager\r\n * @returns {Input}\r\n */\r\nfunction createInputInstance(manager) {\r\n    var Type;\r\n    if (SUPPORT_POINTER_EVENTS) {\r\n        Type = PointerEventInput;\r\n    } else if (SUPPORT_ONLY_TOUCH) {\r\n        Type = TouchInput;\r\n    } else if (!SUPPORT_TOUCH) {\r\n        Type = MouseInput;\r\n    } else {\r\n        Type = TouchMouseInput;\r\n    }\r\n    return new (Type)(manager, inputHandler);\r\n}\r\n\r\n/**\r\n * handle input events\r\n * @param {Manager} manager\r\n * @param {String} eventType\r\n * @param {Object} input\r\n */\r\nfunction inputHandler(manager, eventType, input) {\r\n    var pointersLen = input.pointers.length;\r\n    var changedPointersLen = input.changedPointers.length;\r\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\r\n    var isFinal = (eventType & INPUT_END && (pointersLen - changedPointersLen === 0));\r\n\r\n    input.isFirst = isFirst;\r\n    input.isFinal = isFinal;\r\n\r\n    if (isFirst) {\r\n        manager.session = {};\r\n    }\r\n    // source event is the normalized value of the domEvents\r\n    // like 'touchstart, mouseup, pointerdown'\r\n    input.eventType = eventType;\r\n\r\n    // compute scale, rotation etc\r\n    computeInputData(manager, input);\r\n\r\n    manager.recognize(input);\r\n}\r\n\r\n/**\r\n * extend the data with some usable properties like scale, rotate, velocity etc\r\n * @param {Object} manager\r\n * @param {Object} input\r\n */\r\nfunction computeInputData(manager, input) {\r\n    var session = manager.session;\r\n    var pointers = input.pointers;\r\n    var pointersLength = pointers.length;\r\n\r\n    // store the first input to calculate the distance and direction\r\n    if (!session.firstInput) {\r\n        session.firstInput = simpleCloneInputData(input);\r\n    }\r\n\r\n    // to compute scale and rotation we need to store the multiple touches\r\n    if (pointersLength > 1 && !session.firstMultiple) {\r\n        session.firstMultiple = simpleCloneInputData(input);\r\n    } else if (pointersLength === 1) {\r\n        session.firstMultiple = false;\r\n    }\r\n\r\n    var firstInput = session.firstInput;\r\n    var firstMultiple = session.firstMultiple;\r\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\r\n    var center = getCenter(pointers);\r\n\r\n    input.timeStamp = Date.now();//input.srcEvent.timeStamp;\r\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\r\n    input.deltaX = center.x - offsetCenter.x;\r\n    input.deltaY = center.y - offsetCenter.y;\r\n\r\n    input.center = center;\r\n    input.angle = getAngle(offsetCenter, center);\r\n    input.distance = getDistance(offsetCenter, center);\r\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\r\n\r\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\r\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\r\n\r\n    // find the correct target\r\n    var target = manager.element;\r\n    if (hasParent(input.srcEvent.target, target)) {\r\n        target = input.srcEvent.target;\r\n    }\r\n    input.target = target;\r\n\r\n    computeIntervalInputData(session, input);\r\n}\r\n\r\n/**\r\n * velocity is calculated every x ms\r\n * @param {Object} session\r\n * @param {Object} input\r\n */\r\nfunction computeIntervalInputData(session, input) {\r\n    var last = session.lastInterval;\r\n    if (!last) {\r\n        last = session.lastInterval = simpleCloneInputData(input);\r\n    }\r\n\r\n    var deltaTime = input.timeStamp - last.timeStamp;\r\n    if (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined) {\r\n        var deltaX = last.deltaX - input.deltaX;\r\n        var deltaY = last.deltaY - input.deltaY;\r\n\r\n        last = session.lastInterval = simpleCloneInputData(input);\r\n        last.velocity = getVelocity(deltaTime, deltaX, deltaY);\r\n        last.direction = getDirection(deltaX, deltaY);\r\n    }\r\n\r\n    var velocity = last.velocity;\r\n    input.velocity = Math.max(velocity.x, velocity.y);\r\n    input.velocityX = velocity.x;\r\n    input.velocityY = velocity.y;\r\n\r\n    input.direction = last.direction;\r\n}\r\n\r\n/**\r\n * create a simple clone from the input used for storage of firstInput and firstMultiple\r\n * @param {Object} input\r\n * @returns {Object} clonedInputData\r\n */\r\nfunction simpleCloneInputData(input) {\r\n    // make a simple copy of the pointers because we will get a reference if we don't\r\n    // we only need clientXY for the calculations\r\n    var pointers = [];\r\n    for (var i = 0; i < input.pointers.length; i++) {\r\n        pointers[i] = {\r\n            clientX: round(input.pointers[i].clientX),\r\n            clientY: round(input.pointers[i].clientY)\r\n        };\r\n    }\r\n\r\n    return {\r\n        timeStamp: Date.now(),\r\n        pointers: pointers,\r\n        center: getCenter(pointers),\r\n        deltaX: input.deltaX,\r\n        deltaY: input.deltaY\r\n    };\r\n}\r\n\r\n/**\r\n * get the center of all the pointers\r\n * @param {Array} pointers\r\n * @return {Object} center contains `x` and `y` properties\r\n */\r\nfunction getCenter(pointers) {\r\n    var pointersLength = pointers.length;\r\n\r\n    // no need to loop when only one touch\r\n    if (pointersLength === 1) {\r\n        return {\r\n            x: round(pointers[0].clientX),\r\n            y: round(pointers[0].clientY)\r\n        };\r\n    }\r\n\r\n    var x = 0, y = 0;\r\n    for (var i = 0; i < pointersLength; i++) {\r\n        x += pointers[i].clientX;\r\n        y += pointers[i].clientY;\r\n    }\r\n\r\n    return {\r\n        x: round(x / pointersLength),\r\n        y: round(y / pointersLength)\r\n    };\r\n}\r\n\r\n/**\r\n * calculate the velocity between two points. unit is in px per ms.\r\n * @param {Number} deltaTime\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Object} velocity `x` and `y`\r\n */\r\nfunction getVelocity(deltaTime, x, y) {\r\n    return {\r\n        x: Math.abs(x / deltaTime) || 0,\r\n        y: Math.abs(y / deltaTime) || 0\r\n    };\r\n}\r\n\r\n/**\r\n * get the direction between two points\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Number} direction\r\n */\r\nfunction getDirection(x, y) {\r\n    if (x === y) {\r\n        return DIRECTION_NONE;\r\n    }\r\n\r\n    if (Math.abs(x) >= Math.abs(y)) {\r\n        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n    }\r\n    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\r\n}\r\n\r\n/**\r\n * calculate the absolute distance between two points\r\n * @param {Object} p1 {x, y}\r\n * @param {Object} p2 {x, y}\r\n * @param {Array} [props] containing x and y keys\r\n * @return {Number} distance\r\n */\r\nfunction getDistance(p1, p2, props) {\r\n    if (!props) {\r\n        props = PROPS_XY;\r\n    }\r\n    var x = p2[props[0]] - p1[props[0]],\r\n        y = p2[props[1]] - p1[props[1]];\r\n\r\n    return Math.sqrt((x * x) + (y * y));\r\n}\r\n\r\n/**\r\n * calculate the angle between two coordinates\r\n * @param {Object} p1\r\n * @param {Object} p2\r\n * @param {Array} [props] containing x and y keys\r\n * @return {Number} angle\r\n */\r\nfunction getAngle(p1, p2, props) {\r\n    if (!props) {\r\n        props = PROPS_XY;\r\n    }\r\n    var x = p2[props[0]] - p1[props[0]],\r\n        y = p2[props[1]] - p1[props[1]];\r\n    return Math.atan2(y, x) * 180 / Math.PI;\r\n}\r\n\r\n/**\r\n * calculate the rotation degrees between two pointersets\r\n * @param {Array} start array of pointers\r\n * @param {Array} end array of pointers\r\n * @return {Number} rotation\r\n */\r\nfunction getRotation(start, end) {\r\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);\r\n}\r\n\r\n/**\r\n * calculate the scale factor between two pointersets\r\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\r\n * @param {Array} start array of pointers\r\n * @param {Array} end array of pointers\r\n * @return {Number} scale\r\n */\r\nfunction getScale(start, end) {\r\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\r\n}\r\n\r\nvar MOUSE_INPUT_MAP = {\r\n    mousedown: INPUT_START,\r\n    mousemove: INPUT_MOVE,\r\n    mouseup: INPUT_END,\r\n    mouseout: INPUT_CANCEL\r\n};\r\n\r\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\r\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseout mouseup';\r\n\r\n/**\r\n * Mouse events input\r\n * @constructor\r\n */\r\nfunction MouseInput() {\r\n    this.elEvents = MOUSE_ELEMENT_EVENTS;\r\n    this.winEvents = MOUSE_WINDOW_EVENTS;\r\n\r\n    this.allow = true; // used by Input.TouchMouse to disable mouse events\r\n    this.pressed = false; // mousedown state\r\n\r\n    Input.apply(this, arguments);\r\n}\r\n\r\ninherit(MouseInput, Input, {\r\n    /**\r\n     * handle mouse events\r\n     * @param {Object} ev\r\n     */\r\n    handler: function(ev) {\r\n        var eventType = MOUSE_INPUT_MAP[ev.type];\r\n\r\n        // on start we want to have the left mouse button down\r\n        if (eventType & INPUT_START && ev.button === 0) {\r\n            this.pressed = true;\r\n        }\r\n\r\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\r\n            eventType = INPUT_END;\r\n        }\r\n\r\n        // mouse must be down, and mouse events are allowed (see the TouchMouse input)\r\n        if (!this.pressed || !this.allow) {\r\n            return;\r\n        }\r\n\r\n        // out of the window?\r\n        var target = ev.relatedTarget || ev.toElement || ev.target;\r\n        if (ev.type == 'mouseout' && target.nodeName != 'HTML') {\r\n            eventType = INPUT_MOVE;\r\n        }\r\n\r\n        if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n            this.pressed = false;\r\n        }\r\n\r\n        this.callback(this.manager, eventType, {\r\n            pointers: [ev],\r\n            changedPointers: [ev],\r\n            pointerType: INPUT_TYPE_MOUSE,\r\n            srcEvent: ev\r\n        });\r\n    },\r\n});\r\n\r\nvar POINTER_INPUT_MAP = {\r\n    pointerdown: INPUT_START,\r\n    pointermove: INPUT_MOVE,\r\n    pointerup: INPUT_END,\r\n    pointercancel: INPUT_CANCEL,\r\n    pointerout: INPUT_CANCEL\r\n};\r\n\r\n// in IE10 the pointer types is defined as an enum\r\nvar IE10_POINTER_TYPE_ENUM = {\r\n    2: INPUT_TYPE_TOUCH,\r\n    3: INPUT_TYPE_PEN,\r\n    4: INPUT_TYPE_MOUSE,\r\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\r\n};\r\n\r\nvar POINTER_ELEMENT_EVENTS = 'pointerdown pointermove pointerup pointercancel';\r\nvar POINTER_WINDOW_EVENTS = 'pointerout';\r\n\r\n// IE10 has prefixed support, and case-sensitive\r\nif (window.MSPointerEvent) {\r\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown MSPointerMove MSPointerUp MSPointerCancel';\r\n    POINTER_WINDOW_EVENTS = 'MSPointerOut';\r\n}\r\n\r\n/**\r\n * Pointer events input\r\n * @constructor\r\n */\r\nfunction PointerEventInput() {\r\n    this.elEvents = POINTER_ELEMENT_EVENTS;\r\n    this.winEvents = POINTER_WINDOW_EVENTS;\r\n\r\n    Input.apply(this, arguments);\r\n\r\n    this.store = (this.manager.session.pointerEvents = []);\r\n}\r\n\r\ninherit(PointerEventInput, Input, {\r\n    /**\r\n     * handle mouse events\r\n     * @param {Object} ev\r\n     */\r\n    handler: function(ev) {\r\n        var store = this.store;\r\n        var removePointer = false;\r\n\r\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\r\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\r\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\r\n\r\n        // out of the window?\r\n        var target = ev.relatedTarget || ev.toElement || ev.target;\r\n        if (eventTypeNormalized == 'pointerout' && target.nodeName != 'HTML') {\r\n            eventType = INPUT_MOVE;\r\n        }\r\n\r\n        // start and mouse must be down\r\n        if (eventType & INPUT_START && (ev.button === 0 || pointerType == INPUT_TYPE_TOUCH)) {\r\n            store.push(ev);\r\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n            removePointer = true;\r\n        }\r\n\r\n        // get index of the event in the store\r\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\r\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\r\n        if (storeIndex < 0) {\r\n            return;\r\n        }\r\n\r\n        // update the event in the store\r\n        store[storeIndex] = ev;\r\n\r\n        this.callback(this.manager, eventType, {\r\n            pointers: store,\r\n            changedPointers: [ev],\r\n            pointerType: pointerType,\r\n            srcEvent: ev\r\n        });\r\n\r\n        if (removePointer) {\r\n            // remove from the store\r\n            store.splice(storeIndex, 1);\r\n        }\r\n    }\r\n});\r\n\r\nvar TOUCH_INPUT_MAP = {\r\n    touchstart: INPUT_START,\r\n    touchmove: INPUT_MOVE,\r\n    touchend: INPUT_END,\r\n    touchcancel: INPUT_CANCEL\r\n};\r\n\r\nvar TOUCH_EVENTS = 'touchstart touchmove touchend touchcancel';\r\n\r\n/**\r\n * Touch events input\r\n * @constructor\r\n */\r\nfunction TouchInput() {\r\n    this.elEvents = TOUCH_EVENTS;\r\n    this.targetIds = {};\r\n\r\n    Input.apply(this, arguments);\r\n}\r\n\r\ninherit(TouchInput, Input, {\r\n    /**\r\n     * handle touch events\r\n     * @param {Object} ev\r\n     */\r\n    handler: function(ev) {\r\n        var touches = normalizeTouches(ev, this);\r\n        this.callback(this.manager, TOUCH_INPUT_MAP[ev.type], {\r\n            pointers: touches[0],\r\n            changedPointers: touches[1],\r\n            pointerType: INPUT_TYPE_TOUCH,\r\n            srcEvent: ev\r\n        });\r\n    }\r\n});\r\n\r\n/**\r\n * make sure all browsers return the same touches\r\n * @param {Object} ev\r\n * @param {TouchInput} touchInput\r\n * @returns {Array} [all, changed]\r\n */\r\nfunction normalizeTouches(ev, touchInput) {\r\n    var i, len;\r\n\r\n    var targetIds = touchInput.targetIds;\r\n    var targetTouches = toArray(ev.targetTouches);\r\n    var changedTouches = toArray(ev.changedTouches);\r\n    var changedTargetTouches = [];\r\n\r\n    // collect touches\r\n    if (ev.type == 'touchstart') {\r\n        for (i = 0, len = targetTouches.length; i < len; i++) {\r\n            targetIds[targetTouches[i].identifier] = true;\r\n        }\r\n    }\r\n\r\n    // filter changed touches to only contain touches that exist in the collected target ids\r\n    for (i = 0, len = changedTouches.length; i < len; i++) {\r\n        if (targetIds[changedTouches[i].identifier]) {\r\n            changedTargetTouches.push(changedTouches[i]);\r\n        }\r\n\r\n        // cleanup removed touches\r\n        if (ev.type == 'touchend'|| ev.type == 'touchcancel') {\r\n            delete targetIds[changedTouches[i].identifier];\r\n        }\r\n    }\r\n\r\n    return [\r\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\r\n        // also removed the duplicates\r\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier'),\r\n\r\n        // only the changed :-)\r\n        changedTargetTouches\r\n    ];\r\n}\r\n\r\n/**\r\n * Combined touch and mouse input\r\n *\r\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\r\n * This because touch devices also emit mouse events while doing a touch.\r\n *\r\n * @constructor\r\n */\r\nfunction TouchMouseInput() {\r\n    Input.apply(this, arguments);\r\n\r\n    this._handler = bindFn(this.handler, this);\r\n    this.touch = new TouchInput(this.manager, this._handler);\r\n    this.mouse = new MouseInput(this.manager, this._handler);\r\n}\r\n\r\ninherit(TouchMouseInput, Input, {\r\n    /**\r\n     * handle mouse and touch events\r\n     * @param {Hammer} manager\r\n     * @param {String} inputEvent\r\n     * @param {Object} inputData\r\n     */\r\n    handler: function(manager, inputEvent, inputData) {\r\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\r\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\r\n\r\n        // when we're in a touch event, so  block all upcoming mouse events\r\n        // most mobile browser also emit mouseevents, right after touchstart\r\n        if (isTouch) {\r\n            this.mouse.allow = false;\r\n        } else if (isMouse && !this.mouse.allow) {\r\n            return;\r\n        }\r\n\r\n        // reset the allowMouse when we're done\r\n        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {\r\n            this.mouse.allow = true;\r\n        }\r\n\r\n        this.callback(manager, inputEvent, inputData);\r\n    },\r\n\r\n    /**\r\n     * remove the event listeners\r\n     */\r\n    destroy: function() {\r\n        this.touch.destroy();\r\n        this.mouse.destroy();\r\n    }\r\n});\r\n\r\nvar PREFIXED_TOUCH_ACTION = prefixed(document.body.style, 'touchAction');\r\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\r\n\r\n// magical touchAction value\r\nvar TOUCH_ACTION_COMPUTE = 'compute';\r\n\r\nvar TOUCH_ACTION_AUTO = 'auto';\r\nvar TOUCH_ACTION_MANIPULATION = 'manipulation';\r\nvar TOUCH_ACTION_NONE = 'none';\r\nvar TOUCH_ACTION_PAN_X = 'pan-x';\r\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\r\n\r\n/**\r\n * Touch Action\r\n * sets the touchAction property or uses the js alternative\r\n * @param {Manager} manager\r\n * @param {String} value\r\n * @constructor\r\n */\r\nfunction TouchAction(manager, value) {\r\n    this.manager = manager;\r\n    this.set(value);\r\n}\r\n\r\nTouchAction.prototype = {\r\n    /**\r\n     * set the touchAction value on the element or enable the polyfill\r\n     * @param {String} value\r\n     */\r\n    set: function(value) {\r\n        // find out the touch-action by the event handlers\r\n        if (value == TOUCH_ACTION_COMPUTE) {\r\n            value = this.compute();\r\n        }\r\n\r\n        if (NATIVE_TOUCH_ACTION) {\r\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\r\n        }\r\n        this.actions = value.toLowerCase();\r\n    },\r\n\r\n    /**\r\n     * just re-set the touchAction value\r\n     */\r\n    update: function() {\r\n        this.set(this.manager.options.touchAction);\r\n    },\r\n\r\n    /**\r\n     * compute the value for the touchAction property based on the recognizer's settings\r\n     * @returns {String} value\r\n     */\r\n    compute: function() {\r\n        var value;\r\n        var actions = [];\r\n\r\n        each(this.manager.recognizers, function(recognizer) {\r\n            if (boolOrFn(recognizer.options.enable, recognizer)) {\r\n                actions = actions.concat(recognizer.getTouchAction());\r\n            }\r\n        });\r\n        value = uniqueArray(actions).join(' ');\r\n        return cleanTouchActions(value);\r\n    },\r\n\r\n    /**\r\n     * this method is called on each input cycle and provides the preventing of the browser behavior\r\n     * @param {Object} input\r\n     */\r\n    preventDefaults: function(input) {\r\n        // not needed with native support for the touchAction property\r\n        if (NATIVE_TOUCH_ACTION) {\r\n            return;\r\n        }\r\n\r\n        var srcEvent = input.srcEvent;\r\n        var direction = input.offsetDirection;\r\n\r\n        // if the touch action did prevented once this session\r\n        if (this.manager.session.prevented) {\r\n            srcEvent.preventDefault();\r\n            return;\r\n        }\r\n\r\n        var actions = this.actions;\r\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE);\r\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\r\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\r\n\r\n        if (hasNone || (hasPanY && hasPanX) ||\r\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\r\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\r\n            return this.preventSrc(srcEvent);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\r\n     * @param {Object} srcEvent\r\n     */\r\n    preventSrc: function(srcEvent) {\r\n        this.manager.session.prevented = true;\r\n        srcEvent.preventDefault();\r\n    }\r\n};\r\n\r\n/**\r\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\r\n * @param {String} actions\r\n * @returns {*}\r\n */\r\nfunction cleanTouchActions(actions) {\r\n    // none\r\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\r\n        return TOUCH_ACTION_NONE;\r\n    }\r\n    // pan-x and pan-y can be combined\r\n    if (inStr(actions, TOUCH_ACTION_PAN_X) || inStr(actions, TOUCH_ACTION_PAN_Y)) {\r\n        return actions.replace(/[\\-\\w]+/g, function(action) {\r\n            if (/^pan\\-/.test(action)) {\r\n                return action;\r\n            }\r\n            return '';\r\n        });\r\n    }\r\n    // manipulation\r\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\r\n        return TOUCH_ACTION_MANIPULATION;\r\n    }\r\n\r\n    return TOUCH_ACTION_AUTO;\r\n}\r\n\r\nvar STATE_POSSIBLE = 1;\r\nvar STATE_BEGAN = 2;\r\nvar STATE_CHANGED = 4;\r\nvar STATE_ENDED = 8;\r\nvar STATE_RECOGNIZED = STATE_ENDED;\r\nvar STATE_CANCELLED = 16;\r\nvar STATE_FAILED = 32;\r\n\r\n/**\r\n * Recognizer\r\n * Every recognizer needs to extend from this class.\r\n * @constructor\r\n * @param {Object} options\r\n */\r\nfunction Recognizer(options) {\r\n    this.id = uniqueId();\r\n\r\n    this.manager = null;\r\n    this.options = merge(options || {}, this.defaults);\r\n\r\n    // default is enable true\r\n    this.options.enable = (options.enable === undefined) ? true : options.enable;\r\n\r\n    this.state = STATE_FAILED;\r\n\r\n    this.simultaneous = {};\r\n    this.requireFail = [];\r\n}\r\n\r\nRecognizer.prototype = {\r\n    /**\r\n     * default settings\r\n     */\r\n    defaults: {},\r\n\r\n    /**\r\n     * set options\r\n     * @param {String} option\r\n     * @param {*} val\r\n     */\r\n    set: function(option, val) {\r\n        this.options[option] = val;\r\n\r\n        // also update the touchAction, in case something changed about the directions/enabled state\r\n        this.manager && this.manager.touchAction.update();\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * default emitter\r\n     * @param {Object} input\r\n     */\r\n    emit: function(input) {\r\n        this.manager.emit(this.options.event, input); // simple 'eventName' events\r\n        this.manager.emit(this.options.event + stateStr(this.state), input); // like 'panmove' and 'panstart'\r\n    },\r\n\r\n    /**\r\n     * recognize simultaneous with an other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    recognizeWith: function(otherRecognizer) {\r\n        var simultaneous = this.simultaneous;\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        if (!simultaneous[otherRecognizer.id]) {\r\n            simultaneous[otherRecognizer.id] = otherRecognizer;\r\n            otherRecognizer.recognizeWith(this);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    dropRecognizeWith: function(otherRecognizer) {\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        delete this.simultaneous[otherRecognizer.id];\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * recognizer can only run when an other is failing\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    requireFailure: function(otherRecognizer) {\r\n        var requireFail = this.requireFail;\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        if (inArray(requireFail, otherRecognizer) === -1) {\r\n            requireFail.push(otherRecognizer);\r\n            otherRecognizer.requireFailure(this);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    dropRequireFailure: function(otherRecognizer) {\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        var index = inArray(this.requireFail, otherRecognizer);\r\n        if (index > -1) {\r\n            this.requireFail.splice(index, 1);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * if the recognizer can recognize simultaneous with an other recognizer\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Boolean}\r\n     */\r\n    canRecognizeWith: function(otherRecognizer) {\r\n        return !!this.simultaneous[otherRecognizer.id];\r\n    },\r\n\r\n    /**\r\n     * update the recognizer\r\n     * @param {Object} inputData\r\n     */\r\n    recognize: function(inputData) {\r\n        // require failure of other recognizers\r\n        var canRecognize = true;\r\n        for (var i = 0; i < this.requireFail.length; i++) {\r\n            if (!(this.requireFail[i].state & STATE_FAILED)) {\r\n                canRecognize = false;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // make a new copy of the inputData\r\n        // so we can change the inputData without messing up the other recognizers\r\n        var inputDataClone = extend({}, inputData);\r\n\r\n        // is is enabled and allow recognizing?\r\n        if (!canRecognize || !boolOrFn(this.options.enable, [this, inputDataClone])) {\r\n            this.reset();\r\n            this.state = STATE_FAILED;\r\n            return;\r\n        }\r\n\r\n        // reset when we've reached the end\r\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\r\n            this.state = STATE_POSSIBLE;\r\n        }\r\n\r\n        this.state = this.process(inputDataClone);\r\n\r\n        // the recognizer has recognized a gesture\r\n        // so trigger an event\r\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\r\n            this.emit(inputDataClone);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * return the state of the recognizer\r\n     * the actual recognizing happens in this method\r\n     * @virtual\r\n     * @param {Object} inputData\r\n     * @returns {Const} STATE_*\r\n     */\r\n    process: function(inputData) { }, // jshint ignore:line\r\n\r\n    /**\r\n     * return the preferred touch-action\r\n     * @virtual\r\n     * @returns {Array}\r\n     */\r\n    getTouchAction: function() { },\r\n\r\n    /**\r\n     * called when the gesture isn't allowed to recognize\r\n     * like when another is being recognized or it is disabled\r\n     * @virtual\r\n     */\r\n    reset: function() { }\r\n};\r\n\r\n/**\r\n * get a usable string, used as event postfix\r\n * @param {Const} state\r\n * @returns {String} state\r\n */\r\nfunction stateStr(state) {\r\n    if (state & STATE_CANCELLED) {\r\n        return 'cancel';\r\n    } else if (state & STATE_ENDED) {\r\n        return 'end';\r\n    } else if (state & STATE_CHANGED) {\r\n        return 'move';\r\n    } else if (state & STATE_BEGAN) {\r\n        return 'start';\r\n    }\r\n    return '';\r\n}\r\n\r\n/**\r\n * direction cons to string\r\n * @param {Const} direction\r\n * @returns {String}\r\n */\r\nfunction directionStr(direction) {\r\n    if (direction == DIRECTION_DOWN) {\r\n        return 'down';\r\n    } else if (direction == DIRECTION_UP) {\r\n        return 'up';\r\n    } else if (direction == DIRECTION_LEFT) {\r\n        return 'left';\r\n    } else if (direction == DIRECTION_RIGHT) {\r\n        return 'right';\r\n    }\r\n    return '';\r\n}\r\n\r\n/**\r\n * get a recognizer by name if it is bound to a manager\r\n * @param {Recognizer|String} otherRecognizer\r\n * @param {Recognizer} recognizer\r\n * @returns {Recognizer}\r\n */\r\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\r\n    var manager = recognizer.manager;\r\n    if (manager) {\r\n        return manager.get(otherRecognizer);\r\n    }\r\n    return otherRecognizer;\r\n}\r\n\r\n/**\r\n * this recognizer is just used as a base for the simple\r\n * pan, pinch, rotate and swipe recognizers\r\n * @constructor\r\n */\r\nfunction AttrRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(AttrRecognizer, Recognizer, {\r\n    defaults: {\r\n        pointers: 1\r\n    },\r\n\r\n    /**\r\n     * used to check if it the recognizer receives valid input, like input.distance > 10\r\n     * this should be overwritten\r\n     * @virtual\r\n     * @param {Object} input\r\n     * @returns {Boolean} recognized\r\n     */\r\n    attrTest: function(input) {\r\n        var optionPointers = this.options.pointers;\r\n        return optionPointers === 0 || input.pointers.length === optionPointers;\r\n    },\r\n\r\n    process: function(input) {\r\n        var state = this.state;\r\n        var eventType = input.eventType;\r\n\r\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\r\n        var isValid = this.attrTest(input);\r\n\r\n        // on cancel input and we've recognized before, return STATE_CANCELLED\r\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\r\n            return state | STATE_CANCELLED;\r\n        } else if (isRecognized || isValid) {\r\n            if (eventType & INPUT_END) {\r\n                return state | STATE_ENDED;\r\n            } else if (!(state & STATE_BEGAN)) {\r\n                return state | STATE_BEGAN;\r\n            }\r\n            return state | STATE_CHANGED;\r\n        }\r\n        return STATE_FAILED;\r\n    }\r\n});\r\n\r\n/**\r\n * Pan\r\n * Recognized when the pointer is down and moved in the allowed direction.\r\n * @constructor\r\n */\r\nfunction PanRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n\r\n    this.pX = null;\r\n    this.pY = null;\r\n}\r\n\r\ninherit(PanRecognizer, AttrRecognizer, {\r\n    defaults: {\r\n        event: 'pan',\r\n        threshold: 10,\r\n        pointers: 1,\r\n        direction: DIRECTION_ALL\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        var direction = this.options.direction;\r\n\r\n        if (direction === DIRECTION_ALL) {\r\n            return [TOUCH_ACTION_NONE];\r\n        }\r\n\r\n        var actions = [];\r\n        if (direction & DIRECTION_HORIZONTAL) {\r\n            actions.push(TOUCH_ACTION_PAN_Y);\r\n        }\r\n        if (direction & DIRECTION_VERTICAL) {\r\n            actions.push(TOUCH_ACTION_PAN_X);\r\n        }\r\n        return actions;\r\n    },\r\n\r\n    directionTest: function(input) {\r\n        var options = this.options;\r\n        var hasMoved = true;\r\n        var distance = input.distance;\r\n        var direction = input.direction;\r\n        var x = input.deltaX;\r\n        var y = input.deltaY;\r\n\r\n        // lock to axis?\r\n        if (!(direction & options.direction)) {\r\n            if (options.direction & DIRECTION_HORIZONTAL) {\r\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n                hasMoved = x != this.pX;\r\n                distance = Math.abs(input.deltaX);\r\n            } else {\r\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\r\n                hasMoved = y != this.pY;\r\n                distance = Math.abs(input.deltaY);\r\n            }\r\n        }\r\n        input.direction = direction;\r\n        return hasMoved && distance > options.threshold && direction & options.direction;\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\r\n            this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input));\r\n    },\r\n\r\n    emit: function(input) {\r\n        this.pX = input.deltaX;\r\n        this.pY = input.deltaY;\r\n\r\n        this._super.emit.call(this, input);\r\n\r\n        var direction = directionStr(input.direction);\r\n        if (direction) {\r\n            this.manager.emit(this.options.event + direction, input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Pinch\r\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\r\n * @constructor\r\n */\r\nfunction PinchRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(PinchRecognizer, AttrRecognizer, {\r\n    defaults: {\r\n        event: 'pinch',\r\n        threshold: 0,\r\n        pointers: 2\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y];\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return this._super.attrTest.call(this, input) &&\r\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\r\n    },\r\n\r\n    emit: function(input) {\r\n        this._super.emit.call(this, input);\r\n        if (input.scale !== 1) {\r\n            var inOut = input.scale < 1 ? 'in' : 'out';\r\n            this.manager.emit(this.options.event + inOut, input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Press\r\n * Recognized when the pointer is down for x ms without any movement.\r\n * @constructor\r\n */\r\nfunction PressRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n\r\n    this._timer = null;\r\n    this._input = null;\r\n}\r\n\r\ninherit(PressRecognizer, Recognizer, {\r\n    defaults: {\r\n        event: 'press',\r\n        pointers: 1,\r\n        time: 500, // minimal time of the pointer to be pressed\r\n        threshold: 5 // a minimal movement is ok, but keep it low\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_AUTO];\r\n    },\r\n\r\n    process: function(input) {\r\n        var options = this.options;\r\n\r\n        var validPointers = input.pointers.length === options.pointers;\r\n        var validMovement = input.distance < options.threshold;\r\n        var validTime = input.deltaTime > options.time;\r\n\r\n        this._input = input;\r\n\r\n        // we only allow little movement\r\n        // and we've reached an end event, so a tap is possible\r\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\r\n            this.reset();\r\n        } else if (input.eventType & INPUT_START) {\r\n            this.reset();\r\n            this._timer = setTimeout(bindFn(this.emit, this), options.time);\r\n        }\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    reset: function() {\r\n        clearTimeout(this._timer);\r\n        this._timer = null;\r\n    },\r\n\r\n    emit: function() {\r\n        this._input.timeStamp = Date.now();\r\n        this.manager.emit(this.options.event, this._input);\r\n    }\r\n});\r\n\r\n/**\r\n * Rotate\r\n * Recognized when two or more pointer are moving in a circular motion.\r\n * @constructor\r\n */\r\nfunction RotateRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(RotateRecognizer, AttrRecognizer, {\r\n    defaults: {\r\n        event: 'rotate',\r\n        threshold: 0,\r\n        pointers: 2\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_NONE];\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return this._super.attrTest.call(this, input) &&\r\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\r\n    }\r\n});\r\n\r\n/**\r\n * Swipe\r\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\r\n * @constructor\r\n */\r\nfunction SwipeRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(SwipeRecognizer, AttrRecognizer, {\r\n    defaults: {\r\n        event: 'swipe',\r\n        threshold: 10,\r\n        velocity: 0.65,\r\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\r\n        pointers: 1\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return PanRecognizer.prototype.getTouchAction.call(this);\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        var direction = this.options.direction;\r\n        var velocity;\r\n\r\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\r\n            velocity = input.velocity;\r\n        } else if (direction & DIRECTION_HORIZONTAL) {\r\n            velocity = input.velocityX;\r\n        } else if (direction & DIRECTION_VERTICAL) {\r\n            velocity = input.velocityY;\r\n        }\r\n\r\n        return this._super.attrTest.call(this, input) &&\r\n            direction & input.direction &&\r\n            velocity > this.options.velocity && input.eventType & INPUT_END;\r\n    },\r\n\r\n    emit: function(input) {\r\n        this.manager.emit(this.options.event, input);\r\n\r\n        var direction = directionStr(input.direction);\r\n        if (direction) {\r\n            this.manager.emit(this.options.event + direction, input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Tap\r\n * Recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur between the given\r\n * interval and position. The delay option can be used to recognize multi-taps without firing a single tap.\r\n *\r\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\r\n * multi-taps being recognized.\r\n * @constructor\r\n */\r\nfunction TapRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n\r\n    // previous time and center,\r\n    // used for tap counting\r\n    this.pTime = false;\r\n    this.pCenter = false;\r\n\r\n    this._timer = null;\r\n    this._input = null;\r\n    this.count = 0;\r\n}\r\n\r\ninherit(TapRecognizer, Recognizer, {\r\n    defaults: {\r\n        event: 'tap',\r\n        pointers: 1,\r\n        taps: 1,\r\n        interval: 300, // max time between the multi-tap taps\r\n        delay: 0, // delay after triggering the tap. useful if you don't want to recognize a tap on each touchend\r\n        time: 250, // max time of the pointer to be down (like finger on the screen)\r\n        threshold: 2, // a minimal movement is ok, but keep it low\r\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_MANIPULATION];\r\n    },\r\n\r\n    process: function(input) {\r\n        var self = this;\r\n        var options = this.options;\r\n\r\n        var validPointers = input.pointers.length === options.pointers;\r\n        var validMovement = input.distance < options.threshold;\r\n        var validTouchTime = input.deltaTime < options.time;\r\n\r\n        // we only allow little movement\r\n        // and we've reached an end event, so a tap is possible\r\n        if (input.eventType & INPUT_END && validMovement && validTouchTime && validPointers) {\r\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\r\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\r\n\r\n            this.pTime = input.timeStamp;\r\n            this.pCenter = input.center;\r\n\r\n            if (!validMultiTap || !validInterval) {\r\n                this.count = 1;\r\n            } else {\r\n                this.count += 1;\r\n            }\r\n\r\n            this._input = input;\r\n            this.reset();\r\n\r\n            // if tap count matches we have recognized it,\r\n            // else it has began recognizing...\r\n            var tapCount = this.count % options.taps;\r\n            if (tapCount === 0) {\r\n                if (!options.delay) {\r\n                    return STATE_RECOGNIZED;\r\n                } else {\r\n                    this._timer = setTimeout(function() {\r\n                        self.state = STATE_RECOGNIZED;\r\n                        self.emit();\r\n                    }, options.delay);\r\n                    return STATE_BEGAN;\r\n                }\r\n            }\r\n            if (!options.delay) {\r\n                return STATE_BEGAN;\r\n            }\r\n        }\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    reset: function() {\r\n        clearTimeout(this._timer);\r\n    },\r\n\r\n    emit: function() {\r\n        if (this.state == STATE_RECOGNIZED) {\r\n            this._input.tapCount = this.count;\r\n            this.manager.emit(this.options.event, this._input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * create an manager with a default set of recognizers\r\n * @param {HTMLElement} element\r\n * @param {Object} [options]\r\n * @constructor\r\n */\r\nfunction Hammer(element, options) {\r\n    options = options || {};\r\n    options.recognizers = Hammer.defaults.setupRecognizers;\r\n    return new Manager(element, options);\r\n}\r\n\r\nHammer.VERSION = '2.0.0dev';\r\n\r\nHammer.defaults = {\r\n    // when set to true, dom events are being triggered.\r\n    // but this is slower and unused by simple implementations, so disabled by default.\r\n    domEvents: false,\r\n\r\n    // this value is used when a touch-action isn't defined on the element.style\r\n    touchAction: TOUCH_ACTION_COMPUTE,\r\n\r\n    // default enabled state\r\n    enable: true,\r\n\r\n    // default recognizer setup when calling Hammer()\r\n    // when creating a new manager these will be skipped.\r\n    setupRecognizers: [\r\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\r\n        [RotateRecognizer, { enable: false }],\r\n        [PinchRecognizer, { enable: false }, ['rotate']],\r\n        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],\r\n        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\r\n        [TapRecognizer],\r\n        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\r\n        [PressRecognizer]\r\n    ],\r\n\r\n    // with some style attributes you can improve the experience.\r\n    cssProps: {\r\n        // Disables text selection to improve the dragging gesture. When the value is `none` it also sets\r\n        // `onselectstart=false` for IE9 on the element. Mainly for desktop browsers.\r\n        userSelect: 'none',\r\n\r\n        // Disable the Windows Phone grippers when pressing an element.\r\n        touchSelect: 'none',\r\n\r\n        // Disables the default callout shown when you touch and hold a touch target.\r\n        // On iOS, when you touch and hold a touch target such as a link, Safari displays\r\n        // a callout containing information about the link. This property allows you to disable that callout.\r\n        touchCallout: 'none',\r\n\r\n        // Specifies whether zooming is enabled. Used by IE10>\r\n        contentZooming: 'none',\r\n\r\n        // Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\r\n        userDrag: 'none',\r\n\r\n        // Overrides the highlight color shown when the user taps a link or a JavaScript\r\n        // clickable element in iOS. This property obeys the alpha value, if specified.\r\n        tapHighlightColor: 'rgba(0,0,0,0)'\r\n    }\r\n};\r\n\r\n/**\r\n * Manager\r\n * @param {HTMLElement} element\r\n * @param {Object} [options]\r\n * @constructor\r\n */\r\nfunction Manager(element, options) {\r\n    options = options || {};\r\n\r\n    this.options = merge(options, Hammer.defaults);\r\n\r\n    this.handlers = {};\r\n    this.session = {};\r\n    this.recognizers = [];\r\n\r\n    this.element = element;\r\n    this.input = createInputInstance(this);\r\n    this.touchAction = new TouchAction(this, this.options.touchAction);\r\n\r\n    toggleCssProps(this, true);\r\n\r\n    each(options.recognizers, function(item) {\r\n        var recognizer = this.add(new (item[0])(item[1]));\r\n        item[2] && each(item[2], recognizer.recognizeWith, recognizer);\r\n        item[3] && each(item[3], recognizer.requireFailure, recognizer);\r\n    }, this);\r\n}\r\n\r\nManager.prototype = {\r\n    /**\r\n     * set options\r\n     * @param {String} option\r\n     * @param {*} val\r\n     */\r\n    set: function(option, val) {\r\n        this.options[option] = val;\r\n    },\r\n\r\n    /**\r\n     * stop recognizing for this session.\r\n     * This session will be discarded, when a new [input]start event is fired.\r\n     * When forced, the recognizer cycle is stopped immediately.\r\n     * @param {Boolean} [force]\r\n     */\r\n    stop: function(force) {\r\n        this.session.stopped = force ? 2 : 1;\r\n    },\r\n\r\n    /**\r\n     * run the recognizers!\r\n     * called by the inputHandler function\r\n     * @param {Object} inputData\r\n     */\r\n    recognize: function(inputData) {\r\n        if (this.session.stopped) {\r\n            return;\r\n        }\r\n\r\n        this.touchAction.preventDefaults(inputData);\r\n\r\n        var recognizer;\r\n        var session = this.session;\r\n        var curRecognizer = session.curRecognizer;\r\n\r\n        // reset when the last recognizer is done, or this is a new session\r\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\r\n            curRecognizer = session.curRecognizer = null;\r\n        }\r\n\r\n        // we're in a active recognizer\r\n        for (var i = 0, len = this.recognizers.length; i < len; i++) {\r\n            recognizer = this.recognizers[i];\r\n\r\n            if (this.session.stopped !== 2 && (\r\n                    !curRecognizer || recognizer == curRecognizer ||\r\n                    recognizer.canRecognizeWith(curRecognizer))) {\r\n                recognizer.recognize(inputData);\r\n            } else {\r\n                recognizer.reset();\r\n            }\r\n\r\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\r\n                curRecognizer = session.curRecognizer = recognizer;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * get a recognizer by its event name.\r\n     * @param {Recognizer|String} recognizer\r\n     * @returns {Recognizer|Null}\r\n     */\r\n    get: function(recognizer) {\r\n        if (recognizer instanceof Recognizer) {\r\n            return recognizer;\r\n        }\r\n\r\n        var recognizers = this.recognizers;\r\n        for (var i = 0; i < recognizers.length; i++) {\r\n            if (recognizers[i].options.event == recognizer) {\r\n                return recognizers[i];\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * add a recognizer to the manager\r\n     * existing recognizers with the same event name will be removed\r\n     * @param {Recognizer} recognizer\r\n     * @returns {Recognizer}\r\n     */\r\n    add: function(recognizer) {\r\n        // remove existing\r\n        var existing = this.get(recognizer.options.event);\r\n        if (existing) {\r\n            this.remove(existing);\r\n        }\r\n\r\n        this.recognizers.push(recognizer);\r\n        recognizer.manager = this;\r\n\r\n        this.touchAction.update();\r\n        return recognizer;\r\n    },\r\n\r\n    /**\r\n     * remove a recognizer by name or instance\r\n     * @param {Recognizer|String} recognizer\r\n     */\r\n    remove: function(recognizer) {\r\n        var recognizers = this.recognizers;\r\n        recognizer = this.get(recognizer);\r\n        recognizers.splice(inArray(recognizers, recognizer), 1);\r\n\r\n        this.touchAction.update();\r\n    },\r\n\r\n    /**\r\n     * bind event\r\n     * @param {String} events\r\n     * @param {Function} handler\r\n     * @returns {EventEmitter} this\r\n     */\r\n    on: function(events, handler) {\r\n        var handlers = this.handlers;\r\n        each(splitStr(events), function(event) {\r\n            handlers[event] = handlers[event] || [];\r\n            handlers[event].push(handler);\r\n        });\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * unbind event, leave emit blank to remove all handlers\r\n     * @param {String} events\r\n     * @param {Function} [handler]\r\n     * @returns {EventEmitter} this\r\n     */\r\n    off: function(events, handler) {\r\n        var handlers = this.handlers;\r\n        each(splitStr(events), function(event) {\r\n            if (!handler) {\r\n                delete handlers[event];\r\n            } else {\r\n                handlers[event].splice(inArray(handlers[event], handler), 1);\r\n            }\r\n        });\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * emit event to the listeners\r\n     * @param {String} event\r\n     * @param {Object} data\r\n     */\r\n    emit: function(event, data) {\r\n        // we also want to trigger dom events\r\n        if (this.options.domEvents) {\r\n            triggerDomEvent(event, data);\r\n        }\r\n\r\n        // no handlers, so skip it all\r\n        var handlers = this.handlers[event];\r\n        if (!handlers || !handlers.length) {\r\n            return;\r\n        }\r\n\r\n        data.type = event;\r\n        data.preventDefault = function() {\r\n            data.srcEvent.preventDefault();\r\n        };\r\n\r\n        for (var i = 0, len = handlers.length; i < len; i++) {\r\n            handlers[i](data);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * destroy the manager and unbinds all events\r\n     * it doesn't unbind dom events, that is the user own responsibility\r\n     */\r\n    destroy: function() {\r\n        toggleCssProps(this, false);\r\n\r\n        this.handlers = {};\r\n        this.session = {};\r\n        this.input.destroy();\r\n        this.element = null;\r\n    }\r\n};\r\n\r\n/**\r\n * add/remove the css properties as defined in manager.options.cssProps\r\n * @param {Manager} manager\r\n * @param {Boolean} add\r\n */\r\nfunction toggleCssProps(manager, add) {\r\n    var element = manager.element;\r\n    var cssProps = manager.options.cssProps;\r\n\r\n    each(cssProps, function(value, name) {\r\n        element.style[prefixed(element.style, name)] = add ? value : '';\r\n    });\r\n\r\n    var falseFn = add && function() { return false; };\r\n    if (cssProps.userSelect == 'none') { element.onselectstart = falseFn; }\r\n    if (cssProps.userDrag == 'none') { element.ondragstart = falseFn; }\r\n}\r\n\r\n/**\r\n * trigger dom event\r\n * @param {String} event\r\n * @param {Object} data\r\n */\r\nfunction triggerDomEvent(event, data) {\r\n    var gestureEvent = document.createEvent('Event');\r\n    gestureEvent.initEvent(event, true, true);\r\n    gestureEvent.gesture = data;\r\n    data.target.dispatchEvent(gestureEvent);\r\n}\r\n\r\nHammer.INPUT_START = INPUT_START;\r\nHammer.INPUT_MOVE = INPUT_MOVE;\r\nHammer.INPUT_END = INPUT_END;\r\nHammer.INPUT_CANCEL = INPUT_CANCEL;\r\n\r\nHammer.STATE_POSSIBLE = STATE_POSSIBLE;\r\nHammer.STATE_BEGAN = STATE_BEGAN;\r\nHammer.STATE_CHANGED = STATE_CHANGED;\r\nHammer.STATE_ENDED = STATE_ENDED;\r\nHammer.STATE_RECOGNIZED = STATE_RECOGNIZED;\r\nHammer.STATE_CANCELLED = STATE_CANCELLED;\r\nHammer.STATE_FAILED = STATE_FAILED;\r\n\r\nHammer.DIRECTION_NONE = DIRECTION_NONE;\r\nHammer.DIRECTION_LEFT = DIRECTION_LEFT;\r\nHammer.DIRECTION_RIGHT = DIRECTION_RIGHT;\r\nHammer.DIRECTION_UP = DIRECTION_UP;\r\nHammer.DIRECTION_DOWN = DIRECTION_DOWN;\r\nHammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\r\nHammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;\r\nHammer.DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\r\n\r\nHammer.Manager = Manager;\r\nHammer.Input = Input;\r\nHammer.TouchAction = TouchAction;\r\n\r\nHammer.Recognizer = Recognizer;\r\nHammer.AttrRecognizer = AttrRecognizer;\r\nHammer.Tap = TapRecognizer;\r\nHammer.Pan = PanRecognizer;\r\nHammer.Swipe = SwipeRecognizer;\r\nHammer.Pinch = PinchRecognizer;\r\nHammer.Rotate = RotateRecognizer;\r\nHammer.Press = PressRecognizer;\r\n\r\nHammer.on = addEventListeners;\r\nHammer.off = removeEventListeners;\r\nHammer.each = each;\r\nHammer.merge = merge;\r\nHammer.extend = extend;\r\nHammer.inherit = inherit;\r\nHammer.bindFn = bindFn;\r\nHammer.prefixed = prefixed;\r\n\r\nif (typeof define == TYPE_FUNCTION && define.amd) {\r\n    define(function() {\r\n        return Hammer;\r\n    });\r\n} else if (typeof module != TYPE_UNDEFINED && module.exports) {\r\n    module.exports = Hammer;\r\n} else {\r\n    window.Hammer = Hammer;\r\n}\r\n\r\n})(window);","module.exports = __webpack_amd_options__;\r\n"],"sourceRoot":"webpack-module://"}