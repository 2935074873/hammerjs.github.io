{"version":3,"file":"index.js","sources":["index.js","webpack/bootstrap 6dfa5dcebfb58ff37e0e","./src/assets/js/index.js","./~/hammerjs/hammer.js","./src/assets/js/demo.js","./src/assets/js/externals.js","(webpack)/buildin/amd-options.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","window","Hammer","toggle","document","querySelector","target","addEventListener","ev","className","indexOf","replace","preventDefault","__WEBPACK_AMD_DEFINE_RESULT__","undefined","each","obj","iterator","context","i","len","forEach","length","hasOwnProperty","extend","dest","src","merge","keys","Object","inherit","child","base","properties","childP","baseP","prototype","create","constructor","Inherited","this","_super","bindFn","fn","apply","arguments","boolOrFn","val","args","TYPE_FUNCTION","ifUndefined","val1","val2","addEventListeners","element","types","handler","splitStr","type","removeEventListeners","removeEventListener","hasParent","node","parent","parentNode","inStr","str","find","trim","split","inArray","findByKey","toArray","Array","slice","uniqueArray","key","results","values","push","prefixed","property","prefix","prop","camelProp","toUpperCase","VENDOR_PREFIXES","uniqueId","_uniqueId","Input","manager","callback","self","domHandler","options","enable","evEl","evWin","createInputInstance","Type","SUPPORT_POINTER_EVENTS","PointerEventInput","SUPPORT_ONLY_TOUCH","TouchInput","SUPPORT_TOUCH","TouchMouseInput","MouseInput","inputHandler","eventType","input","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","INPUT_START","isFinal","INPUT_END","session","computeInputData","recognize","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","timeStamp","Date","now","deltaTime","deltaX","x","deltaY","y","angle","getAngle","distance","getDistance","offsetDirection","getDirection","scale","getScale","rotation","getRotation","srcEvent","computeIntervalInputData","last","lastInterval","velocity","velocityX","velocityY","direction","COMPUTE_INTERVAL","v","getVelocity","Math","max","clientX","round","clientY","abs","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","p1","p2","props","PROPS_XY","sqrt","atan2","PI","start","end","PROPS_CLIENT_XY","MOUSE_ELEMENT_EVENTS","MOUSE_WINDOW_EVENTS","allow","pressed","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","store","pointerEvents","TOUCH_EVENTS","targetIds","normalizeTouches","touchInput","targetTouches","changedTouches","changedTargetTouches","identifier","concat","touch","mouse","TouchAction","value","set","cleanTouchActions","actions","TOUCH_ACTION_NONE","TOUCH_ACTION_PAN_X","TOUCH_ACTION_PAN_Y","action","test","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_AUTO","Recognizer","defaults","state","STATE_POSSIBLE","simultaneous","requireFail","stateStr","STATE_CANCELLED","STATE_ENDED","STATE_CHANGED","STATE_BEGAN","directionStr","getRecognizerByNameIfManager","otherRecognizer","recognizer","get","AttrRecognizer","PanRecognizer","pX","pY","PinchRecognizer","PressRecognizer","_timer","_input","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","count","recognizers","easyRecognizers","Manager","handlers","touchAction","toggleCssProps","item","add","recognizeWith","requireFailure","cssProps","name","style","falseFn","userSelect","onselectstart","userDrag","ondragstart","triggerDomEvent","event","data","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","TYPE_UNDEFINED","MOBILE_REGEX","navigator","userAgent","INPUT_TYPE_TOUCH","INPUT_TYPE_PEN","INPUT_TYPE_MOUSE","INPUT_TYPE_KINECT","INPUT_MOVE","INPUT_CANCEL","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","destroy","elEvents","winEvents","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","mouseout","button","which","relatedTarget","toElement","nodeName","pointerType","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM",2,3,4,5,"MSPointerEvent","removePointer","eventTypeNormalized","toLowerCase","storeIndex","pointerId","splice","TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","touches","inputEvent","inputData","isTouch","isMouse","PREFIXED_TOUCH_ACTION","body","NATIVE_TOUCH_ACTION","TOUCH_ACTION_COMPUTE","compute","update","getTouchAction","join","preventDefaults","prevented","hasNone","hasPanY","hasPanX","preventSrc","STATE_RECOGNIZED","STATE_FAILED","option","dropRecognizeWith","dropRequireFailure","index","hasRequireFailures","canRecognizeWith","emit","tryEmit","canEmit","inputDataClone","process","reset","attrTest","optionPointers","isRecognized","isValid","threshold","directionTest","hasMoved","inOut","time","validPointers","validMovement","validTime","setTimeout","clearTimeout","taps","delay","interval","posThreshold","validTouchTime","_setupBeganState","validInterval","validMultiTap","tapCount","VERSION","domEvents","touchSelect","touchCallout","contentZooming","tapHighlightColor","STOP","FORCED_STOP","stop","force","stopped","curRecognizer","existing","remove","on","events","off","Tap","Pan","Swipe","Pinch","Rotate","Press","resetElementStart","el","resetElementEnd","transform","translate","startX","startY","rotate","requestElementUpdate","updateElementTransform","webkitTransform","ticking","reqAnimationFrame","onPan","onSwipe","onPinch","onRotate","onTap","onDoubleTap","onHold","background","offsetWidth","offsetHeight","mc","classList","location","href","_gaq","ga","createElement","async","protocol","s","getElementsByTagName","insertBefore","d","js","fjs","getElementById","__webpack_amd_options__"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,cAGAV,EAAA,KDMM,SAASI,EAAQD,EAASH,GE5ChCW,OAAAC,OAAAZ,EAAA,EAEA,IAAAa,GAAAC,SAAAC,cAAA,mBACAC,EAAAF,SAAAC,cAAA,WACAF,IAAAG,GACAH,EAAAI,iBAAA,iBAAAC,GACA,KAAAF,EAAAG,UAAAC,QAAA,QACAJ,EAAAG,WAAA,QAEAH,EAAAG,UAAAH,EAAAG,UAAAE,QAAA,WAEAH,EAAAI,mBAKAR,SAAAC,cAAA,aACAf,EAAA,GAGAA,EAAA,IFmDM,SAASI,EAAQD,EAASH,GGvEhC,GAAAuB,IAAA,SAAAZ,EAAAa,GACA,YAaA,SAAAC,GAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAAC,CAEA,IAAAJ,EAIA,GAAAA,EAAAK,QACAL,EAAAK,QAAAJ,EAAAC,OACK,IAAAF,EAAAM,SAAAR,EACL,IAAAK,EAAA,EAAAC,EAAAJ,EAAAM,OAAqCF,EAAAD,EAASA,IAC9CF,EAAApB,KAAAqB,EAAAF,EAAAG,KAAAH,OAGA,KAAAG,IAAAH,GACAA,EAAAO,eAAAJ,IAAAF,EAAApB,KAAAqB,EAAAF,EAAAG,KAAAH,GAaA,QAAAQ,GAAAC,EAAAC,EAAAC,GAEA,OADAC,GAAAC,OAAAD,KAAAF,GACAP,EAAA,EAAAC,EAAAQ,EAAAN,OAAsCF,EAAAD,EAASA,MAC/CQ,MAAAF,EAAAG,EAAAT,MAAAL,KACAW,EAAAG,EAAAT,IAAAO,EAAAE,EAAAT,IAGA,OAAAM,GAUA,QAAAE,GAAAF,EAAAC,GACA,MAAAF,GAAAC,EAAAC,GAAA,GASA,QAAAI,GAAAC,EAAAC,EAAAC,GACA,GACAC,GADAC,EAAAH,EAAAI,SAIA,IAAAP,OAAAQ,OACAH,EAAAH,EAAAK,UAAAP,OAAAQ,OAAAF,GACAD,EAAAI,YAAAP,MACK,CACLP,EAAAO,EAAAC,EACA,IAAAO,GAAA,WACAC,KAAAF,YAAAP,EAEAQ,GAAAH,UAAAD,EACAD,EAAAH,EAAAK,UAAA,GAAAG,GAGAN,GACAT,EAAAU,EAAAD,GAGAC,EAAAO,OAAAN,EASA,QAAAO,GAAAC,EAAAzB,GACA,kBACA,MAAAyB,GAAAC,MAAA1B,EAAA2B,YAWA,QAAAC,GAAAC,EAAAC,GACA,aAAAD,IAAAE,GACAF,EAAAH,MAAAI,IAAA,IAAA/C,IAAA+C,GAEAD,EASA,QAAAG,GAAAC,EAAAC,GACA,MAAAD,KAAArC,EAAAsC,EAAAD,EASA,QAAAE,GAAAC,EAAAC,EAAAC,GACAzC,EAAA0C,EAAAF,GAAA,SAAAG,GACAJ,EAAA/C,iBAAAmD,EAAAF,GAAA,KAUA,QAAAG,GAAAL,EAAAC,EAAAC,GACAzC,EAAA0C,EAAAF,GAAA,SAAAG,GACAJ,EAAAM,oBAAAF,EAAAF,GAAA,KAWA,QAAAK,GAAAC,EAAAC,GACA,KAAAD,GAAA,CACA,GAAAA,GAAAC,EACA,QAEAD,KAAAE,WAEA,SAcA,QAAAC,GAAAC,EAAAC,GACA,MAAAD,GAAAxD,QAAAyD,GAAA,GAQA,QAAAV,GAAAS,GACA,MAAAA,GAAAE,OAAAC,MAAA,QAUA,QAAAC,GAAA5C,EAAAyC,EAAAI,GACA,GAAA7C,EAAAhB,UAAA6D,EACA,MAAA7C,GAAAhB,QAAAyD,EAEA,QAAAhD,GAAA,EAAAC,EAAAM,EAAAJ,OAAyCF,EAAAD,EAASA,IAClD,GAAAoD,GAAA7C,EAAAP,GAAAoD,IAAAJ,IAAAI,GAAA7C,EAAAP,KAAAgD,EACA,MAAAhD,EAGA,UASA,QAAAqD,GAAAxD,GACA,MAAAyD,OAAArC,UAAAsC,MAAA7E,KAAAmB,EAAA,GASA,QAAA2D,GAAAjD,EAAAkD,GAGA,OAFAC,MACAC,KACA3D,EAAA,EAAAC,EAAAM,EAAAJ,OAAqCF,EAAAD,EAASA,IAAA,CAC9C,GAAA4B,GAAA6B,EAAAlD,EAAAP,GAAAyD,GAAAlD,EAAAP,EACAmD,GAAAQ,EAAA/B,GAAA,GACA8B,EAAAE,KAAArD,EAAAP,IAEA2D,EAAA3D,GAAA4B,EAEA,MAAA8B,GASA,QAAAG,GAAAhE,EAAAiE,GAIA,OAHAC,GAAAC,EACAC,EAAAH,EAAA,GAAAI,cAAAJ,EAAAP,MAAA,GAEAvD,EAAA,EAAAC,EAAAkE,GAAAhE,OAAiDF,EAAAD,EAASA,IAI1D,GAHA+D,EAAAI,GAAAnE,GACAgE,EAAA,EAAAD,EAAAE,EAAAH,EAEAE,IAAAnE,GACA,MAAAmE,EAGA,OAAArE,GAQA,QAAAyE,KACA,MAAAC,MAyCA,QAAAC,GAAAC,EAAAC,GACA,GAAAC,GAAApD,IACAA,MAAAkD,UACAlD,KAAAmD,WAIAnD,KAAAqD,WAAA,SAAArF,GACAsC,EAAA8C,EAAAF,QAAAI,QAAAC,QAAAH,EAAAF,WACAE,EAAApC,QAAAhD,IAIAgC,KAAAwD,MAAA3C,EAAAb,KAAAkD,QAAApC,QAAAd,KAAAwD,KAAAxD,KAAAqD,YACArD,KAAAyD,OAAA5C,EAAApD,EAAAuC,KAAAyD,MAAAzD,KAAAqD,YAwBA,QAAAK,GAAAR,GACA,GAAAS,EAUA,YARAA,EADAC,GACAC,EACKC,GACLC,EACKC,GAGLC,EAFAC,GAIAhB,EAAAiB,GASA,QAAAA,GAAAjB,EAAAkB,EAAAC,GACA,GAAAC,GAAAD,EAAAE,SAAAzF,OACA0F,EAAAH,EAAAI,gBAAA3F,OACA4F,EAAAN,EAAAO,IAAAL,EAAAE,IAAA,EACAI,EAAAR,EAAAS,IAAAP,EAAAE,IAAA,CAEAH,GAAAK,UACAL,EAAAO,UAEAF,IACAxB,EAAA4B,YAIAT,EAAAD,YAGAW,EAAA7B,EAAAmB,GAEAnB,EAAA8B,UAAAX,GAQA,QAAAU,GAAA7B,EAAAmB,GACA,GAAAS,GAAA5B,EAAA4B,QACAP,EAAAF,EAAAE,SACAU,EAAAV,EAAAzF,MAGAgG,GAAAI,aACAJ,EAAAI,WAAAC,EAAAd,IAIAY,EAAA,IAAAH,EAAAM,cACAN,EAAAM,cAAAD,EAAAd,GACK,IAAAY,IACLH,EAAAM,eAAA,EAGA,IAAAF,GAAAJ,EAAAI,WACAE,EAAAN,EAAAM,cACAC,EAAAD,IAAAE,OAAAJ,EAAAI,OACAA,EAAAC,EAAAhB,EAEAF,GAAAmB,UAAAC,KAAAC,MACArB,EAAAsB,UAAAtB,EAAAmB,UAAAN,EAAAM,UACAnB,EAAAuB,OAAAN,EAAAO,EAAAR,EAAAQ,EACAxB,EAAAyB,OAAAR,EAAAS,EAAAV,EAAAU,EAEA1B,EAAAiB,SACAjB,EAAA2B,MAAAC,EAAAZ,EAAAC,GACAjB,EAAA6B,SAAAC,EAAAd,EAAAC,GACAjB,EAAA+B,gBAAAC,EAAAhC,EAAAuB,OAAAvB,EAAAyB,QAEAzB,EAAAiC,MAAAlB,EAAAmB,EAAAnB,EAAAb,YAAA,EACAF,EAAAmC,SAAApB,EAAAqB,EAAArB,EAAAb,YAAA,CAGA,IAAAzG,GAAAoF,EAAApC,OACAO,GAAAgD,EAAAqC,SAAA5I,YACAA,EAAAuG,EAAAqC,SAAA5I,QAEAuG,EAAAvG,SAEA6I,EAAA7B,EAAAT,GAQA,QAAAsC,GAAA7B,EAAAT,GACA,GAAAuC,GAAA9B,EAAA+B,YACAD,KACAA,EAAA9B,EAAA+B,aAAA1B,EAAAd,GAGA,IACAyC,GACAC,EACAC,EACAC,EAJAtB,EAAAtB,EAAAmB,UAAAoB,EAAApB,SAMA,IAAAG,EAAAuB,IAAAN,EAAAE,WAAAxI,EAAA,CACA,GAAAsH,GAAAgB,EAAAhB,OAAAvB,EAAAuB,OACAE,EAAAc,EAAAd,OAAAzB,EAAAyB,OAEAqB,EAAAC,EAAAzB,EAAAC,EAAAE,EACAiB,GAAAI,EAAAtB,EACAmB,EAAAG,EAAApB,EACAe,EAAAO,KAAAC,IAAAH,EAAAtB,EAAAsB,EAAApB,GACAkB,EAAAZ,EAAAT,EAAAE,OAGAgB,GAAAF,EAAAE,SACAC,EAAAH,EAAAG,UACAC,EAAAJ,EAAAI,UACAC,EAAAL,EAAAK,SAGA5C,GAAAyC,WACAzC,EAAA0C,YACA1C,EAAA2C,YACA3C,EAAA4C,YAQA,QAAA9B,GAAAd,GAIA,OADAE,MACA5F,EAAA,EAAmBA,EAAA0F,EAAAE,SAAAzF,OAA2BH,IAC9C4F,EAAA5F,IACA4I,QAAAC,GAAAnD,EAAAE,SAAA5F,GAAA4I,SACAE,QAAAD,GAAAnD,EAAAE,SAAA5F,GAAA8I,SAIA,QACAjC,UAAAC,KAAAC,MACAnB,WACAe,OAAAC,EAAAhB,GACAqB,OAAAvB,EAAAuB,OACAE,OAAAzB,EAAAyB,QASA,QAAAP,GAAAhB,GACA,GAAAU,GAAAV,EAAAzF,MAGA,QAAAmG,EACA,OACAY,EAAA2B,GAAAjD,EAAA,GAAAgD,SACAxB,EAAAyB,GAAAjD,EAAA,GAAAkD,SAKA,QADA5B,GAAA,EAAAE,EAAA,EACApH,EAAA,EAAmBsG,EAAAtG,EAAoBA,IACvCkH,GAAAtB,EAAA5F,GAAA4I,QACAxB,GAAAxB,EAAA5F,GAAA8I,OAGA,QACA5B,EAAA2B,GAAA3B,EAAAZ,GACAc,EAAAyB,GAAAzB,EAAAd,IAWA,QAAAmC,GAAAzB,EAAAE,EAAAE,GACA,OACAF,EAAAwB,KAAAK,IAAA7B,EAAAF,IAAA,EACAI,EAAAsB,KAAAK,IAAA3B,EAAAJ,IAAA,GAUA,QAAAU,GAAAR,EAAAE,GACA,MAAAF,KAAAE,EACA4B,GAGAN,KAAAK,IAAA7B,IAAAwB,KAAAK,IAAA3B,GACAF,EAAA,EAAA+B,GAAAC,GAEA9B,EAAA,EAAA+B,GAAAC,GAUA,QAAA5B,GAAA6B,EAAAC,EAAAC,GACAA,IACAA,EAAAC,GAEA,IAAAtC,GAAAoC,EAAAC,EAAA,IAAAF,EAAAE,EAAA,IACAnC,EAAAkC,EAAAC,EAAA,IAAAF,EAAAE,EAAA,GAEA,OAAAb,MAAAe,KAAAvC,IAAAE,KAUA,QAAAE,GAAA+B,EAAAC,EAAAC,GACAA,IACAA,EAAAC,GAEA,IAAAtC,GAAAoC,EAAAC,EAAA,IAAAF,EAAAE,EAAA,IACAnC,EAAAkC,EAAAC,EAAA,IAAAF,EAAAE,EAAA,GACA,YAAAb,KAAAgB,MAAAtC,EAAAF,GAAAwB,KAAAiB,GASA,QAAA7B,GAAA8B,EAAAC,GACA,MAAAvC,GAAAuC,EAAA,GAAAA,EAAA,GAAAC,IAAAxC,EAAAsC,EAAA,GAAAA,EAAA,GAAAE,IAUA,QAAAlC,GAAAgC,EAAAC,GACA,MAAArC,GAAAqC,EAAA,GAAAA,EAAA,GAAAC,IAAAtC,EAAAoC,EAAA,GAAAA,EAAA,GAAAE,IAkBA,QAAAvE,KACAlE,KAAAwD,KAAAkF,GACA1I,KAAAyD,MAAAkF,GAEA3I,KAAA4I,OAAA,EACA5I,KAAA6I,SAAA,EAEA5F,EAAA7C,MAAAJ,KAAAK,WA0EA,QAAAwD,KACA7D,KAAAwD,KAAAsF,GACA9I,KAAAyD,MAAAsF,GAEA9F,EAAA7C,MAAAJ,KAAAK,WAEAL,KAAAgJ,MAAAhJ,KAAAkD,QAAA4B,QAAAmE,iBAmEA,QAAAlF,KACA/D,KAAAwD,KAAA0F,GACAlJ,KAAAmJ,aAEAlG,EAAA7C,MAAAJ,KAAAK,WAyBA,QAAA+I,GAAApL,EAAAqL,GACA,GAAA1K,GAAAC,EAEAuK,EAAAE,EAAAF,UACAG,EAAAtH,EAAAhE,EAAAsL,eACAC,EAAAvH,EAAAhE,EAAAuL,gBACAC,IAGA,kBAAAxL,EAAAkD,KACA,IAAAvC,EAAA,EAAAC,EAAA0K,EAAAxK,OAA+CF,EAAAD,EAASA,IACxDwK,EAAAG,EAAA3K,GAAA8K,aAAA,CAKA,KAAA9K,EAAA,EAAAC,EAAA2K,EAAAzK,OAA4CF,EAAAD,EAASA,IACrDwK,EAAAI,EAAA5K,GAAA8K,aACAD,EAAAjH,KAAAgH,EAAA5K,KAIA,YAAAX,EAAAkD,MAAA,eAAAlD,EAAAkD,aACAiI,GAAAI,EAAA5K,GAAA8K,WAIA,QAGAtH,EAAAmH,EAAAI,OAAAF,GAAA,cAGAA,GAaA,QAAAvF,KACAhB,EAAA7C,MAAAJ,KAAAK,UAEA,IAAAW,GAAAd,EAAAF,KAAAgB,QAAAhB,KACAA,MAAA2J,MAAA,GAAA5F,GAAA/D,KAAAkD,QAAAlC,GACAhB,KAAA4J,MAAA,GAAA1F,GAAAlE,KAAAkD,QAAAlC,GAyDA,QAAA6I,GAAA3G,EAAA4G,GACA9J,KAAAkD,UACAlD,KAAA+J,IAAAD,GA0FA,QAAAE,GAAAC,GAEA,MAAAxI,GAAAwI,EAAAC,IACAA,GAGAzI,EAAAwI,EAAAE,KAAA1I,EAAAwI,EAAAG,IACAH,EAAA9L,QAAA,oBAAAkM,GACA,eAAAC,KAAAD,GACAA,EAEA,KAIA5I,EAAAwI,EAAAM,IACAA,GAGAC,GA4CA,QAAAC,GAAAnH,GACAtD,KAAA7C,GAAA4F,IAEA/C,KAAAkD,QAAA,KACAlD,KAAAsD,QAAAnE,EAAAmE,MAAsCtD,KAAA0K,UAGtC1K,KAAAsD,QAAAC,OAAA7C,EAAAV,KAAAsD,QAAAC,QAAA,GAEAvD,KAAA2K,MAAAC,GAEA5K,KAAA6K,gBACA7K,KAAA8K,eA+LA,QAAAC,GAAAJ,GACA,MAAAA,GAAAK,GACA,SACKL,EAAAM,GACL,MACKN,EAAAO,GACL,OACKP,EAAAQ,GACL,QAEA,GAQA,QAAAC,GAAAnE,GACA,MAAAA,IAAAc,GACA,OACKd,GAAAa,GACL,KACKb,GAAAW,GACL,OACKX,GAAAY,GACL,QAEA,GASA,QAAAwD,GAAAC,EAAAC,GACA,GAAArI,GAAAqI,EAAArI,OACA,OAAAA,GACAA,EAAAsI,IAAAF,GAEAA,EAQA,QAAAG,KACAhB,EAAArK,MAAAJ,KAAAK,WA6DA,QAAAqL,KACAD,EAAArL,MAAAJ,KAAAK,WAEAL,KAAA2L,GAAA,KACA3L,KAAA4L,GAAA,KAkFA,QAAAC,KACAJ,EAAArL,MAAAJ,KAAAK,WAsCA,QAAAyL,KACArB,EAAArK,MAAAJ,KAAAK,WAEAL,KAAA+L,OAAA,KACA/L,KAAAgM,OAAA,KA8DA,QAAAC,KACAR,EAAArL,MAAAJ,KAAAK,WA8BA,QAAA6L,KACAT,EAAArL,MAAAJ,KAAAK,WAyDA,QAAA8L,KACA1B,EAAArK,MAAAJ,KAAAK,WAIAL,KAAAoM,OAAA,EACApM,KAAAqM,SAAA,EAEArM,KAAA+L,OAAA,KACA/L,KAAAgM,OAAA,KACAhM,KAAAsM,MAAA,EAuGA,QAAA5O,IAAAoD,EAAAwC,GAGA,MAFAA,SACAA,EAAAiJ,YAAA7L,EAAA4C,EAAAiJ,YAAA7O,GAAAgN,SAAA8B,iBACA,GAAAC,IAAA3L,EAAAwC,GAmHA,QAAAmJ,IAAA3L,EAAAwC,GACAA,QAEAtD,KAAAsD,QAAAnE,EAAAmE,EAAA5F,GAAAgN,UAEA1K,KAAA0M,YACA1M,KAAA8E,WACA9E,KAAAuM,eAEAvM,KAAAc,UACAd,KAAAqE,MAAAX,EAAA1D,MACAA,KAAA2M,YAAA,GAAA9C,GAAA7J,UAAAsD,QAAAqJ,aAEAC,GAAA5M,MAAA,GAEAzB,EAAA+E,EAAAiJ,YAAA,SAAAM,GACA,GAAAtB,GAAAvL,KAAA8M,IAAA,GAAAD,GAAA,GAAAA,EAAA,IACAA,GAAA,IAAAtO,EAAAsO,EAAA,GAAAtB,EAAAwB,cAAAxB,GACAsB,EAAA,IAAAtO,EAAAsO,EAAA,GAAAtB,EAAAyB,eAAAzB,IACKvL,MAgNL,QAAA4M,IAAA1J,EAAA4J,GACA,GAAAhM,GAAAoC,EAAApC,QACAmM,EAAA/J,EAAAI,QAAA2J,QAEA1O,GAAA0O,EAAA,SAAAnD,EAAAoD,GACApM,EAAAqM,MAAA3K,EAAA1B,EAAAqM,MAAAD,IAAAJ,EAAAhD,EAAA,IAGA,IAAAsD,GAAAN,GAAA,WAAqC,SACrC,SAAAG,EAAAI,aAAwCvM,EAAAwM,cAAAF,GACxC,QAAAH,EAAAM,WAAsCzM,EAAA0M,YAAAJ,GAQtC,QAAAK,IAAAC,EAAAC,GACA,GAAAC,GAAAhQ,SAAAiQ,YAAA,QACAD,GAAAE,UAAAJ,GAAA,MACAE,EAAAG,QAAAJ,EACAA,EAAA7P,OAAAkQ,cAAAJ,GAvmEA,GAAA9K,KAAA,iCAEArC,GAAA,WACAwN,GAAA,YAuKAzG,GAAAH,KAAAG,MA8FAxE,GAAA,EAKAkL,GAAA,wCAEAlK,GAAA,gBAAAvG,GACAmG,GAAApB,EAAA/E,EAAA,kBAAAa,EACAwF,GAAAE,IAAAkK,GAAA5D,KAAA6D,UAAAC,WAEAC,GAAA,QACAC,GAAA,MACAC,GAAA,QACAC,GAAA,SAEAtH,GAAA,GAEAvC,GAAA,EACA8J,GAAA,EACA5J,GAAA,EACA6J,GAAA,EAEA/G,GAAA,EACAC,GAAA,EACAC,GAAA,EACAC,GAAA,EACAC,GAAA,GAEA4G,GAAA/G,GAAAC,GACA+G,GAAA9G,GAAAC,GACA8G,GAAAF,GAAAC,GAEAzG,IAAA,SACAM,IAAA,oBA0BAxF,GAAArD,WAKAoB,QAAA,aAKA8N,QAAA,WACA9O,KAAA+O,UAAA5N,EAAAnB,KAAAkD,QAAApC,QAAAd,KAAA+O,SAAA/O,KAAAqD,YACArD,KAAAgP,WAAA7N,EAAA1D,EAAAuC,KAAAgP,UAAAhP,KAAAqD,aAuRA,IAAA4L,KACAC,UAAAvK,GACAwK,UAAAV,GACAW,QAAAvK,GACAwK,SAAAX,IAGAhG,GAAA,YACAC,GAAA,4BAiBArJ,GAAA4E,EAAAjB,GAKAjC,QAAA,SAAAhD,GACA,GAAAoG,GAAA6K,GAAAjR,EAAAkD,KAYA,IATAkD,EAAAO,IAAA,IAAA3G,EAAAsR,SACAtP,KAAA6I,SAAA,GAGAzE,EAAAqK,IAAA,IAAAzQ,EAAAuR,QACAnL,EAAAS,IAIA7E,KAAA6I,SAAA7I,KAAA4I,MAAA,CAKA,GAAA9K,GAAAE,EAAAwR,eAAAxR,EAAAyR,WAAAzR,EAAAF,MACA,aAAAE,EAAAkD,MAAA,QAAApD,EAAA4R,WACAtL,EAAAqK,IAGArK,GAAAS,GAAA6J,MACA1O,KAAA6I,SAAA,GAGA7I,KAAAmD,SAAAnD,KAAAkD,QAAAkB,GACAG,UAAAvG,GACAyG,iBAAAzG,GACA2R,YAAApB,GACA7H,SAAA1I,OAKA,IAAA4R,KACAC,YAAAlL,GACAmL,YAAArB,GACAsB,UAAAlL,GACAmL,cAAAtB,GACAuB,WAAAvB,IAIAwB,IACAC,EAAA9B,GACA+B,EAAA9B,GACA+B,EAAA9B,GACA+B,EAAA9B,IAGA1F,GAAA,kDACAC,GAAA,YAGAtL,GAAA8S,iBACAzH,GAAA,0DACAC,GAAA,gBAiBAzJ,EAAAuE,EAAAZ,GAKAjC,QAAA,SAAAhD,GACA,GAAAgL,GAAAhJ,KAAAgJ,MACAwH,GAAA,EAEAC,EAAAzS,EAAAkD,KAAAwP,cAAAvS,QAAA,SACAiG,EAAAwL,GAAAa,GACAd,EAAAO,GAAAlS,EAAA2R,cAAA3R,EAAA2R,YAGA7R,EAAAE,EAAAwR,eAAAxR,EAAAyR,WAAAzR,EAAAF,MACA,eAAA2S,GAAA,QAAA3S,EAAA4R,WACAtL,EAAAqK,IAIArK,EAAAO,KAAA,IAAA3G,EAAAsR,QAAAK,GAAAtB,IACArF,EAAAzG,KAAAvE,GACSoG,GAAAS,GAAA6J,MACT8B,GAAA,EAKA,IAAAG,GAAA7O,EAAAkH,EAAAhL,EAAA4S,UAAA,YACA,GAAAD,IAKA3H,EAAA2H,GAAA3S,EAEAgC,KAAAmD,SAAAnD,KAAAkD,QAAAkB,GACAG,SAAAyE,EACAvE,iBAAAzG,GACA2R,cACAjJ,SAAA1I,IAGAwS,GAEAxH,EAAA6H,OAAAF,EAAA,MAKA,IAAAG,KACAC,WAAApM,GACAqM,UAAAvC,GACAwC,SAAApM,GACAqM,YAAAxC,IAGAxF,GAAA,2CAcA5J,GAAAyE,EAAAd,GAKAjC,QAAA,SAAAhD,GACA,GAAAmT,GAAA/H,EAAApL,EAAAgC,KACAA,MAAAmD,SAAAnD,KAAAkD,QAAA4N,GAAA9S,EAAAkD,OACAqD,SAAA4M,EAAA,GACA1M,gBAAA0M,EAAA,GACAxB,YAAAtB,GACA3H,SAAA1I,OAiEAsB,EAAA2E,EAAAhB,GAOAjC,QAAA,SAAAkC,EAAAkO,EAAAC,GACA,GAAAC,GAAAD,EAAA1B,aAAAtB,GACAkD,EAAAF,EAAA1B,aAAApB,EAIA,IAAA+C,EACAtR,KAAA4J,MAAAhB,OAAA,MACS,IAAA2I,IAAAvR,KAAA4J,MAAAhB,MACT,MAIAwI,IAAAvM,GAAA6J,MACA1O,KAAA4J,MAAAhB,OAAA,GAGA5I,KAAAmD,SAAAD,EAAAkO,EAAAC,IAMAvC,QAAA,WACA9O,KAAA2J,MAAAmF,UACA9O,KAAA4J,MAAAkF,YAIA,IAAA0C,IAAAhP,EAAA5E,SAAA6T,KAAAtE,MAAA,eACAuE,GAAAF,KAAAlT,EAGAqT,GAAA,UACAnH,GAAA,OACAD,GAAA,eACAL,GAAA,OACAC,GAAA,QACAC,GAAA,OAcAP,GAAAjK,WAKAmK,IAAA,SAAAD,GAEAA,GAAA6H,KACA7H,EAAA9J,KAAA4R,WAGAF,KACA1R,KAAAkD,QAAApC,QAAAqM,MAAAqE,IAAA1H,GAEA9J,KAAAiK,QAAAH,EAAA4G,eAMAmB,OAAA,WACA7R,KAAA+J,IAAA/J,KAAAkD,QAAAI,QAAAqJ,cAOAiF,QAAA,WACA,GAAA9H,GACAG,IAQA,OANA1L,GAAAyB,KAAAkD,QAAAqJ,YAAA,SAAAhB,GACAjL,EAAAiL,EAAAjI,QAAAC,OAAAgI,KACAtB,IAAAP,OAAA6B,EAAAuG,qBAGAhI,EAAA3H,EAAA8H,GAAA8H,KAAA,KACA/H,EAAAF,IAOAkI,gBAAA,SAAA3N,GAEA,IAAAqN,GAAA,CAIA,GAAAhL,GAAArC,EAAAqC,SACAO,EAAA5C,EAAA+B,eAGA,IAAApG,KAAAkD,QAAA4B,QAAAmN,UAEA,WADAvL,GAAAtI,gBAIA,IAAA6L,GAAAjK,KAAAiK,QACAiI,EAAAzQ,EAAAwI,EAAAC,IACAiI,EAAA1Q,EAAAwI,EAAAG,IACAgI,EAAA3Q,EAAAwI,EAAAE,GAEA,OAAA+H,IAAAC,GAAAC,GACAD,GAAAlL,EAAA0H,IACAyD,GAAAnL,EAAA2H,GACA5O,KAAAqS,WAAA3L,GAHA,SAWA2L,WAAA,SAAA3L,GACA1G,KAAAkD,QAAA4B,QAAAmN,WAAA,EACAvL,EAAAtI,kBA0DA,IAAAwM,IAAA,EACAO,GAAA,EACAD,GAAA,EACAD,GAAA,EACAqH,GAAArH,GACAD,GAAA,GACAuH,GAAA,EAuBA9H,GAAA7K,WAKA8K,YAOAX,IAAA,SAAAyI,EAAAjS,GAKA,MAJAP,MAAAsD,QAAAkP,GAAAjS,EAGAP,KAAAkD,SAAAlD,KAAAkD,QAAAyJ,YAAAkF,SACA7R,MAQA+M,cAAA,SAAAzB,GACA,GAAAT,GAAA7K,KAAA6K,YAMA,OALAS,GAAAD,EAAAC,EAAAtL,MACA6K,EAAAS,EAAAnO,MACA0N,EAAAS,EAAAnO,IAAAmO,EACAA,EAAAyB,cAAA/M,OAEAA,MAQAyS,kBAAA,SAAAnH,GAGA,MAFAA,GAAAD,EAAAC,EAAAtL,YACAA,MAAA6K,aAAAS,EAAAnO,IACA6C,MAQAgN,eAAA,SAAA1B,GACA,GAAAR,GAAA9K,KAAA8K,WAMA,OALAQ,GAAAD,EAAAC,EAAAtL,MACA,KAAA8B,EAAAgJ,EAAAQ,KACAR,EAAAvI,KAAA+I,GACAA,EAAA0B,eAAAhN,OAEAA,MAQA0S,mBAAA,SAAApH,GACAA,EAAAD,EAAAC,EAAAtL,KACA,IAAA2S,GAAA7Q,EAAA9B,KAAA8K,YAAAQ,EAIA,OAHAqH,GAAA,IACA3S,KAAA8K,YAAA+F,OAAA8B,EAAA,GAEA3S,MAOA4S,mBAAA,WACA,MAAA5S,MAAA8K,YAAAhM,OAAA,GAQA+T,iBAAA,SAAAvH,GACA,QAAAtL,KAAA6K,aAAAS,EAAAnO,KAQA2V,KAAA,SAAAzO,GACArE,KAAAkD,QAAA4P,KAAA9S,KAAAsD,QAAAoK,MAAArJ,GACArE,KAAAkD,QAAA4P,KAAA9S,KAAAsD,QAAAoK,MAAA3C,EAAA/K,KAAA2K,OAAAtG,IASA0O,QAAA,SAAA1O,GACA,MAAArE,MAAAgT,UACAhT,KAAA8S,KAAAzO,QAGArE,KAAA2K,MAAA4H,KAOAS,QAAA,WACA,OAAArU,GAAA,EAAuBA,EAAAqB,KAAA8K,YAAAhM,OAA6BH,IACpD,KAAAqB,KAAA8K,YAAAnM,GAAAgM,OAAA4H,GAAA3H,KACA,QAGA,WAOA5F,UAAA,SAAAqM,GAGA,GAAA4B,GAAAjU,KAAsCqS,EAGtC,OAAA/Q,GAAAN,KAAAsD,QAAAC,QAAAvD,KAAAiT,KAOAjT,KAAA2K,OAAA2H,GAAAtH,GAAAuH,MACAvS,KAAA2K,MAAAC,IAGA5K,KAAA2K,MAAA3K,KAAAkT,QAAAD,QAIAjT,KAAA2K,OAAAQ,GAAAD,GAAAD,GAAAD,KACAhL,KAAA+S,QAAAE,MAfAjT,KAAAmT,aACAnT,KAAA2K,MAAA4H,MAyBAW,QAAA,aAOApB,eAAA,aAOAqB,MAAA,cA8DA7T,EAAAmM,EAAAhB,GAKAC,UAKAnG,SAAA,GASA6O,SAAA,SAAA/O,GACA,GAAAgP,GAAArT,KAAAsD,QAAAiB,QACA,YAAA8O,GAAAhP,EAAAE,SAAAzF,SAAAuU,GASAH,QAAA,SAAA7O,GACA,GAAAsG,GAAA3K,KAAA2K,MACAvG,EAAAC,EAAAD,UAEAkP,EAAA3I,GAAAQ,GAAAD,IACAqI,EAAAvT,KAAAoT,SAAA/O,EAGA,OAAAiP,KAAAlP,EAAAsK,KAAA6E,GACA5I,EAAAK,GACSsI,GAAAC,EACTnP,EAAAS,GACA8F,EAAAM,GACaN,EAAAQ,GAGbR,EAAAO,GAFAC,GAIAoH,MAiBAjT,EAAAoM,EAAAD,GAKAf,UACAgD,MAAA,MACA8F,UAAA,GACAjP,SAAA,EACA0C,UAAA4H,IAGAiD,eAAA,WACA,GAAA7K,GAAAjH,KAAAsD,QAAA2D,SAEA,IAAAA,IAAA4H,GACA,OAAA3E,GAGA,IAAAD,KAOA,OANAhD,GAAA0H,IACA1E,EAAA1H,KAAA6H,IAEAnD,EAAA2H,IACA3E,EAAA1H,KAAA4H,IAEAF,GAGAwJ,cAAA,SAAApP,GACA,GAAAf,GAAAtD,KAAAsD,QACAoQ,GAAA,EACAxN,EAAA7B,EAAA6B,SACAe,EAAA5C,EAAA4C,UACApB,EAAAxB,EAAAuB,OACAG,EAAA1B,EAAAyB,MAiBA,OAZAmB,GAAA3D,EAAA2D,YACA3D,EAAA2D,UAAA0H,IACA1H,EAAA,IAAApB,EAAA8B,GAAA,EAAA9B,EAAA+B,GAAAC,GACA6L,EAAA7N,GAAA7F,KAAA2L,GACAzF,EAAAmB,KAAAK,IAAArD,EAAAuB,UAEAqB,EAAA,IAAAlB,EAAA4B,GAAA,EAAA5B,EAAA+B,GAAAC,GACA2L,EAAA3N,GAAA/F,KAAA4L,GACA1F,EAAAmB,KAAAK,IAAArD,EAAAyB,UAGAzB,EAAA4C,YACAyM,GAAAxN,EAAA5C,EAAAkQ,WAAAvM,EAAA3D,EAAA2D,WAGAmM,SAAA,SAAA/O,GACA,MAAAoH,GAAA7L,UAAAwT,SAAA/V,KAAA2C,KAAAqE,KACArE,KAAA2K,MAAAQ,MAAAnL,KAAA2K,MAAAQ,KAAAnL,KAAAyT,cAAApP,KAGAyO,KAAA,SAAAzO,GACArE,KAAA2L,GAAAtH,EAAAuB,OACA5F,KAAA4L,GAAAvH,EAAAyB,OAEA9F,KAAAC,OAAA6S,KAAAzV,KAAA2C,KAAAqE,EAEA,IAAA4C,GAAAmE,EAAA/G,EAAA4C,UACAA,IACAjH,KAAAkD,QAAA4P,KAAA9S,KAAAsD,QAAAoK,MAAAzG,EAAA5C,MAeA/E,EAAAuM,EAAAJ,GAKAf,UACAgD,MAAA,QACA8F,UAAA,EACAjP,SAAA,GAGAuN,eAAA,WACA,OAAA3H,GAAAC,KAGAgJ,SAAA,SAAA/O,GACA,MAAArE,MAAAC,OAAAmT,SAAA/V,KAAA2C,KAAAqE,KACAgD,KAAAK,IAAArD,EAAAiC,MAAA,GAAAtG,KAAAsD,QAAAkQ,WAAAxT,KAAA2K,MAAAQ,KAGA2H,KAAA,SAAAzO,GAEA,GADArE,KAAAC,OAAA6S,KAAAzV,KAAA2C,KAAAqE,GACA,IAAAA,EAAAiC,MAAA,CACA,GAAAqN,GAAAtP,EAAAiC,MAAA,YACAtG,MAAAkD,QAAA4P,KAAA9S,KAAAsD,QAAAoK,MAAAiG,EAAAtP,OAkBA/E,EAAAwM,EAAArB,GAKAC,UACAgD,MAAA,QACAnJ,SAAA,EACAqP,KAAA,IACAJ,UAAA,GAGA1B,eAAA,WACA,OAAAtH,KAGA0I,QAAA,SAAA7O,GACA,GAAAf,GAAAtD,KAAAsD,QAEAuQ,EAAAxP,EAAAE,SAAAzF,SAAAwE,EAAAiB,SACAuP,EAAAzP,EAAA6B,SAAA5C,EAAAkQ,UACAO,EAAA1P,EAAAsB,UAAArC,EAAAsQ,IAMA,IAJA5T,KAAAgM,OAAA3H,GAIAyP,IAAAD,GAAAxP,EAAAD,WAAAS,GAAA6J,MAAAqF,EACA/T,KAAAmT,YACS,IAAA9O,EAAAD,UAAAO,GAAA,CACT3E,KAAAmT,OACA,IAAA/P,GAAApD,IACAA,MAAA+L,OAAAiI,WAAA,WACA5Q,EAAAuH,MAAA2H,GACAlP,EAAA2P,WACazP,EAAAsQ,MAEb,MAAArB,KAGAY,MAAA,WACAc,aAAAjU,KAAA+L,QACA/L,KAAA+L,OAAA,MAGA+G,KAAA,WACA9S,KAAA2K,QAAA2H,KACAtS,KAAAgM,OAAAxG,UAAAC,KAAAC,MACA1F,KAAAkD,QAAA4P,KAAA9S,KAAAsD,QAAAoK,MAAA1N,KAAAgM,YAeA1M,EAAA2M,EAAAR,GAKAf,UACAgD,MAAA,SACA8F,UAAA,EACAjP,SAAA,GAGAuN,eAAA,WACA,OAAA5H,KAGAkJ,SAAA,SAAA/O,GACA,MAAArE,MAAAC,OAAAmT,SAAA/V,KAAA2C,KAAAqE,KACAgD,KAAAK,IAAArD,EAAAmC,UAAAxG,KAAAsD,QAAAkQ,WAAAxT,KAAA2K,MAAAQ,OAcA7L,EAAA4M,EAAAT,GAKAf,UACAgD,MAAA,QACA8F,UAAA,GACA1M,SAAA,IACAG,UAAA0H,GAAAC,GACArK,SAAA,GAGAuN,eAAA,WACA,MAAApG,GAAA9L,UAAAkS,eAAAzU,KAAA2C,OAGAoT,SAAA,SAAA/O,GACA,GACAyC,GADAG,EAAAjH,KAAAsD,QAAA2D,SAWA,OARAA,IAAA0H,GAAAC,IACA9H,EAAAzC,EAAAyC,SACSG,EAAA0H,GACT7H,EAAAzC,EAAA0C,UACSE,EAAA2H,KACT9H,EAAAzC,EAAA2C,WAGAhH,KAAAC,OAAAmT,SAAA/V,KAAA2C,KAAAqE,IACA4C,EAAA5C,EAAA4C,WACAH,EAAA9G,KAAAsD,QAAAwD,UAAAzC,EAAAD,UAAAS,IAGAiO,KAAA,SAAAzO,GACArE,KAAAkD,QAAA4P,KAAA9S,KAAAsD,QAAAoK,MAAArJ,EAEA,IAAA4C,GAAAmE,EAAA/G,EAAA4C,UACAA,IACAjH,KAAAkD,QAAA4P,KAAA9S,KAAAsD,QAAAoK,MAAAzG,EAAA5C,MA4BA/E,EAAA6M,EAAA1B,GAKAC,UACAgD,MAAA,MACAnJ,SAAA,EACA2P,KAAA,EACAC,MAAA,IACAC,SAAA,IACAR,KAAA,IACAJ,UAAA,EACAa,aAAA,IAGAvC,eAAA,WACA,OAAAvH,KAGA2I,QAAA,SAAA7O,GACA,GAAAjB,GAAApD,KACAsD,EAAAtD,KAAAsD,QAEAuQ,EAAAxP,EAAAE,SAAAzF,SAAAwE,EAAAiB,SACAuP,EAAAzP,EAAA6B,SAAA5C,EAAAkQ,UACAc,EAAAjQ,EAAAsB,UAAArC,EAAAsQ,IAIA,IAFA5T,KAAAmT,QAEA9O,EAAAD,UAAAO,IAAA,IAAA3E,KAAAsM,MACA,MAAAtM,MAAAuU,kBAKA,IAAAT,GAAAQ,GAAAT,EAAA,CACA,GAAAxP,EAAAD,UAAAS,GAAA,CACA,GAAA2P,GAAAxU,KAAAoM,MAAA/H,EAAAmB,UAAAxF,KAAAoM,MAAA9I,EAAA8Q,UAAA,EACAK,GAAAzU,KAAAqM,SAAAlG,EAAAnG,KAAAqM,QAAAhI,EAAAiB,QAAAhC,EAAA+Q,YAEArU,MAAAoM,MAAA/H,EAAAmB,UACAxF,KAAAqM,QAAAhI,EAAAiB,OAEAmP,GAAAD,EAGAxU,KAAAsM,OAAA,EAFAtM,KAAAsM,MAAA,EAKAtM,KAAAgM,OAAA3H,CAIA,IAAAqQ,GAAA1U,KAAAsM,MAAAhJ,EAAA4Q,IACA,QAAAQ,EACA,MAAA1U,MAAA4S,sBAGA5S,KAAA+L,OAAAiI,WAAA,WACA5Q,EAAAuH,MAAA2H,GACAlP,EAAA2P,WACyBzP,EAAA6Q,OACzBhJ,IANAmH,GAWA,MAAAtS,MAAAuU,mBAEA,MAAAhC,KAGAgC,iBAAA,WACA,GAAAnR,GAAApD,IAKA,OAJAA,MAAA+L,OAAAiI,WAAA,WACA5Q,EAAAuH,MAAA4H,IACSvS,KAAAsD,QAAA6Q,OAET5B,IAGAY,MAAA,WACAc,aAAAjU,KAAA+L,SAGA+G,KAAA,WACA9S,KAAA2K,OAAA2H,KACAtS,KAAAgM,OAAA0I,SAAA1U,KAAAsM,MACAtM,KAAAkD,QAAA4P,KAAA9S,KAAAsD,QAAAoK,MAAA1N,KAAAgM,YAqBAtO,GAAAiX,QAAA,WAMAjX,GAAAgN,UAOAkK,WAAA,EAQAjI,YAAAgF,GAMApO,QAAA,EAOAiJ,kBAEAP,GAA4B1I,QAAA,KAC5BsI,GAA2BtI,QAAA,IAAgB,YAC3C2I,GAA0BjF,UAAA0H,MAC1BjD,GAAyBzE,UAAA0H,KAAkC,WAC3DxC,IACAA,GAAyBuB,MAAA,YAAAwG,KAAA,IAA8B,SACvDpI,IAQAmB,UAOAI,WAAA,OAOAwH,YAAA,OASAC,aAAA,OAOAC,eAAA,OAOAxH,SAAA,OAQAyH,kBAAA,iBAIA,IAAAC,IAAA,EACAC,GAAA,CA8BAzI,IAAA7M,WAMAmK,IAAA,SAAAyI,EAAAjS,GACAP,KAAAsD,QAAAkP,GAAAjS,GASA4U,KAAA,SAAAC,GACApV,KAAA8E,QAAAuQ,QAAAD,EAAAF,GAAAD,IASAjQ,UAAA,SAAAqM,GACA,IAAArR,KAAA8E,QAAAuQ,QAAA,CAKArV,KAAA2M,YAAAqF,gBAAAX,EAEA,IAAA9F,GACAzG,EAAA9E,KAAA8E,QAKAwQ,EAAAxQ,EAAAwQ,gBAIAA,QAAA3K,MAAA2H,MACAgD,EAAAxQ,EAAAwQ,cAAA,KAGA,QAAA3W,GAAA,EAAAC,EAAAoB,KAAAuM,YAAAzN,OAAsDF,EAAAD,EAASA,IAC/D4M,EAAAvL,KAAAuM,YAAA5N,GAQAqB,KAAA8E,QAAAuQ,UAAAH,IACAI,GAAA/J,GAAA+J,IACA/J,EAAAsH,iBAAAyC,GAGA/J,EAAA4H,QAFA5H,EAAAvG,UAAAqM,IAOAiE,GAAA/J,EAAAZ,OAAAQ,GAAAD,GAAAD,MACAqK,EAAAxQ,EAAAwQ,cAAA/J,KAUAC,IAAA,SAAAD,GACA,GAAAA,YAAAd,GACA,MAAAc,EAIA,QADAgB,GAAAvM,KAAAuM,YACA5N,EAAA,EAAuBA,EAAA4N,EAAAzN,OAAwBH,IAC/C,GAAA4N,EAAA5N,GAAA2E,QAAAoK,OAAAnC,EACA,MAAAgB,GAAA5N,EAGA,cASAmO,IAAA,SAAAvB,GAEA,GAAAgK,GAAAvV,KAAAwL,IAAAD,EAAAjI,QAAAoK,MASA,OARA6H,IACAvV,KAAAwV,OAAAD,GAGAvV,KAAAuM,YAAAhK,KAAAgJ,GACAA,EAAArI,QAAAlD,KAEAA,KAAA2M,YAAAkF,SACAtG,GAOAiK,OAAA,SAAAjK,GACA,GAAAgB,GAAAvM,KAAAuM,WACAhB,GAAAvL,KAAAwL,IAAAD,GACAgB,EAAAsE,OAAA/O,EAAAyK,EAAAhB,GAAA,GAEAvL,KAAA2M,YAAAkF,UASA4D,GAAA,SAAAC,EAAA1U,GACA,GAAA0L,GAAA1M,KAAA0M,QAKA,OAJAnO,GAAA0C,EAAAyU,GAAA,SAAAhI,GACAhB,EAAAgB,GAAAhB,EAAAgB,OACAhB,EAAAgB,GAAAnL,KAAAvB,KAEAhB,MASA2V,IAAA,SAAAD,EAAA1U,GACA,GAAA0L,GAAA1M,KAAA0M,QAQA,OAPAnO,GAAA0C,EAAAyU,GAAA,SAAAhI,GACA1M,EAGA0L,EAAAgB,GAAAmD,OAAA/O,EAAA4K,EAAAgB,GAAA1M,GAAA,SAFA0L,GAAAgB,KAKA1N,MAQA8S,KAAA,SAAApF,EAAAC,GAEA3N,KAAAsD,QAAAsR,WACAnH,GAAAC,EAAAC,EAIA,IAAAjB,GAAA1M,KAAA0M,SAAAgB,EACA,IAAAhB,KAAA5N,OAAA,CAIA6O,EAAAzM,KAAAwM,EACAC,EAAAvP,eAAA,WACAuP,EAAAjH,SAAAtI,iBAGA,QAAAO,GAAA,EAAAC,EAAA8N,EAAA5N,OAA8CF,EAAAD,EAASA,IACvD+N,EAAA/N,GAAAgP,KAQAmB,QAAA,WACA9O,KAAAc,SACA8L,GAAA5M,MAAA,GAGAA,KAAA0M,YACA1M,KAAA8E,WACA9E,KAAAqE,MAAAyK,UACA9O,KAAAc,QAAA,OAkCA9B,EAAAtB,IACAiH,eACA8J,cACA5J,aACA6J,gBAEA9D,kBACAO,eACAD,iBACAD,eACAqH,oBACAtH,mBACAuH,gBAEA5K,kBACAC,kBACAC,mBACAC,gBACAC,kBACA4G,wBACAC,sBACAC,iBAEApC,WACAxJ,QACA4G,cAEAY,aACAgB,iBACAmK,IAAAzJ,EACA0J,IAAAnK,EACAoK,MAAA5J,EACA6J,MAAAlK,EACAmK,OAAA/J,EACAgK,MAAAnK,EAEA2J,GAAA5U,EACA8U,IAAAxU,EACA5C,OACAY,QACAH,SACAM,UACAY,SACAsC,aAGA,YAAA/B,IAAA3D,EAAA,IACAuB,EAAA,WACA,MAAAX,KACKL,KAAAJ,EAAAH,EAAAG,EAAAC,KAAAmB,IAAAC,IAAApB,EAAAD,QAAAoB,WACJnB,IAAA+Q,IAAA/Q,EAAAD,QACDC,EAAAD,QAAAS,GAEAD,EAAAC,WAGCD,SH6EK,WIhtEN,QAAAyY,KACAC,EAAAlY,UAAA,GAGA,QAAAmY,KACAC,GACAC,WAAoBzQ,EAAA0Q,EAAAxQ,EAAAyQ,GACpBlQ,MAAA,EACAmQ,OAAA,GAEAN,EAAAlY,UAAA,UACAyY,IAGA,QAAAC,KACA,GAAA7M,IACA,eAAAuM,EAAAC,UAAAzQ,EAAA,OAAAwQ,EAAAC,UAAAvQ,EAAA,SACA,SAAAsQ,EAAA/P,MAAA,KAAA+P,EAAA/P,MAAA,IACA,UAAA+P,EAAAI,OAAA,OACAN,GAAAhJ,MAAAyJ,gBAAAT,EAAAhJ,MAAAkJ,UAAAvM,EAAAiI,KAAA,KACA8E,GAAA,EAGA,QAAAH,KACAG,IACAA,GAAA,EACAC,EAAAH,IAIA,QAAAI,GAAA/Y,GACAqY,EAAAC,WACAzQ,EAAA0Q,EAAAvY,EAAA4H,OACAG,EAAAyQ,EAAAxY,EAAA8H,QAEA4Q,IAGA,QAAAM,GAAAhZ,GACAqY,EAAAC,WACAzQ,EAAA0Q,EAAA,IAAAvY,EAAA4H,OACAG,EAAAyQ,EAAA,IAAAxY,EAAA8H,QAEAuQ,EAAA/P,MAAA,IACAoQ,IAEA1C,WAAA,WACAoC,KACK,KAGL,QAAAa,GAAAjZ,GACAqY,EAAA/P,MAAAtI,EAAAsI,MACAoQ,IAGA,QAAAQ,GAAAlZ,GACAqY,EAAAI,OAAAzY,EAAAwI,SACAkQ,IAGA,QAAAS,KACAd,EAAA/P,MAAA,GACAoQ,IAEA1C,WAAA,WACAqC,EAAA/P,MAAA,EACAoQ,KACK,KAGL,QAAAU,KACAf,EAAAI,OAAAJ,EAAAI,OAAA,MACAC,IAGA,QAAAW,KACAlB,EAAAhJ,MAAAmK,WAAA,OACAtD,WAAA,WACAmC,EAAAhJ,MAAAmK,WAAA,QACAZ,KACK,KA/GL,GAYAL,GAZAS,EAAA,WACA,MAAArZ,QAAAC,OAAA8E,SAAA/E,OAAA,oCAAA0F,GACA1F,OAAAuW,WAAA7Q,EAAA,YAIAgT,EAAAvY,SAAAC,cAAA,YAEA0Y,EAAAlP,KAAAG,OAAA2O,EAAA3U,WAAA+V,YAAApB,EAAAoB,aAAA,GACAf,EAAAnP,KAAAG,OAAA2O,EAAA3U,WAAAgW,aAAArB,EAAAqB,cAAA,GAEAX,GAAA,EAGAY,EAAA,GAAA/Z,QAAAyY,EAEAsB,GAAAjM,IAAA,SAAAzB,IAAA,aACA0N,EAAAjM,IAAA,UAAAzB,IAAA,aAEA0N,EAAAhC,GAAA,MAAAsB,GACAU,EAAAhC,GAAA,QAAAuB,GACAS,EAAAhC,GAAA,SAAAyB,GACAO,EAAAhC,GAAA,QAAAwB,GACAQ,EAAAhC,GAAA,MAAA0B,GACAM,EAAAhC,GAAA,YAAA2B,GACAK,EAAAhC,GAAA,OAAA4B,GAEAI,EAAAhC,GAAA,kCAAAS,GACAuB,EAAAhC,GAAA,+DAAAW,GAsFAA,IAEAxY,SAAAC,cAAA,kBAAAE,iBAAA,mBACAH,SAAAC,cAAA,WAAA6Z,UAAA/Z,OAAA,gBACC,IJyvEK,WKn3EN,GAAAga,SAAAC,KAAA1Z,QAAA,kBACA,GAAA2Z,QACAA,GAAAtV,MAAA,gCACAsV,EAAAtV,MAAA,mBACA,WACA,GAAAuV,GAAAla,SAAAma,cAAA,SACAD,GAAA5W,KAAA,kBACA4W,EAAAE,OAAA,EACAF,EAAA5Y,KAAA,UAAAtB,SAAA+Z,SAAAM,SAAA,qDACA,IAAAC,GAAAta,SAAAua,qBAAA,YACAD,GAAA1W,WAAA4W,aAAAN,EAAAI,OAIA,SAAAG,EAAAH,EAAA/a,GACA,GAAAmb,GAAAC,EAAAF,EAAAF,qBAAAD,GAAA,EACAG,GAAAG,eAAArb,KACAmb,EAAAD,EAAAN,cAAAG,GACAI,EAAAnb,KACAmb,EAAApZ,IAAA,oCACAqZ,EAAA/W,WAAA4W,aAAAE,EAAAC,KAEC3a,SAAA,yBL03EK,SAASV,EAAQD,IMh5EvB,SAAAwb,GAAAvb,EAAAD,QAAAwb,INo5E8Bpb,KAAKJ","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/assets/js/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\twindow.Hammer = __webpack_require__(1);\r\n\t\r\n\tvar toggle = document.querySelector(\".toggle-sidebar\");\r\n\tvar target = document.querySelector(\".sidebar\");\r\n\tif(toggle && target) {\r\n\t    toggle.addEventListener(\"click\", function(ev) {\r\n\t        if(target.className.indexOf('show') === -1) {\r\n\t            target.className += ' show';\r\n\t        } else {\r\n\t            target.className = target.className.replace('show', '');\r\n\t        }\r\n\t        ev.preventDefault();\r\n\t    });\r\n\t}\r\n\t\r\n\t\r\n\tif(document.querySelector(\"#hitarea\")) {\r\n\t    __webpack_require__(2);\r\n\t}\r\n\t\r\n\t__webpack_require__(3);\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;(function(window, undefined) {\r\n\t  'use strict';\r\n\t\r\n\tvar VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];\r\n\t\r\n\tvar TYPE_FUNCTION = 'function';\r\n\tvar TYPE_UNDEFINED = 'undefined';\r\n\t\r\n\t/**\r\n\t * walk objects and arrays\r\n\t * @param {Object} obj\r\n\t * @param {Function} iterator\r\n\t * @param {Object} context\r\n\t */\r\n\tfunction each(obj, iterator, context) {\r\n\t    var i, len;\r\n\t\r\n\t    if (!obj) {\r\n\t        return;\r\n\t    }\r\n\t\r\n\t    if (obj.forEach) {\r\n\t        obj.forEach(iterator, context);\r\n\t    } else if (obj.length !== undefined) {\r\n\t        for (i = 0, len = obj.length; i < len; i++) {\r\n\t            iterator.call(context, obj[i], i, obj);\r\n\t        }\r\n\t    } else {\r\n\t        for (i in obj) {\r\n\t            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\t/**\r\n\t * extend object.\r\n\t * means that properties in dest will be overwritten by the ones in src.\r\n\t * @param {Object} dest\r\n\t * @param {Object} src\r\n\t * @param {Boolean} [merge]\r\n\t * @returns {Object} dest\r\n\t */\r\n\tfunction extend(dest, src, merge) {\r\n\t    var keys = Object.keys(src);\r\n\t    for (var i = 0, len = keys.length; i < len; i++) {\r\n\t        if (!merge || (merge && dest[keys[i]] === undefined)) {\r\n\t            dest[keys[i]] = src[keys[i]];\r\n\t        }\r\n\t    }\r\n\t    return dest;\r\n\t}\r\n\t\r\n\t/**\r\n\t * merge the values from src in the dest.\r\n\t * means that properties that exist in dest will not be overwritten by src\r\n\t * @param {Object} dest\r\n\t * @param {Object} src\r\n\t * @returns {Object} dest\r\n\t */\r\n\tfunction merge(dest, src) {\r\n\t    return extend(dest, src, true);\r\n\t}\r\n\t\r\n\t/**\r\n\t * simple class inheritance\r\n\t * @param {Function} child\r\n\t * @param {Function} base\r\n\t * @param {Object} [properties]\r\n\t */\r\n\tfunction inherit(child, base, properties) {\r\n\t    var baseP = base.prototype,\r\n\t        childP;\r\n\t\r\n\t    // object create is supported since IE9\r\n\t    if (Object.create) {\r\n\t        childP = child.prototype = Object.create(baseP);\r\n\t        childP.constructor = child;\r\n\t    } else {\r\n\t        extend(child, base);\r\n\t        var Inherited = function() {\r\n\t            this.constructor = child;\r\n\t        };\r\n\t        Inherited.prototype = baseP;\r\n\t        childP = child.prototype = new Inherited();\r\n\t    }\r\n\t\r\n\t    if (properties) {\r\n\t        extend(childP, properties);\r\n\t    }\r\n\t\r\n\t    childP._super = baseP;\r\n\t}\r\n\t\r\n\t/**\r\n\t * simple function bind\r\n\t * @param {Function} fn\r\n\t * @param {Object} context\r\n\t * @returns {Function}\r\n\t */\r\n\tfunction bindFn(fn, context) {\r\n\t    return function() {\r\n\t        return fn.apply(context, arguments);\r\n\t    };\r\n\t}\r\n\t\r\n\t/**\r\n\t * let a boolean value also be a function that must return a boolean\r\n\t * this first item in args will be used as the context\r\n\t * @param {Boolean|Function} val\r\n\t * @param {Array} [args]\r\n\t * @returns {Boolean}\r\n\t */\r\n\tfunction boolOrFn(val, args) {\r\n\t    if (typeof val == TYPE_FUNCTION) {\r\n\t        return val.apply(args ? args[0] || window : window, args);\r\n\t    }\r\n\t    return val;\r\n\t}\r\n\t\r\n\t/**\r\n\t * use the val2 when val1 is undefined\r\n\t * @param {*} val1\r\n\t * @param {*} val2\r\n\t * @returns {*}\r\n\t */\r\n\tfunction ifUndefined(val1, val2) {\r\n\t    return (val1 === undefined) ? val2 : val1;\r\n\t}\r\n\t\r\n\t/**\r\n\t * addEventListener with multiple events at once\r\n\t * @param {HTMLElement} element\r\n\t * @param {String} types\r\n\t * @param {Function} handler\r\n\t */\r\n\tfunction addEventListeners(element, types, handler) {\r\n\t    each(splitStr(types), function(type) {\r\n\t        element.addEventListener(type, handler, false);\r\n\t    });\r\n\t}\r\n\t\r\n\t/**\r\n\t * removeEventListener with multiple events at once\r\n\t * @param {HTMLElement} element\r\n\t * @param {String} types\r\n\t * @param {Function} handler\r\n\t */\r\n\tfunction removeEventListeners(element, types, handler) {\r\n\t    each(splitStr(types), function(type) {\r\n\t        element.removeEventListener(type, handler, false);\r\n\t    });\r\n\t}\r\n\t\r\n\t/**\r\n\t * find if a node is in the given parent\r\n\t * @method hasParent\r\n\t * @param {HTMLElement} node\r\n\t * @param {HTMLElement} parent\r\n\t * @return {Boolean} found\r\n\t */\r\n\tfunction hasParent(node, parent) {\r\n\t    while (node) {\r\n\t        if (node == parent) {\r\n\t            return true;\r\n\t        }\r\n\t        node = node.parentNode;\r\n\t    }\r\n\t    return false;\r\n\t}\r\n\t\r\n\t/**\r\n\t * store Math.round in a var, for better minimisation\r\n\t */\r\n\tvar round = Math.round;\r\n\t\r\n\t/**\r\n\t * small indexOf wrapper\r\n\t * @param {String} str\r\n\t * @param {String} find\r\n\t * @returns {Boolean} found\r\n\t */\r\n\tfunction inStr(str, find) {\r\n\t    return str.indexOf(find) > -1;\r\n\t}\r\n\t\r\n\t/**\r\n\t * split string on whitespace\r\n\t * @param {String} str\r\n\t * @returns {Array} words\r\n\t */\r\n\tfunction splitStr(str) {\r\n\t    return str.trim().split(/\\s+/g);\r\n\t}\r\n\t\r\n\t/**\r\n\t * find if a array contains the object using indexOf or a simple polyFill\r\n\t * @param {Array} src\r\n\t * @param {String} find\r\n\t * @param {String} [findByKey]\r\n\t * @return {Boolean|Number} false when not found, or the index\r\n\t */\r\n\tfunction inArray(src, find, findByKey) {\r\n\t    if (src.indexOf && !findByKey) {\r\n\t        return src.indexOf(find);\r\n\t    } else {\r\n\t        for (var i = 0, len = src.length; i < len; i++) {\r\n\t            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\r\n\t                return i;\r\n\t            }\r\n\t        }\r\n\t        return -1;\r\n\t    }\r\n\t}\r\n\t\r\n\t/**\r\n\t * convert array-like objects to real arrays\r\n\t * @param {Object} obj\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction toArray(obj) {\r\n\t    return Array.prototype.slice.call(obj, 0);\r\n\t}\r\n\t\r\n\t/**\r\n\t * unique array with objects based on a key (like 'id') or just by the array's value\r\n\t * @param {Array} src [{id:1},{id:2},{id:1}]\r\n\t * @param {String} [key]\r\n\t * @returns {Array} [{id:1},{id:2}]\r\n\t */\r\n\tfunction uniqueArray(src, key) {\r\n\t    var results = [];\r\n\t    var values = [];\r\n\t    for (var i = 0, len = src.length; i < len; i++) {\r\n\t        var val = key ? src[i][key] : src[i];\r\n\t        if (inArray(values, val) < 0) {\r\n\t            results.push(src[i]);\r\n\t        }\r\n\t        values[i] = val;\r\n\t    }\r\n\t    return results;\r\n\t}\r\n\t\r\n\t/**\r\n\t * get the prefixed property\r\n\t * @param {Object} obj\r\n\t * @param {String} property\r\n\t * @returns {String|Undefined} prefixed\r\n\t */\r\n\tfunction prefixed(obj, property) {\r\n\t    var prefix, prop;\r\n\t    var camelProp = property[0].toUpperCase() + property.slice(1);\r\n\t\r\n\t    for (var i = 0, len = VENDOR_PREFIXES.length; i < len; i++) {\r\n\t        prefix = VENDOR_PREFIXES[i];\r\n\t        prop = (prefix) ? prefix + camelProp : property;\r\n\t\r\n\t        if (prop in obj) {\r\n\t            return prop;\r\n\t        }\r\n\t    }\r\n\t    return undefined;\r\n\t}\r\n\t\r\n\t/**\r\n\t * get a unique id\r\n\t * @returns {number} uniqueId\r\n\t */\r\n\tvar _uniqueId = 1;\r\n\tfunction uniqueId() {\r\n\t    return _uniqueId++;\r\n\t}\r\n\t\r\n\tvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\r\n\t\r\n\tvar SUPPORT_TOUCH = ('ontouchstart' in window);\r\n\tvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\r\n\tvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\r\n\t\r\n\tvar INPUT_TYPE_TOUCH = 'touch';\r\n\tvar INPUT_TYPE_PEN = 'pen';\r\n\tvar INPUT_TYPE_MOUSE = 'mouse';\r\n\tvar INPUT_TYPE_KINECT = 'kinect';\r\n\t\r\n\tvar COMPUTE_INTERVAL = 25;\r\n\t\r\n\tvar INPUT_START = 1;\r\n\tvar INPUT_MOVE = 2;\r\n\tvar INPUT_END = 4;\r\n\tvar INPUT_CANCEL = 8;\r\n\t\r\n\tvar DIRECTION_NONE = 1;\r\n\tvar DIRECTION_LEFT = 2;\r\n\tvar DIRECTION_RIGHT = 4;\r\n\tvar DIRECTION_UP = 8;\r\n\tvar DIRECTION_DOWN = 16;\r\n\t\r\n\tvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\r\n\tvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\r\n\tvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\r\n\t\r\n\tvar PROPS_XY = ['x', 'y'];\r\n\tvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\r\n\t\r\n\t/**\r\n\t * create new input type manager\r\n\t * @param {Manager} manager\r\n\t * @param {Function} callback\r\n\t * @returns {Input}\r\n\t * @constructor\r\n\t */\r\n\tfunction Input(manager, callback) {\r\n\t    var self = this;\r\n\t    this.manager = manager;\r\n\t    this.callback = callback;\r\n\t\r\n\t    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\r\n\t    // so when disabled the input events are completely bypassed.\r\n\t    this.domHandler = function(ev) {\r\n\t        if (boolOrFn(self.manager.options.enable, [self.manager])) {\r\n\t            self.handler(ev);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    this.evEl && addEventListeners(this.manager.element, this.evEl, this.domHandler);\r\n\t    this.evWin && addEventListeners(window, this.evWin, this.domHandler);\r\n\t}\r\n\t\r\n\tInput.prototype = {\r\n\t    /**\r\n\t     * should handle the inputEvent data and trigger the callback\r\n\t     * @virtual\r\n\t     */\r\n\t    handler: function() { },\r\n\t\r\n\t    /**\r\n\t     * unbind the events\r\n\t     */\r\n\t    destroy: function() {\r\n\t        this.elEvents && removeEventListeners(this.manager.element, this.elEvents, this.domHandler);\r\n\t        this.winEvents && removeEventListeners(window, this.winEvents, this.domHandler);\r\n\t    }\r\n\t};\r\n\t\r\n\t/**\r\n\t * create new input type manager\r\n\t * @param {Hammer} manager\r\n\t * @returns {Input}\r\n\t */\r\n\tfunction createInputInstance(manager) {\r\n\t    var Type;\r\n\t    if (SUPPORT_POINTER_EVENTS) {\r\n\t        Type = PointerEventInput;\r\n\t    } else if (SUPPORT_ONLY_TOUCH) {\r\n\t        Type = TouchInput;\r\n\t    } else if (!SUPPORT_TOUCH) {\r\n\t        Type = MouseInput;\r\n\t    } else {\r\n\t        Type = TouchMouseInput;\r\n\t    }\r\n\t    return new (Type)(manager, inputHandler);\r\n\t}\r\n\t\r\n\t/**\r\n\t * handle input events\r\n\t * @param {Manager} manager\r\n\t * @param {String} eventType\r\n\t * @param {Object} input\r\n\t */\r\n\tfunction inputHandler(manager, eventType, input) {\r\n\t    var pointersLen = input.pointers.length;\r\n\t    var changedPointersLen = input.changedPointers.length;\r\n\t    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\r\n\t    var isFinal = (eventType & INPUT_END && (pointersLen - changedPointersLen === 0));\r\n\t\r\n\t    input.isFirst = isFirst;\r\n\t    input.isFinal = isFinal;\r\n\t\r\n\t    if (isFirst) {\r\n\t        manager.session = {};\r\n\t    }\r\n\t    // source event is the normalized value of the domEvents\r\n\t    // like 'touchstart, mouseup, pointerdown'\r\n\t    input.eventType = eventType;\r\n\t\r\n\t    // compute scale, rotation etc\r\n\t    computeInputData(manager, input);\r\n\t\r\n\t    manager.recognize(input);\r\n\t}\r\n\t\r\n\t/**\r\n\t * extend the data with some usable properties like scale, rotate, velocity etc\r\n\t * @param {Object} manager\r\n\t * @param {Object} input\r\n\t */\r\n\tfunction computeInputData(manager, input) {\r\n\t    var session = manager.session;\r\n\t    var pointers = input.pointers;\r\n\t    var pointersLength = pointers.length;\r\n\t\r\n\t    // store the first input to calculate the distance and direction\r\n\t    if (!session.firstInput) {\r\n\t        session.firstInput = simpleCloneInputData(input);\r\n\t    }\r\n\t\r\n\t    // to compute scale and rotation we need to store the multiple touches\r\n\t    if (pointersLength > 1 && !session.firstMultiple) {\r\n\t        session.firstMultiple = simpleCloneInputData(input);\r\n\t    } else if (pointersLength === 1) {\r\n\t        session.firstMultiple = false;\r\n\t    }\r\n\t\r\n\t    var firstInput = session.firstInput;\r\n\t    var firstMultiple = session.firstMultiple;\r\n\t    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\r\n\t    var center = getCenter(pointers);\r\n\t\r\n\t    input.timeStamp = Date.now();\r\n\t    input.deltaTime = input.timeStamp - firstInput.timeStamp;\r\n\t    input.deltaX = center.x - offsetCenter.x;\r\n\t    input.deltaY = center.y - offsetCenter.y;\r\n\t\r\n\t    input.center = center;\r\n\t    input.angle = getAngle(offsetCenter, center);\r\n\t    input.distance = getDistance(offsetCenter, center);\r\n\t    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\r\n\t\r\n\t    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\r\n\t    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\r\n\t\r\n\t    // find the correct target\r\n\t    var target = manager.element;\r\n\t    if (hasParent(input.srcEvent.target, target)) {\r\n\t        target = input.srcEvent.target;\r\n\t    }\r\n\t    input.target = target;\r\n\t\r\n\t    computeIntervalInputData(session, input);\r\n\t}\r\n\t\r\n\t/**\r\n\t * velocity is calculated every x ms\r\n\t * @param {Object} session\r\n\t * @param {Object} input\r\n\t */\r\n\tfunction computeIntervalInputData(session, input) {\r\n\t    var last = session.lastInterval;\r\n\t    if (!last) {\r\n\t        last = session.lastInterval = simpleCloneInputData(input);\r\n\t    }\r\n\t\r\n\t    var deltaTime = input.timeStamp - last.timeStamp,\r\n\t        velocity,\r\n\t        velocityX,\r\n\t        velocityY,\r\n\t        direction;\r\n\t\r\n\t    if (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined) {\r\n\t        var deltaX = last.deltaX - input.deltaX;\r\n\t        var deltaY = last.deltaY - input.deltaY;\r\n\t\r\n\t        var v = getVelocity(deltaTime, deltaX, deltaY);\r\n\t        velocityX = v.x;\r\n\t        velocityY = v.y;\r\n\t        velocity = Math.max(v.x, v.y);\r\n\t        direction = getDirection(deltaX, deltaY);\r\n\t    } else {\r\n\t        // use latest velocity info if it doesn't overtake a minimum period\r\n\t        velocity = last.velocity;\r\n\t        velocityX = last.velocityX;\r\n\t        velocityY = last.velocityY;\r\n\t        direction = last.direction;\r\n\t    }\r\n\t\r\n\t    input.velocity = velocity;\r\n\t    input.velocityX = velocityX;\r\n\t    input.velocityY = velocityY;\r\n\t    input.direction = direction;\r\n\t}\r\n\t\r\n\t/**\r\n\t * create a simple clone from the input used for storage of firstInput and firstMultiple\r\n\t * @param {Object} input\r\n\t * @returns {Object} clonedInputData\r\n\t */\r\n\tfunction simpleCloneInputData(input) {\r\n\t    // make a simple copy of the pointers because we will get a reference if we don't\r\n\t    // we only need clientXY for the calculations\r\n\t    var pointers = [];\r\n\t    for (var i = 0; i < input.pointers.length; i++) {\r\n\t        pointers[i] = {\r\n\t            clientX: round(input.pointers[i].clientX),\r\n\t            clientY: round(input.pointers[i].clientY)\r\n\t        };\r\n\t    }\r\n\t\r\n\t    return {\r\n\t        timeStamp: Date.now(),\r\n\t        pointers: pointers,\r\n\t        center: getCenter(pointers),\r\n\t        deltaX: input.deltaX,\r\n\t        deltaY: input.deltaY\r\n\t    };\r\n\t}\r\n\t\r\n\t/**\r\n\t * get the center of all the pointers\r\n\t * @param {Array} pointers\r\n\t * @return {Object} center contains `x` and `y` properties\r\n\t */\r\n\tfunction getCenter(pointers) {\r\n\t    var pointersLength = pointers.length;\r\n\t\r\n\t    // no need to loop when only one touch\r\n\t    if (pointersLength === 1) {\r\n\t        return {\r\n\t            x: round(pointers[0].clientX),\r\n\t            y: round(pointers[0].clientY)\r\n\t        };\r\n\t    }\r\n\t\r\n\t    var x = 0, y = 0;\r\n\t    for (var i = 0; i < pointersLength; i++) {\r\n\t        x += pointers[i].clientX;\r\n\t        y += pointers[i].clientY;\r\n\t    }\r\n\t\r\n\t    return {\r\n\t        x: round(x / pointersLength),\r\n\t        y: round(y / pointersLength)\r\n\t    };\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the velocity between two points. unit is in px per ms.\r\n\t * @param {Number} deltaTime\r\n\t * @param {Number} x\r\n\t * @param {Number} y\r\n\t * @return {Object} velocity `x` and `y`\r\n\t */\r\n\tfunction getVelocity(deltaTime, x, y) {\r\n\t    return {\r\n\t        x: Math.abs(x / deltaTime) || 0,\r\n\t        y: Math.abs(y / deltaTime) || 0\r\n\t    };\r\n\t}\r\n\t\r\n\t/**\r\n\t * get the direction between two points\r\n\t * @param {Number} x\r\n\t * @param {Number} y\r\n\t * @return {Number} direction\r\n\t */\r\n\tfunction getDirection(x, y) {\r\n\t    if (x === y) {\r\n\t        return DIRECTION_NONE;\r\n\t    }\r\n\t\r\n\t    if (Math.abs(x) >= Math.abs(y)) {\r\n\t        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n\t    }\r\n\t    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the absolute distance between two points\r\n\t * @param {Object} p1 {x, y}\r\n\t * @param {Object} p2 {x, y}\r\n\t * @param {Array} [props] containing x and y keys\r\n\t * @return {Number} distance\r\n\t */\r\n\tfunction getDistance(p1, p2, props) {\r\n\t    if (!props) {\r\n\t        props = PROPS_XY;\r\n\t    }\r\n\t    var x = p2[props[0]] - p1[props[0]],\r\n\t        y = p2[props[1]] - p1[props[1]];\r\n\t\r\n\t    return Math.sqrt((x * x) + (y * y));\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the angle between two coordinates\r\n\t * @param {Object} p1\r\n\t * @param {Object} p2\r\n\t * @param {Array} [props] containing x and y keys\r\n\t * @return {Number} angle\r\n\t */\r\n\tfunction getAngle(p1, p2, props) {\r\n\t    if (!props) {\r\n\t        props = PROPS_XY;\r\n\t    }\r\n\t    var x = p2[props[0]] - p1[props[0]],\r\n\t        y = p2[props[1]] - p1[props[1]];\r\n\t    return Math.atan2(y, x) * 180 / Math.PI;\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the rotation degrees between two pointersets\r\n\t * @param {Array} start array of pointers\r\n\t * @param {Array} end array of pointers\r\n\t * @return {Number} rotation\r\n\t */\r\n\tfunction getRotation(start, end) {\r\n\t    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);\r\n\t}\r\n\t\r\n\t/**\r\n\t * calculate the scale factor between two pointersets\r\n\t * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\r\n\t * @param {Array} start array of pointers\r\n\t * @param {Array} end array of pointers\r\n\t * @return {Number} scale\r\n\t */\r\n\tfunction getScale(start, end) {\r\n\t    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\r\n\t}\r\n\t\r\n\tvar MOUSE_INPUT_MAP = {\r\n\t    mousedown: INPUT_START,\r\n\t    mousemove: INPUT_MOVE,\r\n\t    mouseup: INPUT_END,\r\n\t    mouseout: INPUT_CANCEL\r\n\t};\r\n\t\r\n\tvar MOUSE_ELEMENT_EVENTS = 'mousedown';\r\n\tvar MOUSE_WINDOW_EVENTS = 'mousemove mouseout mouseup';\r\n\t\r\n\t/**\r\n\t * Mouse events input\r\n\t * @constructor\r\n\t * @extends Input\r\n\t */\r\n\tfunction MouseInput() {\r\n\t    this.evEl = MOUSE_ELEMENT_EVENTS;\r\n\t    this.evWin = MOUSE_WINDOW_EVENTS;\r\n\t\r\n\t    this.allow = true; // used by Input.TouchMouse to disable mouse events\r\n\t    this.pressed = false; // mousedown state\r\n\t\r\n\t    Input.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(MouseInput, Input, {\r\n\t    /**\r\n\t     * handle mouse events\r\n\t     * @param {Object} ev\r\n\t     */\r\n\t    handler: function(ev) {\r\n\t        var eventType = MOUSE_INPUT_MAP[ev.type];\r\n\t\r\n\t        // on start we want to have the left mouse button down\r\n\t        if (eventType & INPUT_START && ev.button === 0) {\r\n\t            this.pressed = true;\r\n\t        }\r\n\t\r\n\t        if (eventType & INPUT_MOVE && ev.which !== 1) {\r\n\t            eventType = INPUT_END;\r\n\t        }\r\n\t\r\n\t        // mouse must be down, and mouse events are allowed (see the TouchMouse input)\r\n\t        if (!this.pressed || !this.allow) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        // out of the window?\r\n\t        var target = ev.relatedTarget || ev.toElement || ev.target;\r\n\t        if (ev.type == 'mouseout' && target.nodeName != 'HTML') {\r\n\t            eventType = INPUT_MOVE;\r\n\t        }\r\n\t\r\n\t        if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n\t            this.pressed = false;\r\n\t        }\r\n\t\r\n\t        this.callback(this.manager, eventType, {\r\n\t            pointers: [ev],\r\n\t            changedPointers: [ev],\r\n\t            pointerType: INPUT_TYPE_MOUSE,\r\n\t            srcEvent: ev\r\n\t        });\r\n\t    },\r\n\t});\r\n\t\r\n\tvar POINTER_INPUT_MAP = {\r\n\t    pointerdown: INPUT_START,\r\n\t    pointermove: INPUT_MOVE,\r\n\t    pointerup: INPUT_END,\r\n\t    pointercancel: INPUT_CANCEL,\r\n\t    pointerout: INPUT_CANCEL\r\n\t};\r\n\t\r\n\t// in IE10 the pointer types is defined as an enum\r\n\tvar IE10_POINTER_TYPE_ENUM = {\r\n\t    2: INPUT_TYPE_TOUCH,\r\n\t    3: INPUT_TYPE_PEN,\r\n\t    4: INPUT_TYPE_MOUSE,\r\n\t    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\r\n\t};\r\n\t\r\n\tvar POINTER_ELEMENT_EVENTS = 'pointerdown pointermove pointerup pointercancel';\r\n\tvar POINTER_WINDOW_EVENTS = 'pointerout';\r\n\t\r\n\t// IE10 has prefixed support, and case-sensitive\r\n\tif (window.MSPointerEvent) {\r\n\t    POINTER_ELEMENT_EVENTS = 'MSPointerDown MSPointerMove MSPointerUp MSPointerCancel';\r\n\t    POINTER_WINDOW_EVENTS = 'MSPointerOut';\r\n\t}\r\n\t\r\n\t/**\r\n\t * Pointer events input\r\n\t * @constructor\r\n\t * @extends Input\r\n\t */\r\n\tfunction PointerEventInput() {\r\n\t    this.evEl = POINTER_ELEMENT_EVENTS;\r\n\t    this.evWin = POINTER_WINDOW_EVENTS;\r\n\t\r\n\t    Input.apply(this, arguments);\r\n\t\r\n\t    this.store = (this.manager.session.pointerEvents = []);\r\n\t}\r\n\t\r\n\tinherit(PointerEventInput, Input, {\r\n\t    /**\r\n\t     * handle mouse events\r\n\t     * @param {Object} ev\r\n\t     */\r\n\t    handler: function(ev) {\r\n\t        var store = this.store;\r\n\t        var removePointer = false;\r\n\t\r\n\t        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\r\n\t        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\r\n\t        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\r\n\t\r\n\t        // out of the window?\r\n\t        var target = ev.relatedTarget || ev.toElement || ev.target;\r\n\t        if (eventTypeNormalized == 'pointerout' && target.nodeName != 'HTML') {\r\n\t            eventType = INPUT_MOVE;\r\n\t        }\r\n\t\r\n\t        // start and mouse must be down\r\n\t        if (eventType & INPUT_START && (ev.button === 0 || pointerType == INPUT_TYPE_TOUCH)) {\r\n\t            store.push(ev);\r\n\t        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n\t            removePointer = true;\r\n\t        }\r\n\t\r\n\t        // get index of the event in the store\r\n\t        // it not found, so the pointer hasn't been down (so it's probably a hover)\r\n\t        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\r\n\t        if (storeIndex < 0) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        // update the event in the store\r\n\t        store[storeIndex] = ev;\r\n\t\r\n\t        this.callback(this.manager, eventType, {\r\n\t            pointers: store,\r\n\t            changedPointers: [ev],\r\n\t            pointerType: pointerType,\r\n\t            srcEvent: ev\r\n\t        });\r\n\t\r\n\t        if (removePointer) {\r\n\t            // remove from the store\r\n\t            store.splice(storeIndex, 1);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\tvar TOUCH_INPUT_MAP = {\r\n\t    touchstart: INPUT_START,\r\n\t    touchmove: INPUT_MOVE,\r\n\t    touchend: INPUT_END,\r\n\t    touchcancel: INPUT_CANCEL\r\n\t};\r\n\t\r\n\tvar TOUCH_EVENTS = 'touchstart touchmove touchend touchcancel';\r\n\t\r\n\t/**\r\n\t * Touch events input\r\n\t * @constructor\r\n\t * @extends Input\r\n\t */\r\n\tfunction TouchInput() {\r\n\t    this.evEl = TOUCH_EVENTS;\r\n\t    this.targetIds = {};\r\n\t\r\n\t    Input.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(TouchInput, Input, {\r\n\t    /**\r\n\t     * handle touch events\r\n\t     * @param {Object} ev\r\n\t     */\r\n\t    handler: function(ev) {\r\n\t        var touches = normalizeTouches(ev, this);\r\n\t        this.callback(this.manager, TOUCH_INPUT_MAP[ev.type], {\r\n\t            pointers: touches[0],\r\n\t            changedPointers: touches[1],\r\n\t            pointerType: INPUT_TYPE_TOUCH,\r\n\t            srcEvent: ev\r\n\t        });\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * make sure all browsers return the same touches\r\n\t * @param {Object} ev\r\n\t * @param {TouchInput} touchInput\r\n\t * @returns {Array} [all, changed]\r\n\t */\r\n\tfunction normalizeTouches(ev, touchInput) {\r\n\t    var i, len;\r\n\t\r\n\t    var targetIds = touchInput.targetIds;\r\n\t    var targetTouches = toArray(ev.targetTouches);\r\n\t    var changedTouches = toArray(ev.changedTouches);\r\n\t    var changedTargetTouches = [];\r\n\t\r\n\t    // collect touches\r\n\t    if (ev.type == 'touchstart') {\r\n\t        for (i = 0, len = targetTouches.length; i < len; i++) {\r\n\t            targetIds[targetTouches[i].identifier] = true;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    // filter changed touches to only contain touches that exist in the collected target ids\r\n\t    for (i = 0, len = changedTouches.length; i < len; i++) {\r\n\t        if (targetIds[changedTouches[i].identifier]) {\r\n\t            changedTargetTouches.push(changedTouches[i]);\r\n\t        }\r\n\t\r\n\t        // cleanup removed touches\r\n\t        if (ev.type == 'touchend'|| ev.type == 'touchcancel') {\r\n\t            delete targetIds[changedTouches[i].identifier];\r\n\t        }\r\n\t    }\r\n\t\r\n\t    return [\r\n\t        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\r\n\t        // also removed the duplicates\r\n\t        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier'),\r\n\t\r\n\t        // only the changed :-)\r\n\t        changedTargetTouches\r\n\t    ];\r\n\t}\r\n\t\r\n\t/**\r\n\t * Combined touch and mouse input\r\n\t *\r\n\t * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\r\n\t * This because touch devices also emit mouse events while doing a touch.\r\n\t *\r\n\t * @constructor\r\n\t * @extends Input\r\n\t */\r\n\tfunction TouchMouseInput() {\r\n\t    Input.apply(this, arguments);\r\n\t\r\n\t    var handler = bindFn(this.handler, this);\r\n\t    this.touch = new TouchInput(this.manager, handler);\r\n\t    this.mouse = new MouseInput(this.manager, handler);\r\n\t}\r\n\t\r\n\tinherit(TouchMouseInput, Input, {\r\n\t    /**\r\n\t     * handle mouse and touch events\r\n\t     * @param {Hammer} manager\r\n\t     * @param {String} inputEvent\r\n\t     * @param {Object} inputData\r\n\t     */\r\n\t    handler: function(manager, inputEvent, inputData) {\r\n\t        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\r\n\t            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\r\n\t\r\n\t        // when we're in a touch event, so  block all upcoming mouse events\r\n\t        // most mobile browser also emit mouseevents, right after touchstart\r\n\t        if (isTouch) {\r\n\t            this.mouse.allow = false;\r\n\t        } else if (isMouse && !this.mouse.allow) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        // reset the allowMouse when we're done\r\n\t        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {\r\n\t            this.mouse.allow = true;\r\n\t        }\r\n\t\r\n\t        this.callback(manager, inputEvent, inputData);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * remove the event listeners\r\n\t     */\r\n\t    destroy: function() {\r\n\t        this.touch.destroy();\r\n\t        this.mouse.destroy();\r\n\t    }\r\n\t});\r\n\t\r\n\tvar PREFIXED_TOUCH_ACTION = prefixed(document.body.style, 'touchAction');\r\n\tvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\r\n\t\r\n\t// magical touchAction value\r\n\tvar TOUCH_ACTION_COMPUTE = 'compute';\r\n\tvar TOUCH_ACTION_AUTO = 'auto';\r\n\tvar TOUCH_ACTION_MANIPULATION = 'manipulation';\r\n\tvar TOUCH_ACTION_NONE = 'none';\r\n\tvar TOUCH_ACTION_PAN_X = 'pan-x';\r\n\tvar TOUCH_ACTION_PAN_Y = 'pan-y';\r\n\t\r\n\t/**\r\n\t * Touch Action\r\n\t * sets the touchAction property or uses the js alternative\r\n\t * @param {Manager} manager\r\n\t * @param {String} value\r\n\t * @constructor\r\n\t */\r\n\tfunction TouchAction(manager, value) {\r\n\t    this.manager = manager;\r\n\t    this.set(value);\r\n\t}\r\n\t\r\n\tTouchAction.prototype = {\r\n\t    /**\r\n\t     * set the touchAction value on the element or enable the polyfill\r\n\t     * @param {String} value\r\n\t     */\r\n\t    set: function(value) {\r\n\t        // find out the touch-action by the event handlers\r\n\t        if (value == TOUCH_ACTION_COMPUTE) {\r\n\t            value = this.compute();\r\n\t        }\r\n\t\r\n\t        if (NATIVE_TOUCH_ACTION) {\r\n\t            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\r\n\t        }\r\n\t        this.actions = value.toLowerCase();\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * just re-set the touchAction value\r\n\t     */\r\n\t    update: function() {\r\n\t        this.set(this.manager.options.touchAction);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * compute the value for the touchAction property based on the recognizer's settings\r\n\t     * @returns {String} value\r\n\t     */\r\n\t    compute: function() {\r\n\t        var value;\r\n\t        var actions = [];\r\n\t\r\n\t        each(this.manager.recognizers, function(recognizer) {\r\n\t            if (boolOrFn(recognizer.options.enable, recognizer)) {\r\n\t                actions = actions.concat(recognizer.getTouchAction());\r\n\t            }\r\n\t        });\r\n\t        value = uniqueArray(actions).join(' ');\r\n\t        return cleanTouchActions(value);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * this method is called on each input cycle and provides the preventing of the browser behavior\r\n\t     * @param {Object} input\r\n\t     */\r\n\t    preventDefaults: function(input) {\r\n\t        // not needed with native support for the touchAction property\r\n\t        if (NATIVE_TOUCH_ACTION) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var srcEvent = input.srcEvent;\r\n\t        var direction = input.offsetDirection;\r\n\t\r\n\t        // if the touch action did prevented once this session\r\n\t        if (this.manager.session.prevented) {\r\n\t            srcEvent.preventDefault();\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var actions = this.actions;\r\n\t        var hasNone = inStr(actions, TOUCH_ACTION_NONE);\r\n\t        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\r\n\t        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\r\n\t\r\n\t        if (hasNone || (hasPanY && hasPanX) ||\r\n\t            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\r\n\t            (hasPanX && direction & DIRECTION_VERTICAL)) {\r\n\t            return this.preventSrc(srcEvent);\r\n\t        }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\r\n\t     * @param {Object} srcEvent\r\n\t     */\r\n\t    preventSrc: function(srcEvent) {\r\n\t        this.manager.session.prevented = true;\r\n\t        srcEvent.preventDefault();\r\n\t    }\r\n\t};\r\n\t\r\n\t/**\r\n\t * when the touchActions are collected they are not a valid value, so we need to clean things up. *\r\n\t * @param {String} actions\r\n\t * @returns {*}\r\n\t */\r\n\tfunction cleanTouchActions(actions) {\r\n\t    // none\r\n\t    if (inStr(actions, TOUCH_ACTION_NONE)) {\r\n\t        return TOUCH_ACTION_NONE;\r\n\t    }\r\n\t    // pan-x and pan-y can be combined\r\n\t    if (inStr(actions, TOUCH_ACTION_PAN_X) || inStr(actions, TOUCH_ACTION_PAN_Y)) {\r\n\t        return actions.replace(/[\\-\\w]+/g, function(action) {\r\n\t            if (/^pan\\-/.test(action)) {\r\n\t                return action;\r\n\t            }\r\n\t            return '';\r\n\t        });\r\n\t    }\r\n\t    // manipulation\r\n\t    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\r\n\t        return TOUCH_ACTION_MANIPULATION;\r\n\t    }\r\n\t\r\n\t    return TOUCH_ACTION_AUTO;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Recognizer flow explained; *\r\n\t * All recognizers have the initial state of POSSIBLE when a input session starts.\r\n\t * The definition of a input session is from the first input until the last input, with all it's movement in it. *\r\n\t * Example session for mouse-input: mousedown -> mousemove -> mouseup\r\n\t *\r\n\t * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\r\n\t * which determines with state it should be.\r\n\t *\r\n\t * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\r\n\t * POSSIBLE to give it another change on the next cycle.\r\n\t *\r\n\t *               Possible\r\n\t *                  |\r\n\t *            +-----+---------------+\r\n\t *            |                     |\r\n\t *      +-----+-----+               |\r\n\t *      |           |               |\r\n\t *   Failed      Cancelled          |\r\n\t *                          +-------+------+\r\n\t *                          |              |\r\n\t *                      Recognized       Began\r\n\t *                                         |\r\n\t *                                      Changed\r\n\t *                                         |\r\n\t *                                  Ended/Recognized\r\n\t */\r\n\tvar STATE_POSSIBLE = 1;\r\n\tvar STATE_BEGAN = 2;\r\n\tvar STATE_CHANGED = 4;\r\n\tvar STATE_ENDED = 8;\r\n\tvar STATE_RECOGNIZED = STATE_ENDED;\r\n\tvar STATE_CANCELLED = 16;\r\n\tvar STATE_FAILED = 32;\r\n\t\r\n\t/**\r\n\t * Recognizer\r\n\t * Every recognizer needs to extend from this class.\r\n\t * @constructor\r\n\t * @param {Object} options\r\n\t */\r\n\tfunction Recognizer(options) {\r\n\t    this.id = uniqueId();\r\n\t\r\n\t    this.manager = null;\r\n\t    this.options = merge(options || {}, this.defaults);\r\n\t\r\n\t    // default is enable true\r\n\t    this.options.enable = ifUndefined(this.options.enable, true);\r\n\t\r\n\t    this.state = STATE_POSSIBLE;\r\n\t\r\n\t    this.simultaneous = {};\r\n\t    this.requireFail = [];\r\n\t}\r\n\t\r\n\tRecognizer.prototype = {\r\n\t    /**\r\n\t     * @virtual\r\n\t     * @type {Object}\r\n\t     */\r\n\t    defaults: {},\r\n\t\r\n\t    /**\r\n\t     * set options\r\n\t     * @param {String} option\r\n\t     * @param {*} val\r\n\t     */\r\n\t    set: function(option, val) {\r\n\t        this.options[option] = val;\r\n\t\r\n\t        // also update the touchAction, in case something changed about the directions/enabled state\r\n\t        this.manager && this.manager.touchAction.update();\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * recognize simultaneous with an other recognizer.\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Recognizer} this\r\n\t     */\r\n\t    recognizeWith: function(otherRecognizer) {\r\n\t        var simultaneous = this.simultaneous;\r\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n\t        if (!simultaneous[otherRecognizer.id]) {\r\n\t            simultaneous[otherRecognizer.id] = otherRecognizer;\r\n\t            otherRecognizer.recognizeWith(this);\r\n\t        }\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Recognizer} this\r\n\t     */\r\n\t    dropRecognizeWith: function(otherRecognizer) {\r\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n\t        delete this.simultaneous[otherRecognizer.id];\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * recognizer can only run when an other is failing\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Recognizer} this\r\n\t     */\r\n\t    requireFailure: function(otherRecognizer) {\r\n\t        var requireFail = this.requireFail;\r\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n\t        if (inArray(requireFail, otherRecognizer) === -1) {\r\n\t            requireFail.push(otherRecognizer);\r\n\t            otherRecognizer.requireFailure(this);\r\n\t        }\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * drop the requireFailure link. it does not remove the link on the other recognizer.\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Recognizer} this\r\n\t     */\r\n\t    dropRequireFailure: function(otherRecognizer) {\r\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n\t        var index = inArray(this.requireFail, otherRecognizer);\r\n\t        if (index > -1) {\r\n\t            this.requireFail.splice(index, 1);\r\n\t        }\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * has require failures boolean\r\n\t     * @returns {boolean}\r\n\t     */\r\n\t    hasRequireFailures: function() {\r\n\t        return this.requireFail.length > 0;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * if the recognizer can recognize simultaneous with an other recognizer\r\n\t     * @param {Recognizer} otherRecognizer\r\n\t     * @returns {Boolean}\r\n\t     */\r\n\t    canRecognizeWith: function(otherRecognizer) {\r\n\t        return !!this.simultaneous[otherRecognizer.id];\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * You should use `tryEmit` instead of `emit` directly to check\r\n\t     * that all the needed recognizers has failed before emitting.\r\n\t     * @param {Object} input\r\n\t     */\r\n\t    emit: function(input) {\r\n\t        this.manager.emit(this.options.event, input); // simple 'eventName' events\r\n\t        this.manager.emit(this.options.event + stateStr(this.state), input); // like 'panmove' and 'panstart'\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Check that all the require failure recognizers has failed,\r\n\t     * if true, it emits a gesture event,\r\n\t     * otherwise, setup the state to FAILED.\r\n\t     * @param {Object} input\r\n\t     */\r\n\t    tryEmit: function(input) {\r\n\t        if (this.canEmit()) {\r\n\t            return this.emit(input);\r\n\t        }\r\n\t        // it's failing anyway\r\n\t        this.state = STATE_FAILED;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * can we emit?\r\n\t     * @returns {boolean}\r\n\t     */\r\n\t    canEmit: function() {\r\n\t        for (var i = 0; i < this.requireFail.length; i++) {\r\n\t            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\r\n\t                return false;\r\n\t            }\r\n\t        }\r\n\t        return true;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * update the recognizer\r\n\t     * @param {Object} inputData\r\n\t     */\r\n\t    recognize: function(inputData) {\r\n\t        // make a new copy of the inputData\r\n\t        // so we can change the inputData without messing up the other recognizers\r\n\t        var inputDataClone = extend({}, inputData);\r\n\t\r\n\t        // is is enabled and allow recognizing?\r\n\t        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\r\n\t            this.reset();\r\n\t            this.state = STATE_FAILED;\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        // reset when we've reached the end\r\n\t        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\r\n\t            this.state = STATE_POSSIBLE;\r\n\t        }\r\n\t\r\n\t        this.state = this.process(inputDataClone);\r\n\t\r\n\t        // the recognizer has recognized a gesture\r\n\t        // so trigger an event\r\n\t        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\r\n\t            this.tryEmit(inputDataClone);\r\n\t        }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * return the state of the recognizer\r\n\t     * the actual recognizing happens in this method\r\n\t     * @virtual\r\n\t     * @param {Object} inputData\r\n\t     * @returns {Const} STATE\r\n\t     */\r\n\t    process: function(inputData) { }, // jshint ignore:line\r\n\t\r\n\t    /**\r\n\t     * return the preferred touch-action\r\n\t     * @virtual\r\n\t     * @returns {Array}\r\n\t     */\r\n\t    getTouchAction: function() { },\r\n\t\r\n\t    /**\r\n\t     * called when the gesture isn't allowed to recognize\r\n\t     * like when another is being recognized or it is disabled\r\n\t     * @virtual\r\n\t     */\r\n\t    reset: function() { }\r\n\t};\r\n\t\r\n\t/**\r\n\t * get a usable string, used as event postfix\r\n\t * @param {Const} state\r\n\t * @returns {String} state\r\n\t */\r\n\tfunction stateStr(state) {\r\n\t    if (state & STATE_CANCELLED) {\r\n\t        return 'cancel';\r\n\t    } else if (state & STATE_ENDED) {\r\n\t        return 'end';\r\n\t    } else if (state & STATE_CHANGED) {\r\n\t        return 'move';\r\n\t    } else if (state & STATE_BEGAN) {\r\n\t        return 'start';\r\n\t    }\r\n\t    return '';\r\n\t}\r\n\t\r\n\t/**\r\n\t * direction cons to string\r\n\t * @param {Const} direction\r\n\t * @returns {String}\r\n\t */\r\n\tfunction directionStr(direction) {\r\n\t    if (direction == DIRECTION_DOWN) {\r\n\t        return 'down';\r\n\t    } else if (direction == DIRECTION_UP) {\r\n\t        return 'up';\r\n\t    } else if (direction == DIRECTION_LEFT) {\r\n\t        return 'left';\r\n\t    } else if (direction == DIRECTION_RIGHT) {\r\n\t        return 'right';\r\n\t    }\r\n\t    return '';\r\n\t}\r\n\t\r\n\t/**\r\n\t * get a recognizer by name if it is bound to a manager\r\n\t * @param {Recognizer|String} otherRecognizer\r\n\t * @param {Recognizer} recognizer\r\n\t * @returns {Recognizer}\r\n\t */\r\n\tfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\r\n\t    var manager = recognizer.manager;\r\n\t    if (manager) {\r\n\t        return manager.get(otherRecognizer);\r\n\t    }\r\n\t    return otherRecognizer;\r\n\t}\r\n\t\r\n\t/**\r\n\t * This recognizer is just used as a base for the simple attribute recognizers.\r\n\t * @constructor\r\n\t * @extends Recognizer\r\n\t */\r\n\tfunction AttrRecognizer() {\r\n\t    Recognizer.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(AttrRecognizer, Recognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof AttrRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        /**\r\n\t         * @type {Number}\r\n\t         * @default 1\r\n\t         */\r\n\t        pointers: 1\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Used to check if it the recognizer receives valid input, like input.distance > 10.\r\n\t     * @memberof AttrRecognizer\r\n\t     * @param {Object} input\r\n\t     * @returns {Boolean} recognized\r\n\t     */\r\n\t    attrTest: function(input) {\r\n\t        var optionPointers = this.options.pointers;\r\n\t        return optionPointers === 0 || input.pointers.length === optionPointers;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * Process the input and return the state for the recognizer\r\n\t     * @memberof AttrRecognizer\r\n\t     * @param {Object} input\r\n\t     * @returns {*} State\r\n\t     */\r\n\t    process: function(input) {\r\n\t        var state = this.state;\r\n\t        var eventType = input.eventType;\r\n\t\r\n\t        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\r\n\t        var isValid = this.attrTest(input);\r\n\t\r\n\t        // on cancel input and we've recognized before, return STATE_CANCELLED\r\n\t        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\r\n\t            return state | STATE_CANCELLED;\r\n\t        } else if (isRecognized || isValid) {\r\n\t            if (eventType & INPUT_END) {\r\n\t                return state | STATE_ENDED;\r\n\t            } else if (!(state & STATE_BEGAN)) {\r\n\t                return STATE_BEGAN;\r\n\t            }\r\n\t            return state | STATE_CHANGED;\r\n\t        }\r\n\t        return STATE_FAILED;\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Pan\r\n\t * Recognized when the pointer is down and moved in the allowed direction.\r\n\t * @constructor\r\n\t * @extends AttrRecognizer\r\n\t */\r\n\tfunction PanRecognizer() {\r\n\t    AttrRecognizer.apply(this, arguments);\r\n\t\r\n\t    this.pX = null;\r\n\t    this.pY = null;\r\n\t}\r\n\t\r\n\tinherit(PanRecognizer, AttrRecognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof PanRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        event: 'pan',\r\n\t        threshold: 10,\r\n\t        pointers: 1,\r\n\t        direction: DIRECTION_ALL\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        var direction = this.options.direction;\r\n\t\r\n\t        if (direction === DIRECTION_ALL) {\r\n\t            return [TOUCH_ACTION_NONE];\r\n\t        }\r\n\t\r\n\t        var actions = [];\r\n\t        if (direction & DIRECTION_HORIZONTAL) {\r\n\t            actions.push(TOUCH_ACTION_PAN_Y);\r\n\t        }\r\n\t        if (direction & DIRECTION_VERTICAL) {\r\n\t            actions.push(TOUCH_ACTION_PAN_X);\r\n\t        }\r\n\t        return actions;\r\n\t    },\r\n\t\r\n\t    directionTest: function(input) {\r\n\t        var options = this.options;\r\n\t        var hasMoved = true;\r\n\t        var distance = input.distance;\r\n\t        var direction = input.direction;\r\n\t        var x = input.deltaX;\r\n\t        var y = input.deltaY;\r\n\t\r\n\t\r\n\t\r\n\t        // lock to axis?\r\n\t        if (!(direction & options.direction)) {\r\n\t            if (options.direction & DIRECTION_HORIZONTAL) {\r\n\t                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n\t                hasMoved = x != this.pX;\r\n\t                distance = Math.abs(input.deltaX);\r\n\t            } else {\r\n\t                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\r\n\t                hasMoved = y != this.pY;\r\n\t                distance = Math.abs(input.deltaY);\r\n\t            }\r\n\t        }\r\n\t        input.direction = direction;\r\n\t        return hasMoved && distance > options.threshold && direction & options.direction;\r\n\t    },\r\n\t\r\n\t    attrTest: function(input) {\r\n\t        return AttrRecognizer.prototype.attrTest.call(this, input) &&\r\n\t            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\r\n\t    },\r\n\t\r\n\t    emit: function(input) {\r\n\t        this.pX = input.deltaX;\r\n\t        this.pY = input.deltaY;\r\n\t\r\n\t        this._super.emit.call(this, input);\r\n\t\r\n\t        var direction = directionStr(input.direction);\r\n\t        if (direction) {\r\n\t            this.manager.emit(this.options.event + direction, input);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Pinch\r\n\t * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\r\n\t * @constructor\r\n\t * @extends AttrRecognizer\r\n\t */\r\n\tfunction PinchRecognizer() {\r\n\t    AttrRecognizer.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(PinchRecognizer, AttrRecognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof PinchRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        event: 'pinch',\r\n\t        threshold: 0,\r\n\t        pointers: 2\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return [TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y];\r\n\t    },\r\n\t\r\n\t    attrTest: function(input) {\r\n\t        return this._super.attrTest.call(this, input) &&\r\n\t            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\r\n\t    },\r\n\t\r\n\t    emit: function(input) {\r\n\t        this._super.emit.call(this, input);\r\n\t        if (input.scale !== 1) {\r\n\t            var inOut = input.scale < 1 ? 'in' : 'out';\r\n\t            this.manager.emit(this.options.event + inOut, input);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Press\r\n\t * Recognized when the pointer is down for x ms without any movement.\r\n\t * @constructor\r\n\t * @extends Recognizer\r\n\t */\r\n\tfunction PressRecognizer() {\r\n\t    Recognizer.apply(this, arguments);\r\n\t\r\n\t    this._timer = null;\r\n\t    this._input = null;\r\n\t}\r\n\t\r\n\tinherit(PressRecognizer, Recognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof PressRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        event: 'press',\r\n\t        pointers: 1,\r\n\t        time: 500, // minimal time of the pointer to be pressed\r\n\t        threshold: 5 // a minimal movement is ok, but keep it low\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return [TOUCH_ACTION_AUTO];\r\n\t    },\r\n\t\r\n\t    process: function(input) {\r\n\t        var options = this.options;\r\n\t\r\n\t        var validPointers = input.pointers.length === options.pointers;\r\n\t        var validMovement = input.distance < options.threshold;\r\n\t        var validTime = input.deltaTime > options.time;\r\n\t\r\n\t        this._input = input;\r\n\t\r\n\t        // we only allow little movement\r\n\t        // and we've reached an end event, so a tap is possible\r\n\t        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\r\n\t            this.reset();\r\n\t        } else if (input.eventType & INPUT_START) {\r\n\t            this.reset();\r\n\t            var self = this;\r\n\t            this._timer = setTimeout(function() {\r\n\t                self.state = STATE_RECOGNIZED;\r\n\t                self.tryEmit();\r\n\t            }, options.time);\r\n\t        }\r\n\t        return STATE_FAILED;\r\n\t    },\r\n\t\r\n\t    reset: function() {\r\n\t        clearTimeout(this._timer);\r\n\t        this._timer = null;\r\n\t    },\r\n\t\r\n\t    emit: function() {\r\n\t        if (this.state === STATE_RECOGNIZED) {\r\n\t            this._input.timeStamp = Date.now();\r\n\t            this.manager.emit(this.options.event, this._input);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Rotate\r\n\t * Recognized when two or more pointer are moving in a circular motion.\r\n\t * @constructor\r\n\t * @extends AttrRecognizer\r\n\t */\r\n\tfunction RotateRecognizer() {\r\n\t    AttrRecognizer.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(RotateRecognizer, AttrRecognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof RotateRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        event: 'rotate',\r\n\t        threshold: 0,\r\n\t        pointers: 2\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return [TOUCH_ACTION_NONE];\r\n\t    },\r\n\t\r\n\t    attrTest: function(input) {\r\n\t        return this._super.attrTest.call(this, input) &&\r\n\t            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Swipe\r\n\t * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\r\n\t * @constructor\r\n\t * @extends AttrRecognizer\r\n\t */\r\n\tfunction SwipeRecognizer() {\r\n\t    AttrRecognizer.apply(this, arguments);\r\n\t}\r\n\t\r\n\tinherit(SwipeRecognizer, AttrRecognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof SwipeRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        event: 'swipe',\r\n\t        threshold: 10,\r\n\t        velocity: 0.65,\r\n\t        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\r\n\t        pointers: 1\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return PanRecognizer.prototype.getTouchAction.call(this);\r\n\t    },\r\n\t\r\n\t    attrTest: function(input) {\r\n\t        var direction = this.options.direction;\r\n\t        var velocity;\r\n\t\r\n\t        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\r\n\t            velocity = input.velocity;\r\n\t        } else if (direction & DIRECTION_HORIZONTAL) {\r\n\t            velocity = input.velocityX;\r\n\t        } else if (direction & DIRECTION_VERTICAL) {\r\n\t            velocity = input.velocityY;\r\n\t        }\r\n\t\r\n\t        return this._super.attrTest.call(this, input) &&\r\n\t            direction & input.direction &&\r\n\t            velocity > this.options.velocity && input.eventType & INPUT_END;\r\n\t    },\r\n\t\r\n\t    emit: function(input) {\r\n\t        this.manager.emit(this.options.event, input);\r\n\t\r\n\t        var direction = directionStr(input.direction);\r\n\t        if (direction) {\r\n\t            this.manager.emit(this.options.event + direction, input);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\r\n\t * between the given interval and position. The delay option can be used to recognize multi-taps without firing\r\n\t * a single tap.\r\n\t *\r\n\t * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\r\n\t * multi-taps being recognized.\r\n\t * @constructor\r\n\t * @extends Recognizer\r\n\t */\r\n\tfunction TapRecognizer() {\r\n\t    Recognizer.apply(this, arguments);\r\n\t\r\n\t    // previous time and center,\r\n\t    // used for tap counting\r\n\t    this.pTime = false;\r\n\t    this.pCenter = false;\r\n\t\r\n\t    this._timer = null;\r\n\t    this._input = null;\r\n\t    this.count = 0;\r\n\t}\r\n\t\r\n\tinherit(TapRecognizer, Recognizer, {\r\n\t    /**\r\n\t     * @namespace\r\n\t     * @memberof PinchRecognizer\r\n\t     */\r\n\t    defaults: {\r\n\t        event: 'tap',\r\n\t        pointers: 1,\r\n\t        taps: 1,\r\n\t        delay: 300,\r\n\t        interval: 300, // max time between the multi-tap taps\r\n\t        time: 250, // max time of the pointer to be down (like finger on the screen)\r\n\t        threshold: 2, // a minimal movement is ok, but keep it low\r\n\t        posThreshold: 10 // a multi-tap can be a bit off the initial position\r\n\t    },\r\n\t\r\n\t    getTouchAction: function() {\r\n\t        return [TOUCH_ACTION_MANIPULATION];\r\n\t    },\r\n\t\r\n\t    process: function(input) {\r\n\t        var self = this;\r\n\t        var options = this.options;\r\n\t\r\n\t        var validPointers = input.pointers.length === options.pointers;\r\n\t        var validMovement = input.distance < options.threshold;\r\n\t        var validTouchTime = input.deltaTime < options.time;\r\n\t\r\n\t        this.reset();\r\n\t\r\n\t        if ((input.eventType & INPUT_START) && (this.count === 0)) {\r\n\t            return this._setupBeganState();\r\n\t        }\r\n\t\r\n\t        // we only allow little movement\r\n\t        // and we've reached an end event, so a tap is possible\r\n\t        if (validMovement && validTouchTime && validPointers) {\r\n\t            if (input.eventType & INPUT_END) {\r\n\t                var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\r\n\t                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\r\n\t\r\n\t                this.pTime = input.timeStamp;\r\n\t                this.pCenter = input.center;\r\n\t\r\n\t                if (!validMultiTap || !validInterval) {\r\n\t                    this.count = 1;\r\n\t                } else {\r\n\t                    this.count += 1;\r\n\t                }\r\n\t\r\n\t                this._input = input;\r\n\t\r\n\t                // if tap count matches we have recognized it,\r\n\t                // else it has began recognizing...\r\n\t                var tapCount = this.count % options.taps;\r\n\t                if (tapCount === 0) {\r\n\t                    if (!this.hasRequireFailures()) {\r\n\t                        return STATE_RECOGNIZED;\r\n\t                    } else {\r\n\t                        this._timer = setTimeout(function() {\r\n\t                            self.state = STATE_RECOGNIZED;\r\n\t                            self.tryEmit();\r\n\t                        }, options.delay);\r\n\t                        return STATE_BEGAN;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t\r\n\t            return this._setupBeganState();\r\n\t        }\r\n\t        return STATE_FAILED;\r\n\t    },\r\n\t\r\n\t    _setupBeganState: function() {\r\n\t        var self = this;\r\n\t        this._timer = setTimeout(function() {\r\n\t            self.state = STATE_FAILED;\r\n\t        }, this.options.delay);\r\n\t\r\n\t        return STATE_FAILED;\r\n\t    },\r\n\t\r\n\t    reset: function() {\r\n\t        clearTimeout(this._timer);\r\n\t    },\r\n\t\r\n\t    emit: function() {\r\n\t        if (this.state == STATE_RECOGNIZED ) {\r\n\t            this._input.tapCount = this.count;\r\n\t            this.manager.emit(this.options.event, this._input);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\t/**\r\n\t * Simple way to create an manager with a default set of recognizers.\r\n\t * @param {HTMLElement} element\r\n\t * @param {Object} [options]\r\n\t * @constructor\r\n\t */\r\n\tfunction Hammer(element, options) {\r\n\t    options = options || {};\r\n\t    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.easyRecognizers);\r\n\t    return new Manager(element, options);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Current build version.\r\n\t * @const {string}\r\n\t */\r\n\tHammer.VERSION = '2.0.0dev';\r\n\t\r\n\t/**\r\n\t * default settings\r\n\t * @namespace\r\n\t */\r\n\tHammer.defaults = {\r\n\t    /**\r\n\t     * set if DOM events are being triggered.\r\n\t     * But this is slower and unused by simple implementations, so disabled by default.\r\n\t     * @type {Boolean}\r\n\t     * @default false\r\n\t     */\r\n\t    domEvents: false,\r\n\t\r\n\t    /**\r\n\t     * The value for the touchAction property/fallback.\r\n\t     * When set to `compute` it will magically set the correct value based on the added recognizers.\r\n\t     * @type {String}\r\n\t     * @default compute\r\n\t     */\r\n\t    touchAction: TOUCH_ACTION_COMPUTE,\r\n\t\r\n\t    /**\r\n\t     * @type {Boolean}\r\n\t     * @default true\r\n\t     */\r\n\t    enable: true,\r\n\t\r\n\t    /**\r\n\t     * Default recognizer setup when calling `Hammer()`\r\n\t     * When creating a new Manager these will be skipped.\r\n\t     * @type {Array}\r\n\t     */\r\n\t    easyRecognizers: [\r\n\t        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\r\n\t        [RotateRecognizer, { enable: false }],\r\n\t        [PinchRecognizer, { enable: false }, ['rotate']],\r\n\t        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],\r\n\t        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\r\n\t        [TapRecognizer],\r\n\t        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\r\n\t        [PressRecognizer]\r\n\t    ],\r\n\t\r\n\t    /**\r\n\t     * Some CSS properties can be used to improve the working of Hammer.\r\n\t     * Add them to this method and they will be set when creating a new Manager.\r\n\t     * @namespace\r\n\t     */\r\n\t    cssProps: {\r\n\t        /**\r\n\t         * Disables text selection to improve the dragging gesture. When the value is `none` it also sets\r\n\t         * `onselectstart=false` for IE9 on the element. Mainly for desktop browsers.\r\n\t         * @type {String}\r\n\t         * @default 'none'\r\n\t         */\r\n\t        userSelect: 'none',\r\n\t\r\n\t        /**\r\n\t         * Disable the Windows Phone grippers when pressing an element.\r\n\t         * @type {String}\r\n\t         * @default 'none'\r\n\t         */\r\n\t        touchSelect: 'none',\r\n\t\r\n\t        /**\r\n\t         * Disables the default callout shown when you touch and hold a touch target.\r\n\t         * On iOS, when you touch and hold a touch target such as a link, Safari displays\r\n\t         * a callout containing information about the link. This property allows you to disable that callout.\r\n\t         * @type {String}\r\n\t         * @default 'none'\r\n\t         */\r\n\t        touchCallout: 'none',\r\n\t\r\n\t        /**\r\n\t         * Specifies whether zooming is enabled. Used by IE10>\r\n\t         * @type {String}\r\n\t         * @default 'none'\r\n\t         */\r\n\t        contentZooming: 'none',\r\n\t\r\n\t        /**\r\n\t         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\r\n\t         * @type {String}\r\n\t         * @default 'none'\r\n\t         */\r\n\t        userDrag: 'none',\r\n\t\r\n\t        /**\r\n\t         * Overrides the highlight color shown when the user taps a link or a JavaScript\r\n\t         * clickable element in iOS. This property obeys the alpha value, if specified.\r\n\t         * @type {String}\r\n\t         * @default 'rgba(0,0,0,0)'\r\n\t         */\r\n\t        tapHighlightColor: 'rgba(0,0,0,0)'\r\n\t    }\r\n\t};\r\n\t\r\n\tvar STOP = 1;\r\n\tvar FORCED_STOP = 2;\r\n\t\r\n\t/**\r\n\t * Manager\r\n\t * @param {HTMLElement} element\r\n\t * @param {Object} [options]\r\n\t * @constructor\r\n\t */\r\n\tfunction Manager(element, options) {\r\n\t    options = options || {};\r\n\t\r\n\t    this.options = merge(options, Hammer.defaults);\r\n\t\r\n\t    this.handlers = {};\r\n\t    this.session = {};\r\n\t    this.recognizers = [];\r\n\t\r\n\t    this.element = element;\r\n\t    this.input = createInputInstance(this);\r\n\t    this.touchAction = new TouchAction(this, this.options.touchAction);\r\n\t\r\n\t    toggleCssProps(this, true);\r\n\t\r\n\t    each(options.recognizers, function(item) {\r\n\t        var recognizer = this.add(new (item[0])(item[1]));\r\n\t        item[2] && each(item[2], recognizer.recognizeWith, recognizer);\r\n\t        item[3] && each(item[3], recognizer.requireFailure, recognizer);\r\n\t    }, this);\r\n\t}\r\n\t\r\n\tManager.prototype = {\r\n\t    /**\r\n\t     * set options\r\n\t     * @param {String} option\r\n\t     * @param {*} val\r\n\t     */\r\n\t    set: function(option, val) {\r\n\t        this.options[option] = val;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * stop recognizing for this session.\r\n\t     * This session will be discarded, when a new [input]start event is fired.\r\n\t     * When forced, the recognizer cycle is stopped immediately.\r\n\t     * @param {Boolean} [force]\r\n\t     */\r\n\t    stop: function(force) {\r\n\t        this.session.stopped = force ? FORCED_STOP : STOP;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * run the recognizers!\r\n\t     * called by the inputHandler function on every movement of the pointers (touches)\r\n\t     * it walks through all the recognizers and tries to detect the gesture that is being made\r\n\t     * @param {Object} inputData\r\n\t     */\r\n\t    recognize: function(inputData) {\r\n\t        if (this.session.stopped) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        // run the touch-action polyfill\r\n\t        this.touchAction.preventDefaults(inputData);\r\n\t\r\n\t        var recognizer;\r\n\t        var session = this.session;\r\n\t\r\n\t        // this holds the recognizer that is being recognized.\r\n\t        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\r\n\t        // if no recognizer is detecting a thing, it is set to `null`\r\n\t        var curRecognizer = session.curRecognizer;\r\n\t\r\n\t        // reset when the last recognizer is recognized\r\n\t        // or when we're in a new session\r\n\t        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\r\n\t            curRecognizer = session.curRecognizer = null;\r\n\t        }\r\n\t\r\n\t        for (var i = 0, len = this.recognizers.length; i < len; i++) {\r\n\t            recognizer = this.recognizers[i];\r\n\t\r\n\t            // find out if we are allowed try to recognize the input for this one.\r\n\t            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\r\n\t            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\r\n\t            //      that is being recognized.\r\n\t            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\r\n\t            //      this can be setup with the `recognizeWith()` method on the recognizer.\r\n\t            if (this.session.stopped !== FORCED_STOP && ( // 1\r\n\t                    !curRecognizer || recognizer == curRecognizer || // 2\r\n\t                    recognizer.canRecognizeWith(curRecognizer))) { // 3\r\n\t                recognizer.recognize(inputData);\r\n\t            } else {\r\n\t                recognizer.reset();\r\n\t            }\r\n\t\r\n\t            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\r\n\t            // current active recognizer. but only if we don't already have an active recognizer\r\n\t            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\r\n\t                curRecognizer = session.curRecognizer = recognizer;\r\n\t            }\r\n\t        }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * get a recognizer by its event name.\r\n\t     * @param {Recognizer|String} recognizer\r\n\t     * @returns {Recognizer|Null}\r\n\t     */\r\n\t    get: function(recognizer) {\r\n\t        if (recognizer instanceof Recognizer) {\r\n\t            return recognizer;\r\n\t        }\r\n\t\r\n\t        var recognizers = this.recognizers;\r\n\t        for (var i = 0; i < recognizers.length; i++) {\r\n\t            if (recognizers[i].options.event == recognizer) {\r\n\t                return recognizers[i];\r\n\t            }\r\n\t        }\r\n\t        return null;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * add a recognizer to the manager\r\n\t     * existing recognizers with the same event name will be removed\r\n\t     * @param {Recognizer} recognizer\r\n\t     * @returns {Recognizer}\r\n\t     */\r\n\t    add: function(recognizer) {\r\n\t        // remove existing\r\n\t        var existing = this.get(recognizer.options.event);\r\n\t        if (existing) {\r\n\t            this.remove(existing);\r\n\t        }\r\n\t\r\n\t        this.recognizers.push(recognizer);\r\n\t        recognizer.manager = this;\r\n\t\r\n\t        this.touchAction.update();\r\n\t        return recognizer;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * remove a recognizer by name or instance\r\n\t     * @param {Recognizer|String} recognizer\r\n\t     */\r\n\t    remove: function(recognizer) {\r\n\t        var recognizers = this.recognizers;\r\n\t        recognizer = this.get(recognizer);\r\n\t        recognizers.splice(inArray(recognizers, recognizer), 1);\r\n\t\r\n\t        this.touchAction.update();\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * bind event\r\n\t     * @param {String} events\r\n\t     * @param {Function} handler\r\n\t     * @returns {EventEmitter} this\r\n\t     */\r\n\t    on: function(events, handler) {\r\n\t        var handlers = this.handlers;\r\n\t        each(splitStr(events), function(event) {\r\n\t            handlers[event] = handlers[event] || [];\r\n\t            handlers[event].push(handler);\r\n\t        });\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * unbind event, leave emit blank to remove all handlers\r\n\t     * @param {String} events\r\n\t     * @param {Function} [handler]\r\n\t     * @returns {EventEmitter} this\r\n\t     */\r\n\t    off: function(events, handler) {\r\n\t        var handlers = this.handlers;\r\n\t        each(splitStr(events), function(event) {\r\n\t            if (!handler) {\r\n\t                delete handlers[event];\r\n\t            } else {\r\n\t                handlers[event].splice(inArray(handlers[event], handler), 1);\r\n\t            }\r\n\t        });\r\n\t        return this;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * emit event to the listeners\r\n\t     * @param {String} event\r\n\t     * @param {Object} data\r\n\t     */\r\n\t    emit: function(event, data) {\r\n\t        // we also want to trigger dom events\r\n\t        if (this.options.domEvents) {\r\n\t            triggerDomEvent(event, data);\r\n\t        }\r\n\t\r\n\t        // no handlers, so skip it all\r\n\t        var handlers = this.handlers[event];\r\n\t        if (!handlers || !handlers.length) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        data.type = event;\r\n\t        data.preventDefault = function() {\r\n\t            data.srcEvent.preventDefault();\r\n\t        };\r\n\t\r\n\t        for (var i = 0, len = handlers.length; i < len; i++) {\r\n\t            handlers[i](data);\r\n\t        }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * destroy the manager and unbinds all events\r\n\t     * it doesn't unbind dom events, that is the user own responsibility\r\n\t     */\r\n\t    destroy: function() {\r\n\t        if (this.element) {\r\n\t            toggleCssProps(this, false);\r\n\t        }\r\n\t\r\n\t        this.handlers = {};\r\n\t        this.session = {};\r\n\t        this.input.destroy();\r\n\t        this.element = null;\r\n\t    }\r\n\t};\r\n\t\r\n\t/**\r\n\t * add/remove the css properties as defined in manager.options.cssProps\r\n\t * @param {Manager} manager\r\n\t * @param {Boolean} add\r\n\t */\r\n\tfunction toggleCssProps(manager, add) {\r\n\t    var element = manager.element;\r\n\t    var cssProps = manager.options.cssProps;\r\n\t\r\n\t    each(cssProps, function(value, name) {\r\n\t        element.style[prefixed(element.style, name)] = add ? value : '';\r\n\t    });\r\n\t\r\n\t    var falseFn = add && function() { return false; };\r\n\t    if (cssProps.userSelect == 'none') { element.onselectstart = falseFn; }\r\n\t    if (cssProps.userDrag == 'none') { element.ondragstart = falseFn; }\r\n\t}\r\n\t\r\n\t/**\r\n\t * trigger dom event\r\n\t * @param {String} event\r\n\t * @param {Object} data\r\n\t */\r\n\tfunction triggerDomEvent(event, data) {\r\n\t    var gestureEvent = document.createEvent('Event');\r\n\t    gestureEvent.initEvent(event, true, true);\r\n\t    gestureEvent.gesture = data;\r\n\t    data.target.dispatchEvent(gestureEvent);\r\n\t}\r\n\t\r\n\textend(Hammer, {\r\n\t    INPUT_START: INPUT_START,\r\n\t    INPUT_MOVE: INPUT_MOVE,\r\n\t    INPUT_END: INPUT_END,\r\n\t    INPUT_CANCEL: INPUT_CANCEL,\r\n\t\r\n\t    STATE_POSSIBLE: STATE_POSSIBLE,\r\n\t    STATE_BEGAN: STATE_BEGAN,\r\n\t    STATE_CHANGED: STATE_CHANGED,\r\n\t    STATE_ENDED: STATE_ENDED,\r\n\t    STATE_RECOGNIZED: STATE_RECOGNIZED,\r\n\t    STATE_CANCELLED: STATE_CANCELLED,\r\n\t    STATE_FAILED: STATE_FAILED,\r\n\t\r\n\t    DIRECTION_NONE: DIRECTION_NONE,\r\n\t    DIRECTION_LEFT: DIRECTION_LEFT,\r\n\t    DIRECTION_RIGHT: DIRECTION_RIGHT,\r\n\t    DIRECTION_UP: DIRECTION_UP,\r\n\t    DIRECTION_DOWN: DIRECTION_DOWN,\r\n\t    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\r\n\t    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\r\n\t    DIRECTION_ALL: DIRECTION_ALL,\r\n\t\r\n\t    Manager: Manager,\r\n\t    Input: Input,\r\n\t    TouchAction: TouchAction,\r\n\t\r\n\t    Recognizer: Recognizer,\r\n\t    AttrRecognizer: AttrRecognizer,\r\n\t    Tap: TapRecognizer,\r\n\t    Pan: PanRecognizer,\r\n\t    Swipe: SwipeRecognizer,\r\n\t    Pinch: PinchRecognizer,\r\n\t    Rotate: RotateRecognizer,\r\n\t    Press: PressRecognizer,\r\n\t\r\n\t    on: addEventListeners,\r\n\t    off: removeEventListeners,\r\n\t    each: each,\r\n\t    merge: merge,\r\n\t    extend: extend,\r\n\t    inherit: inherit,\r\n\t    bindFn: bindFn,\r\n\t    prefixed: prefixed\r\n\t});\r\n\t\r\n\tif (\"function\" == TYPE_FUNCTION && __webpack_require__(4)) {\r\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\r\n\t        return Hammer;\r\n\t    }.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t} else if (typeof module != TYPE_UNDEFINED && module.exports) {\r\n\t    module.exports = Hammer;\r\n\t} else {\r\n\t    window.Hammer = Hammer;\r\n\t}\r\n\t\r\n\t})(window);\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * kind of messy code, but good enough for now\r\n\t */\r\n\t// polyfill\r\n\tvar reqAnimationFrame = (function () {\r\n\t    return window[Hammer.prefixed(window, 'requestAnimationFrame')] || function (callback) {\r\n\t        window.setTimeout(callback, 1000 / 60);\r\n\t    };\r\n\t})();\r\n\t\r\n\tvar el = document.querySelector(\"#hitarea\");\r\n\t\r\n\tvar startX = Math.round((el.parentNode.offsetWidth - el.offsetWidth) / 2);\r\n\tvar startY = Math.round((el.parentNode.offsetHeight - el.offsetHeight) / 2);\r\n\t\r\n\tvar ticking = false;\r\n\tvar transform;\r\n\t\r\n\tvar mc = new Hammer(el);\r\n\t\r\n\tmc.get('pinch').set('enable', true);\r\n\tmc.get('rotate').set('enable', true);\r\n\t\r\n\tmc.on(\"pan\", onPan);\r\n\tmc.on(\"swipe\", onSwipe);\r\n\tmc.on(\"rotate\", onRotate);\r\n\tmc.on(\"pinch\", onPinch);\r\n\tmc.on(\"tap\", onTap);\r\n\tmc.on(\"doubletap\", onDoubleTap);\r\n\tmc.on(\"hold\", onHold);\r\n\t\r\n\tmc.on(\"panstart rotatestart pinchstart\", resetElementStart);\r\n\tmc.on(\"panend rotateend pinchend pancancel rotatecancel pinchcancel\", resetElementEnd);\r\n\t\r\n\tfunction resetElementStart() {\r\n\t    el.className = '';\r\n\t}\r\n\t\r\n\tfunction resetElementEnd() {\r\n\t    transform = {\r\n\t        translate: { x: startX, y: startY },\r\n\t        scale: 1,\r\n\t        rotate: 0\r\n\t    };\r\n\t    el.className = 'animate';\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction updateElementTransform() {\r\n\t    var value = [\r\n\t        'translate3d(' + transform.translate.x + 'px, ' + transform.translate.y + 'px, 0)',\r\n\t        'scale(' + transform.scale + ', ' + transform.scale + ')',\r\n\t        'rotate(' + transform.rotate + 'deg)'];\r\n\t    el.style.webkitTransform = el.style.transform = value.join(\" \");\r\n\t    ticking = false;\r\n\t}\r\n\t\r\n\tfunction requestElementUpdate() {\r\n\t    if(!ticking) {\r\n\t        ticking = true;\r\n\t        reqAnimationFrame(updateElementTransform);\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction onPan(ev) {\r\n\t    transform.translate = {\r\n\t        x: startX + ev.deltaX,\r\n\t        y: startY + ev.deltaY\r\n\t    };\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction onSwipe(ev) {\r\n\t    transform.translate = {\r\n\t        x: startX + (ev.deltaX * 1.2),\r\n\t        y: startY + (ev.deltaY * 1.2)\r\n\t    };\r\n\t    transform.scale = 1.2;\r\n\t    requestElementUpdate();\r\n\t\r\n\t    setTimeout(function () {\r\n\t        resetElementEnd();\r\n\t    }, 400);\r\n\t}\r\n\t\r\n\tfunction onPinch(ev) {\r\n\t    transform.scale = ev.scale;\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction onRotate(ev) {\r\n\t    transform.rotate = ev.rotation;\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction onTap(ev) {\r\n\t    transform.scale = .9;\r\n\t    requestElementUpdate();\r\n\t\r\n\t    setTimeout(function () {\r\n\t        transform.scale = 1;\r\n\t        requestElementUpdate();\r\n\t    }, 200);\r\n\t}\r\n\t\r\n\tfunction onDoubleTap(ev) {\r\n\t    transform.rotate = !transform.rotate ? 360 : 0;\r\n\t    requestElementUpdate();\r\n\t}\r\n\t\r\n\tfunction onHold(ev) {\r\n\t    el.style.background = '#fd0';\r\n\t    setTimeout(function () {\r\n\t        el.style.background = 'white';\r\n\t        requestElementUpdate();\r\n\t    }, 500);\r\n\t}\r\n\t\r\n\tresetElementEnd();\r\n\t\r\n\tdocument.querySelector(\".device-button\").addEventListener(\"click\", function(){\r\n\t    document.querySelector(\".device\").classList.toggle('hammertime');\r\n\t}, false);\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tif(location.href.indexOf(\".github.io\") > -1) {\r\n\t    var _gaq = _gaq || [];\r\n\t    _gaq.push(['_setAccount', 'UA-30289566-1']);\r\n\t    _gaq.push(['_trackPageview']);\r\n\t    (function () {\r\n\t        var ga = document.createElement('script');\r\n\t        ga.type = 'text/javascript';\r\n\t        ga.async = true;\r\n\t        ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';\r\n\t        var s = document.getElementsByTagName('script')[0];\r\n\t        s.parentNode.insertBefore(ga, s);\r\n\t    })();\r\n\t}\r\n\t\r\n\t!function (d, s, id) {\r\n\t    var js, fjs = d.getElementsByTagName(s)[0];\r\n\t    if (!d.getElementById(id)) {\r\n\t        js = d.createElement(s);\r\n\t        js.id = id;\r\n\t        js.src = \"//platform.twitter.com/widgets.js\";\r\n\t        fjs.parentNode.insertBefore(js, fjs);\r\n\t    }\r\n\t}(document, \"script\", \"twitter-wjs\");\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ }\n/******/ ])"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/assets/js/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);","window.Hammer = require('../../../node_modules/hammerjs/hammer.js');\r\n\r\nvar toggle = document.querySelector(\".toggle-sidebar\");\r\nvar target = document.querySelector(\".sidebar\");\r\nif(toggle && target) {\r\n    toggle.addEventListener(\"click\", function(ev) {\r\n        if(target.className.indexOf('show') === -1) {\r\n            target.className += ' show';\r\n        } else {\r\n            target.className = target.className.replace('show', '');\r\n        }\r\n        ev.preventDefault();\r\n    });\r\n}\r\n\r\n\r\nif(document.querySelector(\"#hitarea\")) {\r\n    require('./demo.js');\r\n}\r\n\r\nrequire('./externals.js');\r\n","(function(window, undefined) {\r\n  'use strict';\r\n\r\nvar VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];\r\n\r\nvar TYPE_FUNCTION = 'function';\r\nvar TYPE_UNDEFINED = 'undefined';\r\n\r\n/**\r\n * walk objects and arrays\r\n * @param {Object} obj\r\n * @param {Function} iterator\r\n * @param {Object} context\r\n */\r\nfunction each(obj, iterator, context) {\r\n    var i, len;\r\n\r\n    if (!obj) {\r\n        return;\r\n    }\r\n\r\n    if (obj.forEach) {\r\n        obj.forEach(iterator, context);\r\n    } else if (obj.length !== undefined) {\r\n        for (i = 0, len = obj.length; i < len; i++) {\r\n            iterator.call(context, obj[i], i, obj);\r\n        }\r\n    } else {\r\n        for (i in obj) {\r\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * extend object.\r\n * means that properties in dest will be overwritten by the ones in src.\r\n * @param {Object} dest\r\n * @param {Object} src\r\n * @param {Boolean} [merge]\r\n * @returns {Object} dest\r\n */\r\nfunction extend(dest, src, merge) {\r\n    var keys = Object.keys(src);\r\n    for (var i = 0, len = keys.length; i < len; i++) {\r\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\r\n            dest[keys[i]] = src[keys[i]];\r\n        }\r\n    }\r\n    return dest;\r\n}\r\n\r\n/**\r\n * merge the values from src in the dest.\r\n * means that properties that exist in dest will not be overwritten by src\r\n * @param {Object} dest\r\n * @param {Object} src\r\n * @returns {Object} dest\r\n */\r\nfunction merge(dest, src) {\r\n    return extend(dest, src, true);\r\n}\r\n\r\n/**\r\n * simple class inheritance\r\n * @param {Function} child\r\n * @param {Function} base\r\n * @param {Object} [properties]\r\n */\r\nfunction inherit(child, base, properties) {\r\n    var baseP = base.prototype,\r\n        childP;\r\n\r\n    // object create is supported since IE9\r\n    if (Object.create) {\r\n        childP = child.prototype = Object.create(baseP);\r\n        childP.constructor = child;\r\n    } else {\r\n        extend(child, base);\r\n        var Inherited = function() {\r\n            this.constructor = child;\r\n        };\r\n        Inherited.prototype = baseP;\r\n        childP = child.prototype = new Inherited();\r\n    }\r\n\r\n    if (properties) {\r\n        extend(childP, properties);\r\n    }\r\n\r\n    childP._super = baseP;\r\n}\r\n\r\n/**\r\n * simple function bind\r\n * @param {Function} fn\r\n * @param {Object} context\r\n * @returns {Function}\r\n */\r\nfunction bindFn(fn, context) {\r\n    return function() {\r\n        return fn.apply(context, arguments);\r\n    };\r\n}\r\n\r\n/**\r\n * let a boolean value also be a function that must return a boolean\r\n * this first item in args will be used as the context\r\n * @param {Boolean|Function} val\r\n * @param {Array} [args]\r\n * @returns {Boolean}\r\n */\r\nfunction boolOrFn(val, args) {\r\n    if (typeof val == TYPE_FUNCTION) {\r\n        return val.apply(args ? args[0] || window : window, args);\r\n    }\r\n    return val;\r\n}\r\n\r\n/**\r\n * use the val2 when val1 is undefined\r\n * @param {*} val1\r\n * @param {*} val2\r\n * @returns {*}\r\n */\r\nfunction ifUndefined(val1, val2) {\r\n    return (val1 === undefined) ? val2 : val1;\r\n}\r\n\r\n/**\r\n * addEventListener with multiple events at once\r\n * @param {HTMLElement} element\r\n * @param {String} types\r\n * @param {Function} handler\r\n */\r\nfunction addEventListeners(element, types, handler) {\r\n    each(splitStr(types), function(type) {\r\n        element.addEventListener(type, handler, false);\r\n    });\r\n}\r\n\r\n/**\r\n * removeEventListener with multiple events at once\r\n * @param {HTMLElement} element\r\n * @param {String} types\r\n * @param {Function} handler\r\n */\r\nfunction removeEventListeners(element, types, handler) {\r\n    each(splitStr(types), function(type) {\r\n        element.removeEventListener(type, handler, false);\r\n    });\r\n}\r\n\r\n/**\r\n * find if a node is in the given parent\r\n * @method hasParent\r\n * @param {HTMLElement} node\r\n * @param {HTMLElement} parent\r\n * @return {Boolean} found\r\n */\r\nfunction hasParent(node, parent) {\r\n    while (node) {\r\n        if (node == parent) {\r\n            return true;\r\n        }\r\n        node = node.parentNode;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * store Math.round in a var, for better minimisation\r\n */\r\nvar round = Math.round;\r\n\r\n/**\r\n * small indexOf wrapper\r\n * @param {String} str\r\n * @param {String} find\r\n * @returns {Boolean} found\r\n */\r\nfunction inStr(str, find) {\r\n    return str.indexOf(find) > -1;\r\n}\r\n\r\n/**\r\n * split string on whitespace\r\n * @param {String} str\r\n * @returns {Array} words\r\n */\r\nfunction splitStr(str) {\r\n    return str.trim().split(/\\s+/g);\r\n}\r\n\r\n/**\r\n * find if a array contains the object using indexOf or a simple polyFill\r\n * @param {Array} src\r\n * @param {String} find\r\n * @param {String} [findByKey]\r\n * @return {Boolean|Number} false when not found, or the index\r\n */\r\nfunction inArray(src, find, findByKey) {\r\n    if (src.indexOf && !findByKey) {\r\n        return src.indexOf(find);\r\n    } else {\r\n        for (var i = 0, len = src.length; i < len; i++) {\r\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n\r\n/**\r\n * convert array-like objects to real arrays\r\n * @param {Object} obj\r\n * @returns {Array}\r\n */\r\nfunction toArray(obj) {\r\n    return Array.prototype.slice.call(obj, 0);\r\n}\r\n\r\n/**\r\n * unique array with objects based on a key (like 'id') or just by the array's value\r\n * @param {Array} src [{id:1},{id:2},{id:1}]\r\n * @param {String} [key]\r\n * @returns {Array} [{id:1},{id:2}]\r\n */\r\nfunction uniqueArray(src, key) {\r\n    var results = [];\r\n    var values = [];\r\n    for (var i = 0, len = src.length; i < len; i++) {\r\n        var val = key ? src[i][key] : src[i];\r\n        if (inArray(values, val) < 0) {\r\n            results.push(src[i]);\r\n        }\r\n        values[i] = val;\r\n    }\r\n    return results;\r\n}\r\n\r\n/**\r\n * get the prefixed property\r\n * @param {Object} obj\r\n * @param {String} property\r\n * @returns {String|Undefined} prefixed\r\n */\r\nfunction prefixed(obj, property) {\r\n    var prefix, prop;\r\n    var camelProp = property[0].toUpperCase() + property.slice(1);\r\n\r\n    for (var i = 0, len = VENDOR_PREFIXES.length; i < len; i++) {\r\n        prefix = VENDOR_PREFIXES[i];\r\n        prop = (prefix) ? prefix + camelProp : property;\r\n\r\n        if (prop in obj) {\r\n            return prop;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * get a unique id\r\n * @returns {number} uniqueId\r\n */\r\nvar _uniqueId = 1;\r\nfunction uniqueId() {\r\n    return _uniqueId++;\r\n}\r\n\r\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\r\n\r\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\r\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\r\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\r\n\r\nvar INPUT_TYPE_TOUCH = 'touch';\r\nvar INPUT_TYPE_PEN = 'pen';\r\nvar INPUT_TYPE_MOUSE = 'mouse';\r\nvar INPUT_TYPE_KINECT = 'kinect';\r\n\r\nvar COMPUTE_INTERVAL = 25;\r\n\r\nvar INPUT_START = 1;\r\nvar INPUT_MOVE = 2;\r\nvar INPUT_END = 4;\r\nvar INPUT_CANCEL = 8;\r\n\r\nvar DIRECTION_NONE = 1;\r\nvar DIRECTION_LEFT = 2;\r\nvar DIRECTION_RIGHT = 4;\r\nvar DIRECTION_UP = 8;\r\nvar DIRECTION_DOWN = 16;\r\n\r\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\r\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\r\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\r\n\r\nvar PROPS_XY = ['x', 'y'];\r\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\r\n\r\n/**\r\n * create new input type manager\r\n * @param {Manager} manager\r\n * @param {Function} callback\r\n * @returns {Input}\r\n * @constructor\r\n */\r\nfunction Input(manager, callback) {\r\n    var self = this;\r\n    this.manager = manager;\r\n    this.callback = callback;\r\n\r\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\r\n    // so when disabled the input events are completely bypassed.\r\n    this.domHandler = function(ev) {\r\n        if (boolOrFn(self.manager.options.enable, [self.manager])) {\r\n            self.handler(ev);\r\n        }\r\n    };\r\n\r\n    this.evEl && addEventListeners(this.manager.element, this.evEl, this.domHandler);\r\n    this.evWin && addEventListeners(window, this.evWin, this.domHandler);\r\n}\r\n\r\nInput.prototype = {\r\n    /**\r\n     * should handle the inputEvent data and trigger the callback\r\n     * @virtual\r\n     */\r\n    handler: function() { },\r\n\r\n    /**\r\n     * unbind the events\r\n     */\r\n    destroy: function() {\r\n        this.elEvents && removeEventListeners(this.manager.element, this.elEvents, this.domHandler);\r\n        this.winEvents && removeEventListeners(window, this.winEvents, this.domHandler);\r\n    }\r\n};\r\n\r\n/**\r\n * create new input type manager\r\n * @param {Hammer} manager\r\n * @returns {Input}\r\n */\r\nfunction createInputInstance(manager) {\r\n    var Type;\r\n    if (SUPPORT_POINTER_EVENTS) {\r\n        Type = PointerEventInput;\r\n    } else if (SUPPORT_ONLY_TOUCH) {\r\n        Type = TouchInput;\r\n    } else if (!SUPPORT_TOUCH) {\r\n        Type = MouseInput;\r\n    } else {\r\n        Type = TouchMouseInput;\r\n    }\r\n    return new (Type)(manager, inputHandler);\r\n}\r\n\r\n/**\r\n * handle input events\r\n * @param {Manager} manager\r\n * @param {String} eventType\r\n * @param {Object} input\r\n */\r\nfunction inputHandler(manager, eventType, input) {\r\n    var pointersLen = input.pointers.length;\r\n    var changedPointersLen = input.changedPointers.length;\r\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\r\n    var isFinal = (eventType & INPUT_END && (pointersLen - changedPointersLen === 0));\r\n\r\n    input.isFirst = isFirst;\r\n    input.isFinal = isFinal;\r\n\r\n    if (isFirst) {\r\n        manager.session = {};\r\n    }\r\n    // source event is the normalized value of the domEvents\r\n    // like 'touchstart, mouseup, pointerdown'\r\n    input.eventType = eventType;\r\n\r\n    // compute scale, rotation etc\r\n    computeInputData(manager, input);\r\n\r\n    manager.recognize(input);\r\n}\r\n\r\n/**\r\n * extend the data with some usable properties like scale, rotate, velocity etc\r\n * @param {Object} manager\r\n * @param {Object} input\r\n */\r\nfunction computeInputData(manager, input) {\r\n    var session = manager.session;\r\n    var pointers = input.pointers;\r\n    var pointersLength = pointers.length;\r\n\r\n    // store the first input to calculate the distance and direction\r\n    if (!session.firstInput) {\r\n        session.firstInput = simpleCloneInputData(input);\r\n    }\r\n\r\n    // to compute scale and rotation we need to store the multiple touches\r\n    if (pointersLength > 1 && !session.firstMultiple) {\r\n        session.firstMultiple = simpleCloneInputData(input);\r\n    } else if (pointersLength === 1) {\r\n        session.firstMultiple = false;\r\n    }\r\n\r\n    var firstInput = session.firstInput;\r\n    var firstMultiple = session.firstMultiple;\r\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\r\n    var center = getCenter(pointers);\r\n\r\n    input.timeStamp = Date.now();\r\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\r\n    input.deltaX = center.x - offsetCenter.x;\r\n    input.deltaY = center.y - offsetCenter.y;\r\n\r\n    input.center = center;\r\n    input.angle = getAngle(offsetCenter, center);\r\n    input.distance = getDistance(offsetCenter, center);\r\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\r\n\r\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\r\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\r\n\r\n    // find the correct target\r\n    var target = manager.element;\r\n    if (hasParent(input.srcEvent.target, target)) {\r\n        target = input.srcEvent.target;\r\n    }\r\n    input.target = target;\r\n\r\n    computeIntervalInputData(session, input);\r\n}\r\n\r\n/**\r\n * velocity is calculated every x ms\r\n * @param {Object} session\r\n * @param {Object} input\r\n */\r\nfunction computeIntervalInputData(session, input) {\r\n    var last = session.lastInterval;\r\n    if (!last) {\r\n        last = session.lastInterval = simpleCloneInputData(input);\r\n    }\r\n\r\n    var deltaTime = input.timeStamp - last.timeStamp,\r\n        velocity,\r\n        velocityX,\r\n        velocityY,\r\n        direction;\r\n\r\n    if (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined) {\r\n        var deltaX = last.deltaX - input.deltaX;\r\n        var deltaY = last.deltaY - input.deltaY;\r\n\r\n        var v = getVelocity(deltaTime, deltaX, deltaY);\r\n        velocityX = v.x;\r\n        velocityY = v.y;\r\n        velocity = Math.max(v.x, v.y);\r\n        direction = getDirection(deltaX, deltaY);\r\n    } else {\r\n        // use latest velocity info if it doesn't overtake a minimum period\r\n        velocity = last.velocity;\r\n        velocityX = last.velocityX;\r\n        velocityY = last.velocityY;\r\n        direction = last.direction;\r\n    }\r\n\r\n    input.velocity = velocity;\r\n    input.velocityX = velocityX;\r\n    input.velocityY = velocityY;\r\n    input.direction = direction;\r\n}\r\n\r\n/**\r\n * create a simple clone from the input used for storage of firstInput and firstMultiple\r\n * @param {Object} input\r\n * @returns {Object} clonedInputData\r\n */\r\nfunction simpleCloneInputData(input) {\r\n    // make a simple copy of the pointers because we will get a reference if we don't\r\n    // we only need clientXY for the calculations\r\n    var pointers = [];\r\n    for (var i = 0; i < input.pointers.length; i++) {\r\n        pointers[i] = {\r\n            clientX: round(input.pointers[i].clientX),\r\n            clientY: round(input.pointers[i].clientY)\r\n        };\r\n    }\r\n\r\n    return {\r\n        timeStamp: Date.now(),\r\n        pointers: pointers,\r\n        center: getCenter(pointers),\r\n        deltaX: input.deltaX,\r\n        deltaY: input.deltaY\r\n    };\r\n}\r\n\r\n/**\r\n * get the center of all the pointers\r\n * @param {Array} pointers\r\n * @return {Object} center contains `x` and `y` properties\r\n */\r\nfunction getCenter(pointers) {\r\n    var pointersLength = pointers.length;\r\n\r\n    // no need to loop when only one touch\r\n    if (pointersLength === 1) {\r\n        return {\r\n            x: round(pointers[0].clientX),\r\n            y: round(pointers[0].clientY)\r\n        };\r\n    }\r\n\r\n    var x = 0, y = 0;\r\n    for (var i = 0; i < pointersLength; i++) {\r\n        x += pointers[i].clientX;\r\n        y += pointers[i].clientY;\r\n    }\r\n\r\n    return {\r\n        x: round(x / pointersLength),\r\n        y: round(y / pointersLength)\r\n    };\r\n}\r\n\r\n/**\r\n * calculate the velocity between two points. unit is in px per ms.\r\n * @param {Number} deltaTime\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Object} velocity `x` and `y`\r\n */\r\nfunction getVelocity(deltaTime, x, y) {\r\n    return {\r\n        x: Math.abs(x / deltaTime) || 0,\r\n        y: Math.abs(y / deltaTime) || 0\r\n    };\r\n}\r\n\r\n/**\r\n * get the direction between two points\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Number} direction\r\n */\r\nfunction getDirection(x, y) {\r\n    if (x === y) {\r\n        return DIRECTION_NONE;\r\n    }\r\n\r\n    if (Math.abs(x) >= Math.abs(y)) {\r\n        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n    }\r\n    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\r\n}\r\n\r\n/**\r\n * calculate the absolute distance between two points\r\n * @param {Object} p1 {x, y}\r\n * @param {Object} p2 {x, y}\r\n * @param {Array} [props] containing x and y keys\r\n * @return {Number} distance\r\n */\r\nfunction getDistance(p1, p2, props) {\r\n    if (!props) {\r\n        props = PROPS_XY;\r\n    }\r\n    var x = p2[props[0]] - p1[props[0]],\r\n        y = p2[props[1]] - p1[props[1]];\r\n\r\n    return Math.sqrt((x * x) + (y * y));\r\n}\r\n\r\n/**\r\n * calculate the angle between two coordinates\r\n * @param {Object} p1\r\n * @param {Object} p2\r\n * @param {Array} [props] containing x and y keys\r\n * @return {Number} angle\r\n */\r\nfunction getAngle(p1, p2, props) {\r\n    if (!props) {\r\n        props = PROPS_XY;\r\n    }\r\n    var x = p2[props[0]] - p1[props[0]],\r\n        y = p2[props[1]] - p1[props[1]];\r\n    return Math.atan2(y, x) * 180 / Math.PI;\r\n}\r\n\r\n/**\r\n * calculate the rotation degrees between two pointersets\r\n * @param {Array} start array of pointers\r\n * @param {Array} end array of pointers\r\n * @return {Number} rotation\r\n */\r\nfunction getRotation(start, end) {\r\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);\r\n}\r\n\r\n/**\r\n * calculate the scale factor between two pointersets\r\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\r\n * @param {Array} start array of pointers\r\n * @param {Array} end array of pointers\r\n * @return {Number} scale\r\n */\r\nfunction getScale(start, end) {\r\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\r\n}\r\n\r\nvar MOUSE_INPUT_MAP = {\r\n    mousedown: INPUT_START,\r\n    mousemove: INPUT_MOVE,\r\n    mouseup: INPUT_END,\r\n    mouseout: INPUT_CANCEL\r\n};\r\n\r\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\r\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseout mouseup';\r\n\r\n/**\r\n * Mouse events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction MouseInput() {\r\n    this.evEl = MOUSE_ELEMENT_EVENTS;\r\n    this.evWin = MOUSE_WINDOW_EVENTS;\r\n\r\n    this.allow = true; // used by Input.TouchMouse to disable mouse events\r\n    this.pressed = false; // mousedown state\r\n\r\n    Input.apply(this, arguments);\r\n}\r\n\r\ninherit(MouseInput, Input, {\r\n    /**\r\n     * handle mouse events\r\n     * @param {Object} ev\r\n     */\r\n    handler: function(ev) {\r\n        var eventType = MOUSE_INPUT_MAP[ev.type];\r\n\r\n        // on start we want to have the left mouse button down\r\n        if (eventType & INPUT_START && ev.button === 0) {\r\n            this.pressed = true;\r\n        }\r\n\r\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\r\n            eventType = INPUT_END;\r\n        }\r\n\r\n        // mouse must be down, and mouse events are allowed (see the TouchMouse input)\r\n        if (!this.pressed || !this.allow) {\r\n            return;\r\n        }\r\n\r\n        // out of the window?\r\n        var target = ev.relatedTarget || ev.toElement || ev.target;\r\n        if (ev.type == 'mouseout' && target.nodeName != 'HTML') {\r\n            eventType = INPUT_MOVE;\r\n        }\r\n\r\n        if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n            this.pressed = false;\r\n        }\r\n\r\n        this.callback(this.manager, eventType, {\r\n            pointers: [ev],\r\n            changedPointers: [ev],\r\n            pointerType: INPUT_TYPE_MOUSE,\r\n            srcEvent: ev\r\n        });\r\n    },\r\n});\r\n\r\nvar POINTER_INPUT_MAP = {\r\n    pointerdown: INPUT_START,\r\n    pointermove: INPUT_MOVE,\r\n    pointerup: INPUT_END,\r\n    pointercancel: INPUT_CANCEL,\r\n    pointerout: INPUT_CANCEL\r\n};\r\n\r\n// in IE10 the pointer types is defined as an enum\r\nvar IE10_POINTER_TYPE_ENUM = {\r\n    2: INPUT_TYPE_TOUCH,\r\n    3: INPUT_TYPE_PEN,\r\n    4: INPUT_TYPE_MOUSE,\r\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\r\n};\r\n\r\nvar POINTER_ELEMENT_EVENTS = 'pointerdown pointermove pointerup pointercancel';\r\nvar POINTER_WINDOW_EVENTS = 'pointerout';\r\n\r\n// IE10 has prefixed support, and case-sensitive\r\nif (window.MSPointerEvent) {\r\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown MSPointerMove MSPointerUp MSPointerCancel';\r\n    POINTER_WINDOW_EVENTS = 'MSPointerOut';\r\n}\r\n\r\n/**\r\n * Pointer events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction PointerEventInput() {\r\n    this.evEl = POINTER_ELEMENT_EVENTS;\r\n    this.evWin = POINTER_WINDOW_EVENTS;\r\n\r\n    Input.apply(this, arguments);\r\n\r\n    this.store = (this.manager.session.pointerEvents = []);\r\n}\r\n\r\ninherit(PointerEventInput, Input, {\r\n    /**\r\n     * handle mouse events\r\n     * @param {Object} ev\r\n     */\r\n    handler: function(ev) {\r\n        var store = this.store;\r\n        var removePointer = false;\r\n\r\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\r\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\r\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\r\n\r\n        // out of the window?\r\n        var target = ev.relatedTarget || ev.toElement || ev.target;\r\n        if (eventTypeNormalized == 'pointerout' && target.nodeName != 'HTML') {\r\n            eventType = INPUT_MOVE;\r\n        }\r\n\r\n        // start and mouse must be down\r\n        if (eventType & INPUT_START && (ev.button === 0 || pointerType == INPUT_TYPE_TOUCH)) {\r\n            store.push(ev);\r\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n            removePointer = true;\r\n        }\r\n\r\n        // get index of the event in the store\r\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\r\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\r\n        if (storeIndex < 0) {\r\n            return;\r\n        }\r\n\r\n        // update the event in the store\r\n        store[storeIndex] = ev;\r\n\r\n        this.callback(this.manager, eventType, {\r\n            pointers: store,\r\n            changedPointers: [ev],\r\n            pointerType: pointerType,\r\n            srcEvent: ev\r\n        });\r\n\r\n        if (removePointer) {\r\n            // remove from the store\r\n            store.splice(storeIndex, 1);\r\n        }\r\n    }\r\n});\r\n\r\nvar TOUCH_INPUT_MAP = {\r\n    touchstart: INPUT_START,\r\n    touchmove: INPUT_MOVE,\r\n    touchend: INPUT_END,\r\n    touchcancel: INPUT_CANCEL\r\n};\r\n\r\nvar TOUCH_EVENTS = 'touchstart touchmove touchend touchcancel';\r\n\r\n/**\r\n * Touch events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction TouchInput() {\r\n    this.evEl = TOUCH_EVENTS;\r\n    this.targetIds = {};\r\n\r\n    Input.apply(this, arguments);\r\n}\r\n\r\ninherit(TouchInput, Input, {\r\n    /**\r\n     * handle touch events\r\n     * @param {Object} ev\r\n     */\r\n    handler: function(ev) {\r\n        var touches = normalizeTouches(ev, this);\r\n        this.callback(this.manager, TOUCH_INPUT_MAP[ev.type], {\r\n            pointers: touches[0],\r\n            changedPointers: touches[1],\r\n            pointerType: INPUT_TYPE_TOUCH,\r\n            srcEvent: ev\r\n        });\r\n    }\r\n});\r\n\r\n/**\r\n * make sure all browsers return the same touches\r\n * @param {Object} ev\r\n * @param {TouchInput} touchInput\r\n * @returns {Array} [all, changed]\r\n */\r\nfunction normalizeTouches(ev, touchInput) {\r\n    var i, len;\r\n\r\n    var targetIds = touchInput.targetIds;\r\n    var targetTouches = toArray(ev.targetTouches);\r\n    var changedTouches = toArray(ev.changedTouches);\r\n    var changedTargetTouches = [];\r\n\r\n    // collect touches\r\n    if (ev.type == 'touchstart') {\r\n        for (i = 0, len = targetTouches.length; i < len; i++) {\r\n            targetIds[targetTouches[i].identifier] = true;\r\n        }\r\n    }\r\n\r\n    // filter changed touches to only contain touches that exist in the collected target ids\r\n    for (i = 0, len = changedTouches.length; i < len; i++) {\r\n        if (targetIds[changedTouches[i].identifier]) {\r\n            changedTargetTouches.push(changedTouches[i]);\r\n        }\r\n\r\n        // cleanup removed touches\r\n        if (ev.type == 'touchend'|| ev.type == 'touchcancel') {\r\n            delete targetIds[changedTouches[i].identifier];\r\n        }\r\n    }\r\n\r\n    return [\r\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\r\n        // also removed the duplicates\r\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier'),\r\n\r\n        // only the changed :-)\r\n        changedTargetTouches\r\n    ];\r\n}\r\n\r\n/**\r\n * Combined touch and mouse input\r\n *\r\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\r\n * This because touch devices also emit mouse events while doing a touch.\r\n *\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction TouchMouseInput() {\r\n    Input.apply(this, arguments);\r\n\r\n    var handler = bindFn(this.handler, this);\r\n    this.touch = new TouchInput(this.manager, handler);\r\n    this.mouse = new MouseInput(this.manager, handler);\r\n}\r\n\r\ninherit(TouchMouseInput, Input, {\r\n    /**\r\n     * handle mouse and touch events\r\n     * @param {Hammer} manager\r\n     * @param {String} inputEvent\r\n     * @param {Object} inputData\r\n     */\r\n    handler: function(manager, inputEvent, inputData) {\r\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\r\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\r\n\r\n        // when we're in a touch event, so  block all upcoming mouse events\r\n        // most mobile browser also emit mouseevents, right after touchstart\r\n        if (isTouch) {\r\n            this.mouse.allow = false;\r\n        } else if (isMouse && !this.mouse.allow) {\r\n            return;\r\n        }\r\n\r\n        // reset the allowMouse when we're done\r\n        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {\r\n            this.mouse.allow = true;\r\n        }\r\n\r\n        this.callback(manager, inputEvent, inputData);\r\n    },\r\n\r\n    /**\r\n     * remove the event listeners\r\n     */\r\n    destroy: function() {\r\n        this.touch.destroy();\r\n        this.mouse.destroy();\r\n    }\r\n});\r\n\r\nvar PREFIXED_TOUCH_ACTION = prefixed(document.body.style, 'touchAction');\r\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\r\n\r\n// magical touchAction value\r\nvar TOUCH_ACTION_COMPUTE = 'compute';\r\nvar TOUCH_ACTION_AUTO = 'auto';\r\nvar TOUCH_ACTION_MANIPULATION = 'manipulation';\r\nvar TOUCH_ACTION_NONE = 'none';\r\nvar TOUCH_ACTION_PAN_X = 'pan-x';\r\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\r\n\r\n/**\r\n * Touch Action\r\n * sets the touchAction property or uses the js alternative\r\n * @param {Manager} manager\r\n * @param {String} value\r\n * @constructor\r\n */\r\nfunction TouchAction(manager, value) {\r\n    this.manager = manager;\r\n    this.set(value);\r\n}\r\n\r\nTouchAction.prototype = {\r\n    /**\r\n     * set the touchAction value on the element or enable the polyfill\r\n     * @param {String} value\r\n     */\r\n    set: function(value) {\r\n        // find out the touch-action by the event handlers\r\n        if (value == TOUCH_ACTION_COMPUTE) {\r\n            value = this.compute();\r\n        }\r\n\r\n        if (NATIVE_TOUCH_ACTION) {\r\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\r\n        }\r\n        this.actions = value.toLowerCase();\r\n    },\r\n\r\n    /**\r\n     * just re-set the touchAction value\r\n     */\r\n    update: function() {\r\n        this.set(this.manager.options.touchAction);\r\n    },\r\n\r\n    /**\r\n     * compute the value for the touchAction property based on the recognizer's settings\r\n     * @returns {String} value\r\n     */\r\n    compute: function() {\r\n        var value;\r\n        var actions = [];\r\n\r\n        each(this.manager.recognizers, function(recognizer) {\r\n            if (boolOrFn(recognizer.options.enable, recognizer)) {\r\n                actions = actions.concat(recognizer.getTouchAction());\r\n            }\r\n        });\r\n        value = uniqueArray(actions).join(' ');\r\n        return cleanTouchActions(value);\r\n    },\r\n\r\n    /**\r\n     * this method is called on each input cycle and provides the preventing of the browser behavior\r\n     * @param {Object} input\r\n     */\r\n    preventDefaults: function(input) {\r\n        // not needed with native support for the touchAction property\r\n        if (NATIVE_TOUCH_ACTION) {\r\n            return;\r\n        }\r\n\r\n        var srcEvent = input.srcEvent;\r\n        var direction = input.offsetDirection;\r\n\r\n        // if the touch action did prevented once this session\r\n        if (this.manager.session.prevented) {\r\n            srcEvent.preventDefault();\r\n            return;\r\n        }\r\n\r\n        var actions = this.actions;\r\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE);\r\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\r\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\r\n\r\n        if (hasNone || (hasPanY && hasPanX) ||\r\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\r\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\r\n            return this.preventSrc(srcEvent);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\r\n     * @param {Object} srcEvent\r\n     */\r\n    preventSrc: function(srcEvent) {\r\n        this.manager.session.prevented = true;\r\n        srcEvent.preventDefault();\r\n    }\r\n};\r\n\r\n/**\r\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\r\n * @param {String} actions\r\n * @returns {*}\r\n */\r\nfunction cleanTouchActions(actions) {\r\n    // none\r\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\r\n        return TOUCH_ACTION_NONE;\r\n    }\r\n    // pan-x and pan-y can be combined\r\n    if (inStr(actions, TOUCH_ACTION_PAN_X) || inStr(actions, TOUCH_ACTION_PAN_Y)) {\r\n        return actions.replace(/[\\-\\w]+/g, function(action) {\r\n            if (/^pan\\-/.test(action)) {\r\n                return action;\r\n            }\r\n            return '';\r\n        });\r\n    }\r\n    // manipulation\r\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\r\n        return TOUCH_ACTION_MANIPULATION;\r\n    }\r\n\r\n    return TOUCH_ACTION_AUTO;\r\n}\r\n\r\n/**\r\n * Recognizer flow explained; *\r\n * All recognizers have the initial state of POSSIBLE when a input session starts.\r\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\r\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\r\n *\r\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\r\n * which determines with state it should be.\r\n *\r\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\r\n * POSSIBLE to give it another change on the next cycle.\r\n *\r\n *               Possible\r\n *                  |\r\n *            +-----+---------------+\r\n *            |                     |\r\n *      +-----+-----+               |\r\n *      |           |               |\r\n *   Failed      Cancelled          |\r\n *                          +-------+------+\r\n *                          |              |\r\n *                      Recognized       Began\r\n *                                         |\r\n *                                      Changed\r\n *                                         |\r\n *                                  Ended/Recognized\r\n */\r\nvar STATE_POSSIBLE = 1;\r\nvar STATE_BEGAN = 2;\r\nvar STATE_CHANGED = 4;\r\nvar STATE_ENDED = 8;\r\nvar STATE_RECOGNIZED = STATE_ENDED;\r\nvar STATE_CANCELLED = 16;\r\nvar STATE_FAILED = 32;\r\n\r\n/**\r\n * Recognizer\r\n * Every recognizer needs to extend from this class.\r\n * @constructor\r\n * @param {Object} options\r\n */\r\nfunction Recognizer(options) {\r\n    this.id = uniqueId();\r\n\r\n    this.manager = null;\r\n    this.options = merge(options || {}, this.defaults);\r\n\r\n    // default is enable true\r\n    this.options.enable = ifUndefined(this.options.enable, true);\r\n\r\n    this.state = STATE_POSSIBLE;\r\n\r\n    this.simultaneous = {};\r\n    this.requireFail = [];\r\n}\r\n\r\nRecognizer.prototype = {\r\n    /**\r\n     * @virtual\r\n     * @type {Object}\r\n     */\r\n    defaults: {},\r\n\r\n    /**\r\n     * set options\r\n     * @param {String} option\r\n     * @param {*} val\r\n     */\r\n    set: function(option, val) {\r\n        this.options[option] = val;\r\n\r\n        // also update the touchAction, in case something changed about the directions/enabled state\r\n        this.manager && this.manager.touchAction.update();\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * recognize simultaneous with an other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    recognizeWith: function(otherRecognizer) {\r\n        var simultaneous = this.simultaneous;\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        if (!simultaneous[otherRecognizer.id]) {\r\n            simultaneous[otherRecognizer.id] = otherRecognizer;\r\n            otherRecognizer.recognizeWith(this);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    dropRecognizeWith: function(otherRecognizer) {\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        delete this.simultaneous[otherRecognizer.id];\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * recognizer can only run when an other is failing\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    requireFailure: function(otherRecognizer) {\r\n        var requireFail = this.requireFail;\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        if (inArray(requireFail, otherRecognizer) === -1) {\r\n            requireFail.push(otherRecognizer);\r\n            otherRecognizer.requireFailure(this);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    dropRequireFailure: function(otherRecognizer) {\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        var index = inArray(this.requireFail, otherRecognizer);\r\n        if (index > -1) {\r\n            this.requireFail.splice(index, 1);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * has require failures boolean\r\n     * @returns {boolean}\r\n     */\r\n    hasRequireFailures: function() {\r\n        return this.requireFail.length > 0;\r\n    },\r\n\r\n    /**\r\n     * if the recognizer can recognize simultaneous with an other recognizer\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Boolean}\r\n     */\r\n    canRecognizeWith: function(otherRecognizer) {\r\n        return !!this.simultaneous[otherRecognizer.id];\r\n    },\r\n\r\n    /**\r\n     * You should use `tryEmit` instead of `emit` directly to check\r\n     * that all the needed recognizers has failed before emitting.\r\n     * @param {Object} input\r\n     */\r\n    emit: function(input) {\r\n        this.manager.emit(this.options.event, input); // simple 'eventName' events\r\n        this.manager.emit(this.options.event + stateStr(this.state), input); // like 'panmove' and 'panstart'\r\n    },\r\n\r\n    /**\r\n     * Check that all the require failure recognizers has failed,\r\n     * if true, it emits a gesture event,\r\n     * otherwise, setup the state to FAILED.\r\n     * @param {Object} input\r\n     */\r\n    tryEmit: function(input) {\r\n        if (this.canEmit()) {\r\n            return this.emit(input);\r\n        }\r\n        // it's failing anyway\r\n        this.state = STATE_FAILED;\r\n    },\r\n\r\n    /**\r\n     * can we emit?\r\n     * @returns {boolean}\r\n     */\r\n    canEmit: function() {\r\n        for (var i = 0; i < this.requireFail.length; i++) {\r\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * update the recognizer\r\n     * @param {Object} inputData\r\n     */\r\n    recognize: function(inputData) {\r\n        // make a new copy of the inputData\r\n        // so we can change the inputData without messing up the other recognizers\r\n        var inputDataClone = extend({}, inputData);\r\n\r\n        // is is enabled and allow recognizing?\r\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\r\n            this.reset();\r\n            this.state = STATE_FAILED;\r\n            return;\r\n        }\r\n\r\n        // reset when we've reached the end\r\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\r\n            this.state = STATE_POSSIBLE;\r\n        }\r\n\r\n        this.state = this.process(inputDataClone);\r\n\r\n        // the recognizer has recognized a gesture\r\n        // so trigger an event\r\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\r\n            this.tryEmit(inputDataClone);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * return the state of the recognizer\r\n     * the actual recognizing happens in this method\r\n     * @virtual\r\n     * @param {Object} inputData\r\n     * @returns {Const} STATE\r\n     */\r\n    process: function(inputData) { }, // jshint ignore:line\r\n\r\n    /**\r\n     * return the preferred touch-action\r\n     * @virtual\r\n     * @returns {Array}\r\n     */\r\n    getTouchAction: function() { },\r\n\r\n    /**\r\n     * called when the gesture isn't allowed to recognize\r\n     * like when another is being recognized or it is disabled\r\n     * @virtual\r\n     */\r\n    reset: function() { }\r\n};\r\n\r\n/**\r\n * get a usable string, used as event postfix\r\n * @param {Const} state\r\n * @returns {String} state\r\n */\r\nfunction stateStr(state) {\r\n    if (state & STATE_CANCELLED) {\r\n        return 'cancel';\r\n    } else if (state & STATE_ENDED) {\r\n        return 'end';\r\n    } else if (state & STATE_CHANGED) {\r\n        return 'move';\r\n    } else if (state & STATE_BEGAN) {\r\n        return 'start';\r\n    }\r\n    return '';\r\n}\r\n\r\n/**\r\n * direction cons to string\r\n * @param {Const} direction\r\n * @returns {String}\r\n */\r\nfunction directionStr(direction) {\r\n    if (direction == DIRECTION_DOWN) {\r\n        return 'down';\r\n    } else if (direction == DIRECTION_UP) {\r\n        return 'up';\r\n    } else if (direction == DIRECTION_LEFT) {\r\n        return 'left';\r\n    } else if (direction == DIRECTION_RIGHT) {\r\n        return 'right';\r\n    }\r\n    return '';\r\n}\r\n\r\n/**\r\n * get a recognizer by name if it is bound to a manager\r\n * @param {Recognizer|String} otherRecognizer\r\n * @param {Recognizer} recognizer\r\n * @returns {Recognizer}\r\n */\r\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\r\n    var manager = recognizer.manager;\r\n    if (manager) {\r\n        return manager.get(otherRecognizer);\r\n    }\r\n    return otherRecognizer;\r\n}\r\n\r\n/**\r\n * This recognizer is just used as a base for the simple attribute recognizers.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nfunction AttrRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(AttrRecognizer, Recognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof AttrRecognizer\r\n     */\r\n    defaults: {\r\n        /**\r\n         * @type {Number}\r\n         * @default 1\r\n         */\r\n        pointers: 1\r\n    },\r\n\r\n    /**\r\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\r\n     * @memberof AttrRecognizer\r\n     * @param {Object} input\r\n     * @returns {Boolean} recognized\r\n     */\r\n    attrTest: function(input) {\r\n        var optionPointers = this.options.pointers;\r\n        return optionPointers === 0 || input.pointers.length === optionPointers;\r\n    },\r\n\r\n    /**\r\n     * Process the input and return the state for the recognizer\r\n     * @memberof AttrRecognizer\r\n     * @param {Object} input\r\n     * @returns {*} State\r\n     */\r\n    process: function(input) {\r\n        var state = this.state;\r\n        var eventType = input.eventType;\r\n\r\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\r\n        var isValid = this.attrTest(input);\r\n\r\n        // on cancel input and we've recognized before, return STATE_CANCELLED\r\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\r\n            return state | STATE_CANCELLED;\r\n        } else if (isRecognized || isValid) {\r\n            if (eventType & INPUT_END) {\r\n                return state | STATE_ENDED;\r\n            } else if (!(state & STATE_BEGAN)) {\r\n                return STATE_BEGAN;\r\n            }\r\n            return state | STATE_CHANGED;\r\n        }\r\n        return STATE_FAILED;\r\n    }\r\n});\r\n\r\n/**\r\n * Pan\r\n * Recognized when the pointer is down and moved in the allowed direction.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction PanRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n\r\n    this.pX = null;\r\n    this.pY = null;\r\n}\r\n\r\ninherit(PanRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PanRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'pan',\r\n        threshold: 10,\r\n        pointers: 1,\r\n        direction: DIRECTION_ALL\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        var direction = this.options.direction;\r\n\r\n        if (direction === DIRECTION_ALL) {\r\n            return [TOUCH_ACTION_NONE];\r\n        }\r\n\r\n        var actions = [];\r\n        if (direction & DIRECTION_HORIZONTAL) {\r\n            actions.push(TOUCH_ACTION_PAN_Y);\r\n        }\r\n        if (direction & DIRECTION_VERTICAL) {\r\n            actions.push(TOUCH_ACTION_PAN_X);\r\n        }\r\n        return actions;\r\n    },\r\n\r\n    directionTest: function(input) {\r\n        var options = this.options;\r\n        var hasMoved = true;\r\n        var distance = input.distance;\r\n        var direction = input.direction;\r\n        var x = input.deltaX;\r\n        var y = input.deltaY;\r\n\r\n\r\n\r\n        // lock to axis?\r\n        if (!(direction & options.direction)) {\r\n            if (options.direction & DIRECTION_HORIZONTAL) {\r\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n                hasMoved = x != this.pX;\r\n                distance = Math.abs(input.deltaX);\r\n            } else {\r\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\r\n                hasMoved = y != this.pY;\r\n                distance = Math.abs(input.deltaY);\r\n            }\r\n        }\r\n        input.direction = direction;\r\n        return hasMoved && distance > options.threshold && direction & options.direction;\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\r\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\r\n    },\r\n\r\n    emit: function(input) {\r\n        this.pX = input.deltaX;\r\n        this.pY = input.deltaY;\r\n\r\n        this._super.emit.call(this, input);\r\n\r\n        var direction = directionStr(input.direction);\r\n        if (direction) {\r\n            this.manager.emit(this.options.event + direction, input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Pinch\r\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction PinchRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(PinchRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PinchRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'pinch',\r\n        threshold: 0,\r\n        pointers: 2\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y];\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return this._super.attrTest.call(this, input) &&\r\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\r\n    },\r\n\r\n    emit: function(input) {\r\n        this._super.emit.call(this, input);\r\n        if (input.scale !== 1) {\r\n            var inOut = input.scale < 1 ? 'in' : 'out';\r\n            this.manager.emit(this.options.event + inOut, input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Press\r\n * Recognized when the pointer is down for x ms without any movement.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nfunction PressRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n\r\n    this._timer = null;\r\n    this._input = null;\r\n}\r\n\r\ninherit(PressRecognizer, Recognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PressRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'press',\r\n        pointers: 1,\r\n        time: 500, // minimal time of the pointer to be pressed\r\n        threshold: 5 // a minimal movement is ok, but keep it low\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_AUTO];\r\n    },\r\n\r\n    process: function(input) {\r\n        var options = this.options;\r\n\r\n        var validPointers = input.pointers.length === options.pointers;\r\n        var validMovement = input.distance < options.threshold;\r\n        var validTime = input.deltaTime > options.time;\r\n\r\n        this._input = input;\r\n\r\n        // we only allow little movement\r\n        // and we've reached an end event, so a tap is possible\r\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\r\n            this.reset();\r\n        } else if (input.eventType & INPUT_START) {\r\n            this.reset();\r\n            var self = this;\r\n            this._timer = setTimeout(function() {\r\n                self.state = STATE_RECOGNIZED;\r\n                self.tryEmit();\r\n            }, options.time);\r\n        }\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    reset: function() {\r\n        clearTimeout(this._timer);\r\n        this._timer = null;\r\n    },\r\n\r\n    emit: function() {\r\n        if (this.state === STATE_RECOGNIZED) {\r\n            this._input.timeStamp = Date.now();\r\n            this.manager.emit(this.options.event, this._input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Rotate\r\n * Recognized when two or more pointer are moving in a circular motion.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction RotateRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(RotateRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof RotateRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'rotate',\r\n        threshold: 0,\r\n        pointers: 2\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_NONE];\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return this._super.attrTest.call(this, input) &&\r\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\r\n    }\r\n});\r\n\r\n/**\r\n * Swipe\r\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction SwipeRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(SwipeRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof SwipeRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'swipe',\r\n        threshold: 10,\r\n        velocity: 0.65,\r\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\r\n        pointers: 1\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return PanRecognizer.prototype.getTouchAction.call(this);\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        var direction = this.options.direction;\r\n        var velocity;\r\n\r\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\r\n            velocity = input.velocity;\r\n        } else if (direction & DIRECTION_HORIZONTAL) {\r\n            velocity = input.velocityX;\r\n        } else if (direction & DIRECTION_VERTICAL) {\r\n            velocity = input.velocityY;\r\n        }\r\n\r\n        return this._super.attrTest.call(this, input) &&\r\n            direction & input.direction &&\r\n            velocity > this.options.velocity && input.eventType & INPUT_END;\r\n    },\r\n\r\n    emit: function(input) {\r\n        this.manager.emit(this.options.event, input);\r\n\r\n        var direction = directionStr(input.direction);\r\n        if (direction) {\r\n            this.manager.emit(this.options.event + direction, input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\r\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\r\n * a single tap.\r\n *\r\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\r\n * multi-taps being recognized.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nfunction TapRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n\r\n    // previous time and center,\r\n    // used for tap counting\r\n    this.pTime = false;\r\n    this.pCenter = false;\r\n\r\n    this._timer = null;\r\n    this._input = null;\r\n    this.count = 0;\r\n}\r\n\r\ninherit(TapRecognizer, Recognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PinchRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'tap',\r\n        pointers: 1,\r\n        taps: 1,\r\n        delay: 300,\r\n        interval: 300, // max time between the multi-tap taps\r\n        time: 250, // max time of the pointer to be down (like finger on the screen)\r\n        threshold: 2, // a minimal movement is ok, but keep it low\r\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_MANIPULATION];\r\n    },\r\n\r\n    process: function(input) {\r\n        var self = this;\r\n        var options = this.options;\r\n\r\n        var validPointers = input.pointers.length === options.pointers;\r\n        var validMovement = input.distance < options.threshold;\r\n        var validTouchTime = input.deltaTime < options.time;\r\n\r\n        this.reset();\r\n\r\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\r\n            return this._setupBeganState();\r\n        }\r\n\r\n        // we only allow little movement\r\n        // and we've reached an end event, so a tap is possible\r\n        if (validMovement && validTouchTime && validPointers) {\r\n            if (input.eventType & INPUT_END) {\r\n                var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\r\n                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\r\n\r\n                this.pTime = input.timeStamp;\r\n                this.pCenter = input.center;\r\n\r\n                if (!validMultiTap || !validInterval) {\r\n                    this.count = 1;\r\n                } else {\r\n                    this.count += 1;\r\n                }\r\n\r\n                this._input = input;\r\n\r\n                // if tap count matches we have recognized it,\r\n                // else it has began recognizing...\r\n                var tapCount = this.count % options.taps;\r\n                if (tapCount === 0) {\r\n                    if (!this.hasRequireFailures()) {\r\n                        return STATE_RECOGNIZED;\r\n                    } else {\r\n                        this._timer = setTimeout(function() {\r\n                            self.state = STATE_RECOGNIZED;\r\n                            self.tryEmit();\r\n                        }, options.delay);\r\n                        return STATE_BEGAN;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return this._setupBeganState();\r\n        }\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    _setupBeganState: function() {\r\n        var self = this;\r\n        this._timer = setTimeout(function() {\r\n            self.state = STATE_FAILED;\r\n        }, this.options.delay);\r\n\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    reset: function() {\r\n        clearTimeout(this._timer);\r\n    },\r\n\r\n    emit: function() {\r\n        if (this.state == STATE_RECOGNIZED ) {\r\n            this._input.tapCount = this.count;\r\n            this.manager.emit(this.options.event, this._input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Simple way to create an manager with a default set of recognizers.\r\n * @param {HTMLElement} element\r\n * @param {Object} [options]\r\n * @constructor\r\n */\r\nfunction Hammer(element, options) {\r\n    options = options || {};\r\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.easyRecognizers);\r\n    return new Manager(element, options);\r\n}\r\n\r\n/**\r\n * Current build version.\r\n * @const {string}\r\n */\r\nHammer.VERSION = '2.0.0dev';\r\n\r\n/**\r\n * default settings\r\n * @namespace\r\n */\r\nHammer.defaults = {\r\n    /**\r\n     * set if DOM events are being triggered.\r\n     * But this is slower and unused by simple implementations, so disabled by default.\r\n     * @type {Boolean}\r\n     * @default false\r\n     */\r\n    domEvents: false,\r\n\r\n    /**\r\n     * The value for the touchAction property/fallback.\r\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\r\n     * @type {String}\r\n     * @default compute\r\n     */\r\n    touchAction: TOUCH_ACTION_COMPUTE,\r\n\r\n    /**\r\n     * @type {Boolean}\r\n     * @default true\r\n     */\r\n    enable: true,\r\n\r\n    /**\r\n     * Default recognizer setup when calling `Hammer()`\r\n     * When creating a new Manager these will be skipped.\r\n     * @type {Array}\r\n     */\r\n    easyRecognizers: [\r\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\r\n        [RotateRecognizer, { enable: false }],\r\n        [PinchRecognizer, { enable: false }, ['rotate']],\r\n        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],\r\n        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\r\n        [TapRecognizer],\r\n        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\r\n        [PressRecognizer]\r\n    ],\r\n\r\n    /**\r\n     * Some CSS properties can be used to improve the working of Hammer.\r\n     * Add them to this method and they will be set when creating a new Manager.\r\n     * @namespace\r\n     */\r\n    cssProps: {\r\n        /**\r\n         * Disables text selection to improve the dragging gesture. When the value is `none` it also sets\r\n         * `onselectstart=false` for IE9 on the element. Mainly for desktop browsers.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        userSelect: 'none',\r\n\r\n        /**\r\n         * Disable the Windows Phone grippers when pressing an element.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        touchSelect: 'none',\r\n\r\n        /**\r\n         * Disables the default callout shown when you touch and hold a touch target.\r\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\r\n         * a callout containing information about the link. This property allows you to disable that callout.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        touchCallout: 'none',\r\n\r\n        /**\r\n         * Specifies whether zooming is enabled. Used by IE10>\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        contentZooming: 'none',\r\n\r\n        /**\r\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        userDrag: 'none',\r\n\r\n        /**\r\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\r\n         * clickable element in iOS. This property obeys the alpha value, if specified.\r\n         * @type {String}\r\n         * @default 'rgba(0,0,0,0)'\r\n         */\r\n        tapHighlightColor: 'rgba(0,0,0,0)'\r\n    }\r\n};\r\n\r\nvar STOP = 1;\r\nvar FORCED_STOP = 2;\r\n\r\n/**\r\n * Manager\r\n * @param {HTMLElement} element\r\n * @param {Object} [options]\r\n * @constructor\r\n */\r\nfunction Manager(element, options) {\r\n    options = options || {};\r\n\r\n    this.options = merge(options, Hammer.defaults);\r\n\r\n    this.handlers = {};\r\n    this.session = {};\r\n    this.recognizers = [];\r\n\r\n    this.element = element;\r\n    this.input = createInputInstance(this);\r\n    this.touchAction = new TouchAction(this, this.options.touchAction);\r\n\r\n    toggleCssProps(this, true);\r\n\r\n    each(options.recognizers, function(item) {\r\n        var recognizer = this.add(new (item[0])(item[1]));\r\n        item[2] && each(item[2], recognizer.recognizeWith, recognizer);\r\n        item[3] && each(item[3], recognizer.requireFailure, recognizer);\r\n    }, this);\r\n}\r\n\r\nManager.prototype = {\r\n    /**\r\n     * set options\r\n     * @param {String} option\r\n     * @param {*} val\r\n     */\r\n    set: function(option, val) {\r\n        this.options[option] = val;\r\n    },\r\n\r\n    /**\r\n     * stop recognizing for this session.\r\n     * This session will be discarded, when a new [input]start event is fired.\r\n     * When forced, the recognizer cycle is stopped immediately.\r\n     * @param {Boolean} [force]\r\n     */\r\n    stop: function(force) {\r\n        this.session.stopped = force ? FORCED_STOP : STOP;\r\n    },\r\n\r\n    /**\r\n     * run the recognizers!\r\n     * called by the inputHandler function on every movement of the pointers (touches)\r\n     * it walks through all the recognizers and tries to detect the gesture that is being made\r\n     * @param {Object} inputData\r\n     */\r\n    recognize: function(inputData) {\r\n        if (this.session.stopped) {\r\n            return;\r\n        }\r\n\r\n        // run the touch-action polyfill\r\n        this.touchAction.preventDefaults(inputData);\r\n\r\n        var recognizer;\r\n        var session = this.session;\r\n\r\n        // this holds the recognizer that is being recognized.\r\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\r\n        // if no recognizer is detecting a thing, it is set to `null`\r\n        var curRecognizer = session.curRecognizer;\r\n\r\n        // reset when the last recognizer is recognized\r\n        // or when we're in a new session\r\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\r\n            curRecognizer = session.curRecognizer = null;\r\n        }\r\n\r\n        for (var i = 0, len = this.recognizers.length; i < len; i++) {\r\n            recognizer = this.recognizers[i];\r\n\r\n            // find out if we are allowed try to recognize the input for this one.\r\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\r\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\r\n            //      that is being recognized.\r\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\r\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\r\n            if (this.session.stopped !== FORCED_STOP && ( // 1\r\n                    !curRecognizer || recognizer == curRecognizer || // 2\r\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\r\n                recognizer.recognize(inputData);\r\n            } else {\r\n                recognizer.reset();\r\n            }\r\n\r\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\r\n            // current active recognizer. but only if we don't already have an active recognizer\r\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\r\n                curRecognizer = session.curRecognizer = recognizer;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * get a recognizer by its event name.\r\n     * @param {Recognizer|String} recognizer\r\n     * @returns {Recognizer|Null}\r\n     */\r\n    get: function(recognizer) {\r\n        if (recognizer instanceof Recognizer) {\r\n            return recognizer;\r\n        }\r\n\r\n        var recognizers = this.recognizers;\r\n        for (var i = 0; i < recognizers.length; i++) {\r\n            if (recognizers[i].options.event == recognizer) {\r\n                return recognizers[i];\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * add a recognizer to the manager\r\n     * existing recognizers with the same event name will be removed\r\n     * @param {Recognizer} recognizer\r\n     * @returns {Recognizer}\r\n     */\r\n    add: function(recognizer) {\r\n        // remove existing\r\n        var existing = this.get(recognizer.options.event);\r\n        if (existing) {\r\n            this.remove(existing);\r\n        }\r\n\r\n        this.recognizers.push(recognizer);\r\n        recognizer.manager = this;\r\n\r\n        this.touchAction.update();\r\n        return recognizer;\r\n    },\r\n\r\n    /**\r\n     * remove a recognizer by name or instance\r\n     * @param {Recognizer|String} recognizer\r\n     */\r\n    remove: function(recognizer) {\r\n        var recognizers = this.recognizers;\r\n        recognizer = this.get(recognizer);\r\n        recognizers.splice(inArray(recognizers, recognizer), 1);\r\n\r\n        this.touchAction.update();\r\n    },\r\n\r\n    /**\r\n     * bind event\r\n     * @param {String} events\r\n     * @param {Function} handler\r\n     * @returns {EventEmitter} this\r\n     */\r\n    on: function(events, handler) {\r\n        var handlers = this.handlers;\r\n        each(splitStr(events), function(event) {\r\n            handlers[event] = handlers[event] || [];\r\n            handlers[event].push(handler);\r\n        });\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * unbind event, leave emit blank to remove all handlers\r\n     * @param {String} events\r\n     * @param {Function} [handler]\r\n     * @returns {EventEmitter} this\r\n     */\r\n    off: function(events, handler) {\r\n        var handlers = this.handlers;\r\n        each(splitStr(events), function(event) {\r\n            if (!handler) {\r\n                delete handlers[event];\r\n            } else {\r\n                handlers[event].splice(inArray(handlers[event], handler), 1);\r\n            }\r\n        });\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * emit event to the listeners\r\n     * @param {String} event\r\n     * @param {Object} data\r\n     */\r\n    emit: function(event, data) {\r\n        // we also want to trigger dom events\r\n        if (this.options.domEvents) {\r\n            triggerDomEvent(event, data);\r\n        }\r\n\r\n        // no handlers, so skip it all\r\n        var handlers = this.handlers[event];\r\n        if (!handlers || !handlers.length) {\r\n            return;\r\n        }\r\n\r\n        data.type = event;\r\n        data.preventDefault = function() {\r\n            data.srcEvent.preventDefault();\r\n        };\r\n\r\n        for (var i = 0, len = handlers.length; i < len; i++) {\r\n            handlers[i](data);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * destroy the manager and unbinds all events\r\n     * it doesn't unbind dom events, that is the user own responsibility\r\n     */\r\n    destroy: function() {\r\n        if (this.element) {\r\n            toggleCssProps(this, false);\r\n        }\r\n\r\n        this.handlers = {};\r\n        this.session = {};\r\n        this.input.destroy();\r\n        this.element = null;\r\n    }\r\n};\r\n\r\n/**\r\n * add/remove the css properties as defined in manager.options.cssProps\r\n * @param {Manager} manager\r\n * @param {Boolean} add\r\n */\r\nfunction toggleCssProps(manager, add) {\r\n    var element = manager.element;\r\n    var cssProps = manager.options.cssProps;\r\n\r\n    each(cssProps, function(value, name) {\r\n        element.style[prefixed(element.style, name)] = add ? value : '';\r\n    });\r\n\r\n    var falseFn = add && function() { return false; };\r\n    if (cssProps.userSelect == 'none') { element.onselectstart = falseFn; }\r\n    if (cssProps.userDrag == 'none') { element.ondragstart = falseFn; }\r\n}\r\n\r\n/**\r\n * trigger dom event\r\n * @param {String} event\r\n * @param {Object} data\r\n */\r\nfunction triggerDomEvent(event, data) {\r\n    var gestureEvent = document.createEvent('Event');\r\n    gestureEvent.initEvent(event, true, true);\r\n    gestureEvent.gesture = data;\r\n    data.target.dispatchEvent(gestureEvent);\r\n}\r\n\r\nextend(Hammer, {\r\n    INPUT_START: INPUT_START,\r\n    INPUT_MOVE: INPUT_MOVE,\r\n    INPUT_END: INPUT_END,\r\n    INPUT_CANCEL: INPUT_CANCEL,\r\n\r\n    STATE_POSSIBLE: STATE_POSSIBLE,\r\n    STATE_BEGAN: STATE_BEGAN,\r\n    STATE_CHANGED: STATE_CHANGED,\r\n    STATE_ENDED: STATE_ENDED,\r\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\r\n    STATE_CANCELLED: STATE_CANCELLED,\r\n    STATE_FAILED: STATE_FAILED,\r\n\r\n    DIRECTION_NONE: DIRECTION_NONE,\r\n    DIRECTION_LEFT: DIRECTION_LEFT,\r\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\r\n    DIRECTION_UP: DIRECTION_UP,\r\n    DIRECTION_DOWN: DIRECTION_DOWN,\r\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\r\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\r\n    DIRECTION_ALL: DIRECTION_ALL,\r\n\r\n    Manager: Manager,\r\n    Input: Input,\r\n    TouchAction: TouchAction,\r\n\r\n    Recognizer: Recognizer,\r\n    AttrRecognizer: AttrRecognizer,\r\n    Tap: TapRecognizer,\r\n    Pan: PanRecognizer,\r\n    Swipe: SwipeRecognizer,\r\n    Pinch: PinchRecognizer,\r\n    Rotate: RotateRecognizer,\r\n    Press: PressRecognizer,\r\n\r\n    on: addEventListeners,\r\n    off: removeEventListeners,\r\n    each: each,\r\n    merge: merge,\r\n    extend: extend,\r\n    inherit: inherit,\r\n    bindFn: bindFn,\r\n    prefixed: prefixed\r\n});\r\n\r\nif (typeof define == TYPE_FUNCTION && define.amd) {\r\n    define(function() {\r\n        return Hammer;\r\n    });\r\n} else if (typeof module != TYPE_UNDEFINED && module.exports) {\r\n    module.exports = Hammer;\r\n} else {\r\n    window.Hammer = Hammer;\r\n}\r\n\r\n})(window);","/**\r\n * kind of messy code, but good enough for now\r\n */\r\n// polyfill\r\nvar reqAnimationFrame = (function () {\r\n    return window[Hammer.prefixed(window, 'requestAnimationFrame')] || function (callback) {\r\n        window.setTimeout(callback, 1000 / 60);\r\n    };\r\n})();\r\n\r\nvar el = document.querySelector(\"#hitarea\");\r\n\r\nvar startX = Math.round((el.parentNode.offsetWidth - el.offsetWidth) / 2);\r\nvar startY = Math.round((el.parentNode.offsetHeight - el.offsetHeight) / 2);\r\n\r\nvar ticking = false;\r\nvar transform;\r\n\r\nvar mc = new Hammer(el);\r\n\r\nmc.get('pinch').set('enable', true);\r\nmc.get('rotate').set('enable', true);\r\n\r\nmc.on(\"pan\", onPan);\r\nmc.on(\"swipe\", onSwipe);\r\nmc.on(\"rotate\", onRotate);\r\nmc.on(\"pinch\", onPinch);\r\nmc.on(\"tap\", onTap);\r\nmc.on(\"doubletap\", onDoubleTap);\r\nmc.on(\"hold\", onHold);\r\n\r\nmc.on(\"panstart rotatestart pinchstart\", resetElementStart);\r\nmc.on(\"panend rotateend pinchend pancancel rotatecancel pinchcancel\", resetElementEnd);\r\n\r\nfunction resetElementStart() {\r\n    el.className = '';\r\n}\r\n\r\nfunction resetElementEnd() {\r\n    transform = {\r\n        translate: { x: startX, y: startY },\r\n        scale: 1,\r\n        rotate: 0\r\n    };\r\n    el.className = 'animate';\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction updateElementTransform() {\r\n    var value = [\r\n        'translate3d(' + transform.translate.x + 'px, ' + transform.translate.y + 'px, 0)',\r\n        'scale(' + transform.scale + ', ' + transform.scale + ')',\r\n        'rotate(' + transform.rotate + 'deg)'];\r\n    el.style.webkitTransform = el.style.transform = value.join(\" \");\r\n    ticking = false;\r\n}\r\n\r\nfunction requestElementUpdate() {\r\n    if(!ticking) {\r\n        ticking = true;\r\n        reqAnimationFrame(updateElementTransform);\r\n    }\r\n}\r\n\r\nfunction onPan(ev) {\r\n    transform.translate = {\r\n        x: startX + ev.deltaX,\r\n        y: startY + ev.deltaY\r\n    };\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction onSwipe(ev) {\r\n    transform.translate = {\r\n        x: startX + (ev.deltaX * 1.2),\r\n        y: startY + (ev.deltaY * 1.2)\r\n    };\r\n    transform.scale = 1.2;\r\n    requestElementUpdate();\r\n\r\n    setTimeout(function () {\r\n        resetElementEnd();\r\n    }, 400);\r\n}\r\n\r\nfunction onPinch(ev) {\r\n    transform.scale = ev.scale;\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction onRotate(ev) {\r\n    transform.rotate = ev.rotation;\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction onTap(ev) {\r\n    transform.scale = .9;\r\n    requestElementUpdate();\r\n\r\n    setTimeout(function () {\r\n        transform.scale = 1;\r\n        requestElementUpdate();\r\n    }, 200);\r\n}\r\n\r\nfunction onDoubleTap(ev) {\r\n    transform.rotate = !transform.rotate ? 360 : 0;\r\n    requestElementUpdate();\r\n}\r\n\r\nfunction onHold(ev) {\r\n    el.style.background = '#fd0';\r\n    setTimeout(function () {\r\n        el.style.background = 'white';\r\n        requestElementUpdate();\r\n    }, 500);\r\n}\r\n\r\nresetElementEnd();\r\n\r\ndocument.querySelector(\".device-button\").addEventListener(\"click\", function(){\r\n    document.querySelector(\".device\").classList.toggle('hammertime');\r\n}, false);\r\n","if(location.href.indexOf(\".github.io\") > -1) {\r\n    var _gaq = _gaq || [];\r\n    _gaq.push(['_setAccount', 'UA-30289566-1']);\r\n    _gaq.push(['_trackPageview']);\r\n    (function () {\r\n        var ga = document.createElement('script');\r\n        ga.type = 'text/javascript';\r\n        ga.async = true;\r\n        ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';\r\n        var s = document.getElementsByTagName('script')[0];\r\n        s.parentNode.insertBefore(ga, s);\r\n    })();\r\n}\r\n\r\n!function (d, s, id) {\r\n    var js, fjs = d.getElementsByTagName(s)[0];\r\n    if (!d.getElementById(id)) {\r\n        js = d.createElement(s);\r\n        js.id = id;\r\n        js.src = \"//platform.twitter.com/widgets.js\";\r\n        fjs.parentNode.insertBefore(js, fjs);\r\n    }\r\n}(document, \"script\", \"twitter-wjs\");\r\n","module.exports = __webpack_amd_options__;\r\n"],"sourceRoot":"webpack-module://"}